SQL> @@../sosl_ddl/tables/soslerrorlog.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE TABLE soslerrorlog
  2    ( username    VARCHAR2(256)
  3    , timestamp   TIMESTAMP
  4  	 -- older versions than Oracle 23 use VARCHAR2(1024)
  5    , script      CLOB	   -- VARCHAR2(1024)
  6    , identifier  VARCHAR2(256)
  7    , message     CLOB
  8    , statement   CLOB
  9    )
 10  ;

Table created.

SQL> COMMENT ON TABLE soslerrorlog IS 'Userdefined table for SQLPlus error logging';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.username IS 'Oracle account name';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.timestamp IS 'Time when the error occurred';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.script IS 'Name of the originating script if applicable';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.identifier IS 'User defined identifier string';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.message IS 'ORA, PLA or SP2 error message. No feed back messages are included. For example, "PL/SQL Block Created" is not recorded.';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.statement IS 'The statement causing the error';

Comment created.

SQL> -- package with no dependency on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_sys.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Basic sys util package not using data objects of the Simple Oracle Script Loader, no dependencies.
SQL> CREATE OR REPLACE PACKAGE sosl_sys
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader that have no dependencies on any SOSL object.
  5    * As there are no dependencies, exceptions must be catched or handled by the caller. No logging for this functions and procedures.
  6    */
  7  
  8    /*====================================== start package constants used by SOSL ======================================*/
  9    -- define log_type constants used in SOSL_SERVER_LOG
 10    ERROR_TYPE     CONSTANT CHAR(5) := 'ERROR';
 11    WARNING_TYPE   CONSTANT CHAR(7) := 'WARNING';
 12    FATAL_TYPE     CONSTANT CHAR(5) := 'FATAL';
 13    INFO_TYPE      CONSTANT CHAR(4) := 'INFO';
 14    SUCCESS_TYPE   CONSTANT CHAR(7) := 'SUCCESS';
 15    -- Generic n/a type. Should be different from table defaults like 'not set' as table triggers interpret their DDL default value as fallback
 16    -- to set default values using package variables, which is not supported in table DDL by Oracle using DEFAULT. Packages may use variables
 17    -- from other packages in DEFAULT declarations.
 18    NA_TYPE	      CONSTANT CHAR(3) := 'n/a';
 19    /*====================================== end package constants used by SOSL ======================================*/
 20  
 21    /*====================================== start internal functions made visible for testing ======================================*/
 22    /* PROCEDURE SPLIT_FUNCTION_NAME
 23    * Splits the given function name into its parts. Supposed delimiter is the point ".".
 24    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 25    * @param p_package OUT parameter, contains the package name if any or NULL.
 26    * @param p_function OUT parameter, contains the pure function name.
 27    */
 28    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
 29  				    , p_package       OUT VARCHAR2
 30  				    , p_function      OUT VARCHAR2
 31  				    )
 32    ;
 33    /*====================================== end internal functions made visible for testing ======================================*/
 34  
 35    /* FUNCTION HAS_DB_USER
 36    * Checks if a given user is visible for SOSL by checking ALL_USERS. Users must be visible to SOSL to be able to dynamically
 37    * grant the necessary rights on the API for script execution.
 38    *
 39    * @param p_username The database user name to check.
 40    *
 41    * @return TRUE if the user is visible in ALL_USERS to SOSL, otherwise FALSE.
 42    */
 43    FUNCTION has_db_user(p_username IN VARCHAR2)
 44  	 RETURN BOOLEAN
 45    ;
 46  
 47    /* FUNCTION HAS_FUNCTION
 48    * Checks if a given function or package function name is visible for SOSL by checking ALL_ATTRIBUTES.
 49    *
 50    * @param p_owner The owner of the function or package function name to check.
 51    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 52    * @param p_datatype The return datatype of the function expected, e.g. a valid Oracle datatype like NUMBER or VARCHAR2.
 53    *
 54    * @return TRUE if the function is visible in ALL_ATTRIBUTES to SOSL and has the required return datatype, otherwise FALSE.
 55    */
 56    FUNCTION has_function( p_owner	       IN VARCHAR2
 57  			    , p_function_name  IN VARCHAR2
 58  			    , p_datatype       IN VARCHAR2
 59  			    )
 60  	 RETURN BOOLEAN
 61    ;
 62  
 63    /* FUNCTION LOG_TYPE_VALID
 64    * Central function to check the log type. Currently supports INFO, WARNING, ERROR, FATAL, SUCCESS. If log types should get expanded
 65    * adjust this function first and probably the default value for SOSL_SERVER_LOG.
 66    *
 67    * @param p_log_type The log type to check. Case insensitive.
 68    *
 69    *@return TRUE if the given log type is supported. FALSE if not. Exceptions and errors will lead also to FALSE.
 70    */
 71    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 72  	 RETURN BOOLEAN
 73  	 DETERMINISTIC
 74  	 PARALLEL_ENABLE
 75    ;
 76  
 77    /* FUNCTION GET_VALID_LOG_TYPE
 78    * Verifies an given log type, returns either the given log type as upper case or the defined error default.
 79    *
 80    * @param p_log_type The log type to verify and return. Case insensitive.
 81    * @param p_error_default The alternative log type to return, if the log type is invalid. Must be a valid log type and not INFO or SUCCESS. If invalid, FATAL is returned.
 82    *
 83    * @return The valid log type as upper case on success. The valid error default if log type not supported. FATAL if the error default is invalid.
 84    */
 85    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 86  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_sys.ERROR_TYPE
 87  				  )
 88  	 RETURN VARCHAR2
 89  	 DETERMINISTIC
 90  	 PARALLEL_ENABLE
 91    ;
 92  
 93    /*FUNCTION GET_COL_LENGTH
 94    * Returns the column length for a given table and column or -1 if table or column does not exist from USER_TAB_COLUMNS using
 95    * DATA_LENGTH. DATA_LENGTH is misleading if not a char type or CLOB, as CLOB types report 4000 which is definitely wrong.
 96    * The only types handled are NUMBER and CLOB. All other types return the DATA_LENGTH.
 97    *
 98    * Length for numbers is calculated by adding precision and scale.
 99    *
100    * CLOB will return the PLSQL equation of a VARCHAR2/CLOB, which is 32767 and still wrong, but useful to see if a PLSQL can handle
101    * the CLOB. Be careful with CLOB handling. If source is not a table column, PLSQL most likely limits it to 32767 cutting longer content.
102    *
103    * Objects not in the current schema will not be considered and return -1 AS USER_TAB_COLUMN is used.
104    *
105    * No handling for date and timestamp values, as their char representation has too much dependencies on NLS and formatting to get a
106    * reliable length.
107    *
108    * Byte and char semantic is not considered only the effective chars that can be stored in CHAR or VARCHAR2 as defined by DATA_LENGTH.
109    *
110    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
111    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
112    *
113    * @return The calculated length of the column. Fix PLSQL limit 32767 for CLOB types. DATA_LENGTH for data and timestamp types.
114    */
115    FUNCTION get_col_length( p_table  IN VARCHAR2
116  			      , p_column IN VARCHAR2
117  			      )
118  	 RETURN INTEGER
119    ;
120  
121    /* FUNCTION GET_COL_TYPE
122    * Returns the type of a column from USER_TAB_COLUMNS as defined in DATA_TYPE or NA_TYPE if table or column doesn't exist.
123    * Objects not in the current schema will not be considered and return NA_TYPE.
124    *
125    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
126    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
127    *
128    * @return The type of the column as defined in DATA_TYPE or sosl_sys.NA_TYPE on errors or not found columns and tables.
129    */
130    FUNCTION get_col_type( p_table  IN VARCHAR2
131  			    , p_column IN VARCHAR2
132  			    )
133  	 RETURN VARCHAR2
134    ;
135  
136    /* FUNCTION DISTRIBUTE
137    * This functions distributes char data between a VARCHAR2 and a CLOB variable by the following rules:
138    * p_string empty or NULL: Fill p_string to p_max_string_length - p_split_end length.
139    * p_string length > p_max_string_length: Cut p_string to p_max_string_length, including p_split_end appended.
140    *	  p_clob NOT EMPTY: add split_start, rest of p_string before p_clob content.
141    *	  p_clob EMPTY: add split_start and rest of p_string.
142    * p_string length > 0 and < p_max_string_length: no change of p_string and p_clob.
143    * p_string and p_clob empty or NULL: leave unchanged, return FALSE otherwise always TRUE.
144    * In case of exceptions will try to write SQLERRM to p_string as CLOBs tend to be more error prone.
145    *
146    * @param p_string The string to distribute or check. In PLSQL strings can get 32767 chars long, whereas table columns are limited currently to 4000.
147    * @param p_clob The CLOB to distribute or check. Uses NOCOPY to guarantee that CLOB full length is used as given.
148    * @param p_max_string_length The maximum length p_string should have. If this size is exeeded the string gets distribute between p_string and p_clob.
149    * @param p_split_end The split end characters to indicate that the string is continued in p_clob.
150    * @param p_split_start The split start characters for the continuing string in the CLOB.
151    * @param p_delimiter The delimiter between rest of string in CLOB and original CLOB content, if both have content and string must be splitted.
152    *
153    * @return FALSE if p_string and p_clob are empty/NULL or an exception had occurred, otherwise TRUE.
154    */
155    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
156  			  , p_clob		IN OUT NOCOPY  CLOB
157  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
158  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
159  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
160  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
161  			  )
162  	 RETURN BOOLEAN
163    ;
164  
165    /* FUNCTION CHECK_COL
166    * This function can check NUMBER and VARCHAR2/CHAR columns for length and type. Passing a number for a char column type will result
167    * in FALSE. Providing a P_VALUE with a length longer than the length calculated, will result in FALSE. It will not consider
168    * implicite Oracle conversions. Expects type like defined.
169    *
170    * Number length is calculated by TO_CHAR string representation removing all delimiters and counting only numbers 0-9.
171    * Passing a VARCHAR2 value is valid for CHAR and VARCHAR2 column types.
172    *
173    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
174    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
175    * @param p_value The value for the table column to check against column definition.
176    *
177    * @return TRUE if value and column match in type and length, otherwise FALSE.
178    */
179    FUNCTION check_col( p_table  IN VARCHAR2
180  			 , p_column IN VARCHAR2
181  			 , p_value  IN VARCHAR2
182  			 )
183  	 RETURN BOOLEAN
184    ;
185    FUNCTION check_col( p_table  IN VARCHAR2
186  			 , p_column IN VARCHAR2
187  			 , p_value  IN NUMBER
188  			 )
189  	 RETURN BOOLEAN
190    ;
191  
192    /* FUNCTION TXT_BOOLEAN
193    * Provides text values to display instead of BOOLEAN or NUMBER values interpreted as BOOLEAN. Numbers are interpreted
194    * similar to Oracle SQL, where 0 is FALSE and 1 is TRUE. 1 is considered as TRUE, any other value as FALSE. NULL values
195    * are interpreted as sosl_sys.NA_TYPE. Maximum 10 characters for TRUE/FALSE equation.
196    *
197    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
198    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
199    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
200    *
201    * @return The text equation for the given p_bool value.
202    */
203    FUNCTION txt_boolean( p_bool   IN BOOLEAN
204  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
205  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
206  			   )
207  	 RETURN VARCHAR2
208  	 DETERMINISTIC
209  	 PARALLEL_ENABLE
210    ;
211    FUNCTION txt_boolean( p_bool   IN NUMBER
212  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
213  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
214  			   )
215  	 RETURN VARCHAR2
216  	 DETERMINISTIC
217  	 PARALLEL_ENABLE
218    ;
219  
220    /* FUNCTION YES_NO
221    * A simple wrapper for txt_boolean with YES/NO instead of TRUE/FALSE.
222    *
223    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
224    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
225    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
226    *
227    * @return The text equation for the given p_bool value.
228    */
229    FUNCTION yes_no( p_bool	 IN BOOLEAN
230  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
231  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
232  		      )
233  	 RETURN VARCHAR2
234  	 DETERMINISTIC
235  	 PARALLEL_ENABLE
236    ;
237    FUNCTION yes_no( p_bool	 IN NUMBER
238  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
239  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
240  		      )
241  	 RETURN VARCHAR2
242  	 DETERMINISTIC
243  	 PARALLEL_ENABLE
244    ;
245  
246  END;
247  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_sys.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE PACKAGE BODY sosl_sys
  2  AS
  3    -- for description see header file
  4    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
  5  				    , p_package       OUT VARCHAR2
  6  				    , p_function      OUT VARCHAR2
  7  				    )
  8    IS
  9    BEGIN
 10  	 IF INSTR(p_function_name, '.') > 0
 11  	 THEN
 12  	   p_package   := TRIM(SUBSTR(p_function_name, 1, INSTR(p_function_name, '.') -1));
 13  	   p_function  := TRIM(SUBSTR(p_function_name, INSTR(p_function_name, '.') +1, INSTR(p_function_name, '.', 1, 2) - INSTR(p_function_name, '.') -1));
 14  	 ELSE
 15  	   p_package   := NULL;
 16  	   p_function  := TRIM(p_function_name);
 17  	 END IF;
 18    END split_function_name;
 19  
 20    FUNCTION has_db_user(p_username IN VARCHAR2)
 21  	 RETURN BOOLEAN
 22    IS
 23  	 l_has_user  NUMBER;
 24  	 l_return    BOOLEAN;
 25    BEGIN
 26  	 l_return := FALSE;
 27  	 SELECT COUNT(*) INTO l_has_user FROM all_users WHERE username = p_username;
 28  	 IF l_has_user != 0
 29  	 THEN
 30  	   l_return := TRUE;
 31  	 END IF;
 32  	 RETURN l_return;
 33    END has_db_user;
 34  
 35    FUNCTION has_function( p_owner	       IN VARCHAR2
 36  			    , p_function_name  IN VARCHAR2
 37  			    , p_datatype       IN VARCHAR2
 38  			    )
 39  	 RETURN BOOLEAN
 40    IS
 41  	 l_has_function  NUMBER;
 42  	 l_package	 VARCHAR2(128);
 43  	 l_function	 VARCHAR2(128);
 44  	 l_return	 BOOLEAN;
 45    BEGIN
 46  	 l_return := FALSE;
 47  	 sosl_sys.split_function_name(p_function_name, l_package, l_function);
 48  	 SELECT COUNT(*)
 49  	   INTO l_has_function
 50  	   FROM all_arguments
 51  	  WHERE position		   = 0				     -- only functions
 52  	    AND argument_name		   IS NULL			     -- only functions
 53  	    AND data_type		   = p_datatype
 54  	    AND owner			   = p_owner
 55  	    AND NVL(package_name, 'N/A')   = NVL(UPPER(l_package), 'N/A')    -- may not contain a package name
 56  	    AND object_name		   = UPPER(l_function)
 57  	 ;
 58  	 IF l_has_function != 0
 59  	 THEN
 60  	   l_return := TRUE;
 61  	 END IF;
 62  	 RETURN l_return;
 63    END has_function;
 64  
 65    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 66  	 RETURN BOOLEAN
 67  	 DETERMINISTIC
 68  	 PARALLEL_ENABLE
 69    IS
 70  	 l_return  BOOLEAN;
 71    BEGIN
 72  	 l_return := FALSE;
 73  	 IF UPPER(p_log_type) IN ( sosl_sys.INFO_TYPE
 74  				 , sosl_sys.WARNING_TYPE
 75  				 , sosl_sys.ERROR_TYPE
 76  				 , sosl_sys.FATAL_TYPE
 77  				 , sosl_sys.SUCCESS_TYPE
 78  				 )
 79  	 THEN
 80  	   l_return := TRUE;
 81  	 END IF;
 82  	 RETURN l_return;
 83    EXCEPTION
 84  	 WHEN OTHERS THEN
 85  	   RETURN FALSE;
 86    END log_type_valid;
 87  
 88    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 89  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_sys.ERROR_TYPE
 90  				  )
 91  	 RETURN VARCHAR2
 92  	 DETERMINISTIC
 93  	 PARALLEL_ENABLE
 94    IS
 95  	 l_return  VARCHAR2(30);
 96    BEGIN
 97  	 l_return := sosl_sys.FATAL_TYPE;
 98  	 IF log_type_valid(p_log_type)
 99  	 THEN
100  	   l_return := UPPER(p_log_type);
101  	 ELSE
102  	   IF	   log_type_valid(p_error_default)
103  	      AND  UPPER(p_error_default) NOT IN ( sosl_sys.INFO_TYPE
104  						 , sosl_sys.SUCCESS_TYPE
105  						 )
106  	   THEN
107  	     l_return := UPPER(p_error_default);
108  	   END IF;
109  	 END IF;
110  	 RETURN l_return;
111    EXCEPTION
112  	 WHEN OTHERS THEN
113  	   RETURN sosl_sys.FATAL_TYPE;
114    END get_valid_log_type;
115  
116    FUNCTION get_col_length( p_table  IN VARCHAR2
117  			      , p_column IN VARCHAR2
118  			      )
119  	 RETURN INTEGER
120    IS
121  	 l_return	   INTEGER;
122  	 l_has_column	   INTEGER;
123  	 l_data_type	   user_tab_columns.data_type%TYPE;
124  	 l_data_length	   user_tab_columns.data_length%TYPE;
125  	 l_data_precision  user_tab_columns.data_precision%TYPE;
126  	 l_data_scale	   user_tab_columns.data_scale%TYPE;
127    BEGIN
128  	 l_return := -1;
129  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
130  	 IF l_has_column = 1
131  	 THEN
132  	   -- column match calculate length
133  	   SELECT data_type
134  		, data_length
135  		, data_precision
136  		, data_scale
137  	     INTO l_data_type
138  		, l_data_length
139  		, l_data_precision
140  		, l_data_scale
141  	     FROM user_tab_columns
142  	    WHERE table_name  = UPPER(p_table)
143  	      AND column_name = UPPER(p_column)
144  	   ;
145  	   IF l_data_type = 'NUMBER'
146  	   THEN
147  	     IF l_data_scale != 0
148  	     THEN
149  	       -- consider delimiter
150  	       l_return := l_data_precision + l_data_scale;
151  	     ELSE
152  	       l_return := l_data_precision;
153  	     END IF;
154  	   ELSIF l_data_type = 'CLOB'
155  	   THEN
156  	     l_return := 32767;
157  	   ELSE
158  	     l_return := l_data_length;
159  	   END IF;
160  	 END IF;
161  	 RETURN l_return;
162    EXCEPTION
163  	 WHEN OTHERS THEN
164  	   RETURN -1;
165    END get_col_length;
166  
167    FUNCTION get_col_type( p_table  IN VARCHAR2
168  			    , p_column IN VARCHAR2
169  			    )
170  	 RETURN VARCHAR2
171    IS
172  	 l_return      VARCHAR2(128);
173  	 l_has_column  INTEGER;
174  	 l_data_type   user_tab_columns.data_type%TYPE;
175    BEGIN
176  	 l_return := sosl_sys.NA_TYPE;
177  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
178  	 IF l_has_column = 1
179  	 THEN
180  	   -- column match get data type
181  	   SELECT data_type
182  	     INTO l_return
183  	     FROM user_tab_columns
184  	    WHERE table_name  = UPPER(p_table)
185  	      AND column_name = UPPER(p_column)
186  	   ;
187  	 END IF;
188  	 RETURN l_return;
189    EXCEPTION
190  	 WHEN OTHERS THEN
191  	   RETURN sosl_sys.NA_TYPE;
192    END get_col_type;
193  
194    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
195  			  , p_clob		IN OUT NOCOPY  CLOB
196  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
197  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
198  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
199  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
200  			  )
201  	 RETURN BOOLEAN
202    IS
203  	 l_string  VARCHAR2(32767);
204    BEGIN
205  	 IF	(p_string IS NULL OR NVL(LENGTH(TRIM(p_string)), 0) = 0)
206  	    AND (p_clob   IS NULL OR NVL(LENGTH(TRIM(p_clob)), 0) = 0)
207  	 THEN
208  	   RETURN FALSE;
209  	 END IF;
210  	 IF	p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
211  	    AND p_clob	 IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
212  	 THEN
213  	   IF LENGTH(p_string) > p_max_string_length
214  	   THEN
215  	     -- need to split
216  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1)) || p_delimiter;
217  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
218  	     p_clob   := l_string || p_clob;
219  	   END IF;
220  	   RETURN TRUE;
221  	 END IF;
222  	 IF p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
223  	 THEN
224  	   IF LENGTH(p_string) > p_max_string_length
225  	   THEN
226  	     -- need to split
227  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1));
228  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
229  	     p_clob   := TO_CLOB(l_string);
230  	   ELSE
231  	     p_clob := TO_CLOB(l_string);
232  	   END IF;
233  	   RETURN TRUE;
234  	 END IF;
235  	 IF p_clob IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
236  	 THEN
237  	   IF LENGTH(p_clob) > p_max_string_length
238  	   THEN
239  	     p_string := TO_CHAR(SUBSTR(p_clob, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end);
240  	   ELSE
241  	     p_string := TO_CHAR(p_clob);
242  	   END IF;
243  	   RETURN TRUE;
244  	 END IF;
245  	 -- should not reach this point
246  	 p_string := 'ERROR sosl_sys.distribute: INCOMPLETE LOGIC';
247  	 RETURN FALSE;
248    EXCEPTION
249  	 WHEN OTHERS THEN
250  	   p_string := TRIM(SUBSTR(SQLERRM, 1, 4000));
251  	   RETURN FALSE;
252    END distribute;
253  
254    FUNCTION check_col( p_table  IN VARCHAR2
255  			 , p_column IN VARCHAR2
256  			 , p_value  IN VARCHAR2
257  			 )
258  	 RETURN BOOLEAN
259    IS
260  	 l_return  BOOLEAN;
261    BEGIN
262  	 l_return := FALSE;
263  	 IF sosl_sys.get_col_type(p_table, p_column) IN ('VARCHAR2', 'CHAR')
264  	 THEN
265  	   IF NVL(LENGTH(p_value), 0) <= sosl_sys.get_col_length(p_table, p_column)
266  	   THEN
267  	     l_return := TRUE;
268  	   END IF;
269  	 END IF;
270  	 RETURN l_return;
271    END check_col; -- VARCHAR2 variant
272  
273    FUNCTION check_col( p_table  IN VARCHAR2
274  			 , p_column IN VARCHAR2
275  			 , p_value  IN NUMBER
276  			 )
277  	 RETURN BOOLEAN
278    IS
279  	 l_return  BOOLEAN;
280  	 l_number  VARCHAR2(128);
281    BEGIN
282  	 l_return := FALSE;
283  	 IF sosl_sys.get_col_type(p_table, p_column) = 'NUMBER'
284  	 THEN
285  	   l_number := REGEXP_REPLACE(TO_CHAR(p_value), '[^0-9]', '');
286  	   IF NVL(LENGTH(l_number), 0) <= sosl_sys.get_col_length(p_table, p_column)
287  	   THEN
288  	     l_return := TRUE;
289  	   END IF;
290  	 END IF;
291  	 RETURN l_return;
292    END check_col; -- NUMBER variant
293  
294    FUNCTION txt_boolean( p_bool   IN BOOLEAN
295  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
296  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
297  			   )
298  	 RETURN VARCHAR2
299  	 DETERMINISTIC
300  	 PARALLEL_ENABLE
301    IS
302    BEGIN
303  	 IF p_bool
304  	 THEN
305  	   RETURN TRIM(SUBSTR(NVL(p_true, 'TRUE'), 1, 10));
306  	 ELSE
307  	   RETURN TRIM(SUBSTR(NVL(p_false, 'FALSE'), 1, 10));
308  	 END IF;
309    END txt_boolean; -- boolean input
310  
311    FUNCTION txt_boolean( p_bool   IN NUMBER
312  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
313  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
314  			   )
315  	 RETURN VARCHAR2
316  	 DETERMINISTIC
317  	 PARALLEL_ENABLE
318    IS
319    BEGIN
320  	 RETURN sosl_sys.txt_boolean((p_bool = 1), p_true, p_false);
321    END txt_boolean; -- number input
322  
323    FUNCTION yes_no( p_bool	 IN BOOLEAN
324  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
325  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
326  		      )
327  	 RETURN VARCHAR2
328  	 DETERMINISTIC
329  	 PARALLEL_ENABLE
330    IS
331    BEGIN
332  	 RETURN sosl_sys.txt_boolean(p_bool, p_true, p_false);
333    END yes_no;
334  
335    FUNCTION yes_no( p_bool	 IN NUMBER
336  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
337  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
338  		      )
339  	 RETURN VARCHAR2
340  	 DETERMINISTIC
341  	 PARALLEL_ENABLE
342    IS
343    BEGIN
344  	 RETURN sosl_sys.txt_boolean((p_bool = 1), p_true, p_false);
345    END yes_no;
346  
347  END;
348  /

Package body created.

SQL> -- logging table
SQL> @@../sosl_ddl/tables/sosl_server_log.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_server_log
  2    ( exec_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP 		     NOT NULL
  3  	 -- due to Oracle limitations we must use trigger not a package variable, trigger takes care
  4  	 -- to assign a default INFO log type if getting sosl_sys.NA_TYPE
  5    , log_type	   VARCHAR2(30)    DEFAULT 'n/a'			     NOT NULL
  6    , log_category	   VARCHAR2(256)   DEFAULT 'n/a'			     NOT NULL
  7    , message	   VARCHAR2(4000)					     NOT NULL
  8    , run_id 	   NUMBER(38, 0)
  9    , executor_id	   NUMBER(38, 0)
 10    , guid		   VARCHAR2(64)
 11    , sosl_identifier   VARCHAR2(256)
 12    , caller 	   VARCHAR2(256)
 13    , ext_script_id	   VARCHAR2(4000)
 14    , script_file	   VARCHAR2(4000)
 15    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 16    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , full_message	   CLOB
 18    )
 19    -- monthly partitions
 20    PARTITION BY RANGE (exec_timestamp)
 21    INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
 22    (PARTITION P_OLD
 23  	   VALUES LESS THAN (TO_TIMESTAMP('01-01-2024','DD-MM-YYYY'))
 24    )
 25  ;

Table created.

SQL> COMMENT ON TABLE sosl_server_log IS 'Holds the log events of the SOSL server CMD and interaction with the database as well as database events. Update is not allowed. Will use the alias slog.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.exec_timestamp IS 'The timestamp of the event. Automatically set by trigger, no set allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_type IS 'The logging type, supports currently INFO, WARNING, ERROR, FATAL, SUCCESS. Mandatory. Defined in package SOSL_SYS.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_category IS 'The log writer may provide an short log category description.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.message IS 'The shortend log message. Mandatory. If only a CLOB is passed, the short message is build from the CLOB. Categories too long will be cutted.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.full_message IS 'The full log message. For messages longer than 4000 bytes or char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.guid IS 'The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.sosl_identifier IS 'The exact identifier for SOSLERRORLOG if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.run_id IS 'The associated run id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.executor_id IS 'The associated executor id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.ext_script_id IS 'The (external) script id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.caller IS 'Caller identification if available, to distinguish database processes from SOSL CMD server processes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by IS 'The logged in DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- no primary key, only index
SQL> CREATE INDEX sosl_server_log_idx
  2    ON sosl_server_log (exec_timestamp, log_type, log_category)
  3  ;

Index created.

SQL> -- no constraints, as Oracle does not allow package functions in CHECK conditions
SQL> 
SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_server_log_ins_trg
  2    BEFORE INSERT ON sosl_server_log
  3    FOR EACH ROW
  4  DECLARE
  5    l_split BOOLEAN;
  6  BEGIN
  7    -- first set default value if not set, as Oracle does not support default values from package variables
  8    IF :NEW.log_type = sosl_sys.NA_TYPE
  9    THEN
 10  	 :NEW.log_type := sosl_sys.INFO_TYPE;
 11    END IF;
 12    -- instead of check constraint to get package support
 13    IF NOT sosl_sys.log_type_valid(:NEW.log_type)
 14    THEN
 15  	 -- do not block logging, log the error instead, move message to full message
 16  	 :NEW.full_message := :NEW.message || :NEW.full_message;
 17  	 :NEW.message	   := 'Invalid log type. Not supported by package SOSL_SYS. Given log type: ' || :NEW.log_type;
 18  	 :NEW.log_type	   := sosl_sys.FATAL_TYPE;
 19    ELSE
 20  	 :NEW.log_type := sosl_sys.get_valid_log_type(:NEW.log_type);
 21    END IF;
 22    :NEW.exec_timestamp := SYSTIMESTAMP;
 23    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 24    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 25    -- split messages
 26    IF NOT sosl_sys.distribute(:NEW.message, :NEW.full_message, 4000)
 27    THEN
 28  	 -- do not block logging, log the error instead, if :NEW.message contains error information leave it there
 29  	 IF :NEW.message IS NULL AND :NEW.full_message IS NULL
 30  	 THEN
 31  	   :NEW.message := 'Full message must be given, if message is NULL or vice versa.';
 32  	 END IF;
 33  	 :NEW.log_type := sosl_sys.FATAL_TYPE;
 34    END IF;
 35  END;
 36  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_upd_trg
  2    BEFORE UPDATE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20005, 'No updates allowed on a log table.');
  6  END;
  7  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_del_trg
  2    BEFORE DELETE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20006, 'Delete records from a log table is not allowed. This is an admin job which needs sufficient rights.');
  6  END;
  7  /

Trigger created.

SQL> -- logging package
SQL> @@../sosl_ddl/packages/sosl_log.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Basic logging package, dependencies only to sosl_server_log.
SQL> CREATE OR REPLACE PACKAGE sosl_log
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader for managing logging.
  5    * Apart from sosl_server_log table, there are no dependencies, severe exceptions must be catched or handled by the caller.
  6    * The interface has as well functions and procedures. Functions inform about success or error, whereas procedure exceptions
  7    * must be handled by the caller.
  8    *
  9    * CURRENT ORACLE error: NOCOPY for IN parameters creates compile errors, whereas documentation allows IN NOCOPY var. Any
 10    * CLOB handling errors are possibly caused by the inability to provide a CLOB as reference.
 11    */
 12  
 13    /*====================================== start internal functions made visible for testing ======================================*/
 14    /* PROCEDURE LOG_FALLBACK
 15    * This procedure tries some fallback actions, if logging raised an exception. It will not throw an exception. It will try to log the error in
 16    * SOSL_SERVER_LOG, SOSLERRORLOG, SPERRORLOG or, if everything fails output the error via DBMS_OUTPUT. As we can't determine if the message contains
 17    * an illegal character forcing the exception, the caller should transfer SQLERRM and verify the transmitted content before passing it to this procedure
 18    * or avoid transmitting parameters which should cause errors. If error could be logged to one of the tables, it can be found in this tables with
 19    * identifier SOSL_LOG. It will not prevent the exception, only try to log it somewhere, where it could be found without needing to analyze the db server
 20    * logs. Everything runs as autonomous transaction. DO NOT USE THIS PROCEDURE. It is internal for this package.
 21    *
 22    * @param p_script The package function or procedure causing the error, e.g. SOSL_LOG.LOG_EVENT.
 23    * @param p_identifier The identifier for this error. Saved in SOSL_IDENTIFIER in SOSL_SERVER_LOG or IDENTIFIER in the error log tables.
 24    * @param p_message The message to save. Reduce it to SQLERRM if possible.
 25    */
 26    PROCEDURE log_fallback( p_script      IN VARCHAR2
 27  			     , p_identifier  IN VARCHAR2
 28  			     , p_message     IN VARCHAR2
 29  			     )
 30    ;
 31    /* PROCEDURE LOG_EVENT
 32    * Writes a log entry as autonomous transaction. This is the internal base procedure, exposed for testing.
 33    * If on errors writing log entries is not possible the procedure hands the exception to the caller. This is the pure insert without
 34    * any checks. It takes the values as given and table may trigger exceptions. DO NOT USE THIS PROCEDURE. It is internal for this package.
 35    *
 36    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 37    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Must be valid.
 38    * @param p_log_category An optional logging category.
 39    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 40    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 41    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 42    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 43    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 44    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 45    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 46    */
 47    PROCEDURE log_event( p_message	       IN VARCHAR2
 48  			  , p_log_type	       IN VARCHAR2
 49  			  , p_log_category     IN VARCHAR2
 50  			  , p_guid	       IN VARCHAR2
 51  			  , p_sosl_identifier  IN VARCHAR2
 52  			  , p_executor_id      IN NUMBER
 53  			  , p_ext_script_id    IN VARCHAR2
 54  			  , p_caller	       IN VARCHAR2
 55  			  , p_run_id	       IN NUMBER
 56  			  , p_full_message     IN CLOB
 57  			  )
 58    ;
 59  /*====================================== end internal functions made visible for testing ======================================*/
 60  
 61    /* PROCEDURE FULL_LOG
 62    * Procedure with all parameters for logging. Will check parameters before logging. You should at least set also p_log_category
 63    * and p_caller, to be able to assign the log entry to a specific event and object. On parameter errors a separate log entry is
 64    * created. Intention is to write a log in any case and not throw any exception. This still may happen on main system malfunctions
 65    * but is limited to this events.
 66    *
 67    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 68    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Will be set to ERROR if not valid.
 69    * @param p_log_category An optional logging category.
 70    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 71    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 72    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 73    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 74    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 75    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 76    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 77    */
 78    PROCEDURE full_log( p_message	      IN VARCHAR2
 79  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_sys.INFO_TYPE
 80  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
 81  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
 82  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
 83  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
 84  			 , p_executor_id      IN NUMBER      DEFAULT NULL
 85  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
 86  			 , p_run_id	      IN NUMBER      DEFAULT NULL
 87  			 , p_full_message     IN CLOB	     DEFAULT NULL
 88  			 )
 89    ;
 90  
 91    PROCEDURE cmd_log( p_message	     IN VARCHAR2
 92  			, p_log_type	     IN VARCHAR2     DEFAULT sosl_sys.INFO_TYPE
 93  			, p_caller	     IN VARCHAR2     DEFAULT NULL
 94  			, p_guid	     IN VARCHAR2     DEFAULT NULL
 95  			, p_sosl_identifier  IN VARCHAR2     DEFAULT NULL
 96  			, p_executor_id      IN NUMBER	     DEFAULT NULL
 97  			, p_ext_script_id    IN VARCHAR2     DEFAULT NULL
 98  			, p_full_message     IN CLOB	     DEFAULT NULL
 99  			)
100    ;
101  
102  END;
103  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_log.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE PACKAGE BODY sosl_log
  2  AS
  3    -- for description see header file
  4    PROCEDURE log_fallback( p_script      IN VARCHAR2
  5  			     , p_identifier  IN VARCHAR2
  6  			     , p_message     IN VARCHAR2
  7  			     )
  8    IS
  9  	 PRAGMA AUTONOMOUS_TRANSACTION;
 10  	 l_saved BOOLEAN;
 11    BEGIN
 12  	 l_saved := FALSE;
 13  	 -- try to save information in tables probably available
 14  	 BEGIN
 15  	   INSERT INTO sosl_server_log
 16  	     ( message
 17  	     , log_type
 18  	     , log_category
 19  	     , sosl_identifier
 20  	     , caller
 21  	     )
 22  	     VALUES
 23  	       ( p_message
 24  	       , sosl_sys.FATAL_TYPE
 25  	       , 'SOSL_LOG internal error'
 26  	       , p_identifier
 27  	       , p_script
 28  	       )
 29  	   ;
 30  	   COMMIT;
 31  	   l_saved := TRUE;
 32  	 EXCEPTION
 33  	   WHEN OTHERS THEN
 34  	     l_saved := FALSE;
 35  	 END;
 36  	 IF NOT l_saved
 37  	 THEN
 38  	   BEGIN
 39  	     INSERT INTO soslerrorlog
 40  	       ( message
 41  	       , identifier
 42  	       , script
 43  	       , username
 44  	       , timestamp
 45  	       )
 46  	       VALUES
 47  		 ( p_message
 48  		 , p_identifier
 49  		 , p_script
 50  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 51  		 , SYSTIMESTAMP
 52  		 )
 53  	     ;
 54  	     COMMIT;
 55  	     l_saved := TRUE;
 56  	   EXCEPTION
 57  	     WHEN OTHERS THEN
 58  	       l_saved := FALSE;
 59  	   END;
 60  	 END IF;
 61  	 IF NOT l_saved
 62  	 THEN
 63  	   BEGIN
 64  	     INSERT INTO sperrorlog
 65  	       ( message
 66  	       , identifier
 67  	       , script
 68  	       , username
 69  	       , timestamp
 70  	       )
 71  	       VALUES
 72  		 ( p_message
 73  		 , p_identifier
 74  		 , p_script
 75  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 76  		 , SYSTIMESTAMP
 77  		 )
 78  	     ;
 79  	     COMMIT;
 80  	     l_saved := TRUE;
 81  	   EXCEPTION
 82  	     WHEN OTHERS THEN
 83  	       l_saved := FALSE;
 84  	   END;
 85  	 END IF;
 86  	 -- all inserts failed, use DBMS_OUTPUT
 87  	 IF NOT l_saved
 88  	 THEN
 89  	   BEGIN
 90  	     DBMS_OUTPUT.PUT_LINE('Fatal error in ' || p_script || ' error: ' || p_message);
 91  	   EXCEPTION
 92  	     WHEN OTHERS THEN
 93  	       NULL;
 94  	   END;
 95  	 END IF;
 96    EXCEPTION
 97  	 WHEN OTHERS THEN
 98  	   -- do exactly nothing to avoid an additional exception on database malfunction
 99  	   NULL;
100    END log_fallback;
101  
102    PROCEDURE log_event( p_message	       IN VARCHAR2
103  			  , p_log_type	       IN VARCHAR2
104  			  , p_log_category     IN VARCHAR2
105  			  , p_guid	       IN VARCHAR2
106  			  , p_sosl_identifier  IN VARCHAR2
107  			  , p_executor_id      IN NUMBER
108  			  , p_ext_script_id    IN VARCHAR2
109  			  , p_caller	       IN VARCHAR2
110  			  , p_run_id	       IN NUMBER
111  			  , p_full_message     IN CLOB
112  			  )
113    IS
114  	 PRAGMA AUTONOMOUS_TRANSACTION;
115    BEGIN
116  	 INSERT INTO sosl_server_log
117  	   ( message
118  	   , log_type
119  	   , log_category
120  	   , guid
121  	   , sosl_identifier
122  	   , executor_id
123  	   , ext_script_id
124  	   , caller
125  	   , run_id
126  	   , full_message
127  	   )
128  	   VALUES
129  	     ( p_message
130  	     , p_log_type
131  	     , p_log_category
132  	     , p_guid
133  	     , p_sosl_identifier
134  	     , p_executor_id
135  	     , p_ext_script_id
136  	     , p_caller
137  	     , p_run_id
138  	     , p_full_message
139  	     )
140  	 ;
141  	 COMMIT;
142    EXCEPTION
143  	 WHEN OTHERS THEN
144  	   -- use fallback
145  	   log_fallback('SOSL_LOG.LOG_EVENT', 'SOSL_LOG', SQLERRM);
146  	   -- try ROLLBACK
147  	   ROLLBACK;
148  	   -- and raise the error again now
149  	   RAISE;
150    END log_event;
151  
152    PROCEDURE full_log( p_message	      IN VARCHAR2
153  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_sys.INFO_TYPE
154  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
155  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
156  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
157  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
158  			 , p_executor_id      IN NUMBER      DEFAULT NULL
159  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
160  			 , p_run_id	      IN NUMBER      DEFAULT NULL
161  			 , p_full_message     IN CLOB	     DEFAULT NULL
162  			 )
163    IS
164  	 -- set variables to current type
165  	 l_log_category    sosl_server_log.log_category%TYPE;
166  	 l_caller	   sosl_server_log.caller%TYPE;
167  	 l_guid 	   sosl_server_log.guid%TYPE;
168  	 l_sosl_identifier sosl_server_log.sosl_identifier%TYPE;
169  	 l_executor_id	   sosl_server_log.executor_id%TYPE;
170  	 l_ext_script_id   sosl_server_log.ext_script_id%TYPE;
171  	 l_run_id	   sosl_server_log.run_id%TYPE;
172    BEGIN
173  	 -- we leave info type and message splitting to be handled by table trigger, only check other parameters for type and length.
174  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'LOG_CATEGORY', p_log_category)
175  	 THEN
176  	   -- write extra log entry and cut original content to limit
177  	   log_event( 'p_log_category length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
178  		    , sosl_sys.FATAL_TYPE
179  		    , 'LOG USAGE ERROR'
180  		    , NULL, NULL, NULL, NULL, NULL, NULL
181  		    , (p_message || ' - ' || p_full_message)
182  		    )
183  	   ;
184  	   l_log_category := SUBSTR(p_log_category, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'LOG_CATEGORY'));
185  	 ELSE
186  	   l_log_category := NVL(p_log_category, 'not set');
187  	 END IF;
188  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'CALLER', p_caller)
189  	 THEN
190  	   -- write extra log entry and cut original content to limit
191  	   log_event( 'p_caller length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
192  		    , sosl_sys.FATAL_TYPE
193  		    , 'LOG USAGE ERROR'
194  		    , NULL, NULL, NULL, NULL, NULL, NULL
195  		    , (p_message || ' - ' || p_full_message)
196  		    )
197  	   ;
198  	   l_caller := SUBSTR(p_caller, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'CALLER'));
199  	 ELSE
200  	   l_caller := p_caller;
201  	 END IF;
202  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'GUID', p_guid)
203  	 THEN
204  	   -- write extra log entry and cut original content to limit
205  	   log_event( 'p_guid length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
206  		    , sosl_sys.FATAL_TYPE
207  		    , 'LOG USAGE ERROR'
208  		    , NULL, NULL, NULL, NULL, NULL, NULL
209  		    , (p_message || ' - ' || p_full_message)
210  		    )
211  	   ;
212  	   l_guid := SUBSTR(p_guid, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'GUID'));
213  	 ELSE
214  	   l_guid := p_guid;
215  	 END IF;
216  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'SOSL_IDENTIFIER', p_sosl_identifier)
217  	 THEN
218  	   -- write extra log entry and cut original content to limit
219  	   log_event( 'p_sosl_identifier length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
220  		    , sosl_sys.FATAL_TYPE
221  		    , 'LOG USAGE ERROR'
222  		    , NULL, NULL, NULL, NULL, NULL, NULL
223  		    , (p_message || ' - ' || p_full_message)
224  		    )
225  	   ;
226  	   l_sosl_identifier := SUBSTR(p_sosl_identifier, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'SOSL_IDENTIFIER'));
227  	 ELSE
228  	   l_sosl_identifier := p_sosl_identifier;
229  	 END IF;
230  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'EXECUTOR_ID', p_executor_id)
231  	 THEN
232  	   -- write extra log entry and cut original content to limit
233  	   log_event( 'p_executor_id length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error. EXECUTOR_ID: ' || p_executor_id
234  		    , sosl_sys.FATAL_TYPE
235  		    , 'LOG USAGE ERROR'
236  		    , NULL, NULL, NULL, NULL, NULL, NULL
237  		    , (p_message || ' - ' || p_full_message)
238  		    )
239  	   ;
240  	   -- we can't shorten the number, leave it to oracle
241  	   l_executor_id := p_executor_id;
242  	 ELSE
243  	   l_executor_id := p_executor_id;
244  	 END IF;
245  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'EXT_SCRIPT_ID', p_ext_script_id)
246  	 THEN
247  	   -- write extra log entry and cut original content to limit
248  	   log_event( 'ext_script_id length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
249  		    , sosl_sys.FATAL_TYPE
250  		    , 'LOG USAGE ERROR'
251  		    , NULL, NULL, NULL, NULL, NULL, NULL
252  		    , (p_message || ' - ' || p_full_message)
253  		    )
254  	   ;
255  	   l_ext_script_id := SUBSTR(p_ext_script_id, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'EXT_SCRIPT_ID'));
256  	 ELSE
257  	   l_ext_script_id := p_ext_script_id;
258  	 END IF;
259  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'RUN_ID', p_run_id)
260  	 THEN
261  	   -- write extra log entry and cut original content to limit
262  	   log_event( 'p_run_id length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error. RUN_ID: ' || p_run_id
263  		    , sosl_sys.FATAL_TYPE
264  		    , 'LOG USAGE ERROR'
265  		    , NULL, NULL, NULL, NULL, NULL, NULL
266  		    , (p_message || ' - ' || p_full_message)
267  		    )
268  	   ;
269  	   -- we can't shorten the number, leave it to oracle
270  	   l_run_id := p_run_id;
271  	 ELSE
272  	   l_run_id := p_run_id;
273  	 END IF;
274  	 -- try to write the given data to SOSL_SERVER_LOG
275  	 log_event(p_message, p_log_type, l_log_category, l_guid, l_sosl_identifier, l_executor_id, l_ext_script_id, l_caller, l_run_id, p_full_message);
276    EXCEPTION
277  	 WHEN OTHERS THEN
278  	   log_event( 'full log error: ' || TRIM(SUBSTR(SQLERRM, 1, 3900))
279  		    , sosl_sys.FATAL_TYPE
280  		    , 'FULL_LOG ERROR'
281  		    , NULL, NULL, NULL, NULL, NULL, NULL
282  		    , SQLERRM || ': ' || p_message
283  		    )
284  	   ;
285    END full_log;
286  
287    PROCEDURE cmd_log( p_message	     IN VARCHAR2
288  			, p_log_type	     IN VARCHAR2     DEFAULT sosl_sys.INFO_TYPE
289  			, p_caller	     IN VARCHAR2     DEFAULT NULL
290  			, p_guid	     IN VARCHAR2     DEFAULT NULL
291  			, p_sosl_identifier  IN VARCHAR2     DEFAULT NULL
292  			, p_executor_id      IN NUMBER	     DEFAULT NULL
293  			, p_ext_script_id    IN VARCHAR2     DEFAULT NULL
294  			, p_full_message     IN CLOB	     DEFAULT NULL
295  			)
296    IS
297    BEGIN
298  	 full_log( p_message => p_message
299  		 , p_log_type => p_log_type
300  		 , p_caller => p_caller
301  		 , p_guid => p_guid
302  		 , p_sosl_identifier => p_sosl_identifier
303  		 , p_executor_id => p_executor_id
304  		 , p_ext_script_id => p_ext_script_id
305  		 , p_full_message => p_full_message
306  		 )
307  	 ;
308    EXCEPTION
309  	 WHEN OTHERS THEN
310  	   log_event( 'CMD log error: ' || TRIM(SUBSTR(SQLERRM, 1, 3900))
311  		    , sosl_sys.FATAL_TYPE
312  		    , 'CMD_LOG ERROR'
313  		    , NULL, NULL, NULL, NULL, NULL, NULL
314  		    , SQLERRM || ': ' || p_message
315  		    )
316  	   ;
317    END cmd_log;
318  
319  END;
320  /

Package body created.

SQL> 
SQL> -- SOSL objects with possible references to sosl_log and sosl_sys
SQL> @@../sosl_ddl/tables/sosl_config.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_config
  2    ( config_name	     VARCHAR2(128)					       NOT NULL
  3    , config_value	     VARCHAR2(4000)					       NOT NULL
  4    , config_max_length   NUMBER	     DEFAULT -1 			       NOT NULL
  5    , config_type	     VARCHAR2(6)     DEFAULT 'CHAR'			       NOT NULL
  6    , created	     DATE	     DEFAULT SYSDATE			       NOT NULL
  7    , updated	     DATE	     DEFAULT SYSDATE			       NOT NULL
  8    , created_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
  9    , created_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
 11    , updated_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , config_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_config IS 'Holds the configuration used by SOSL. Will use the alias scfg.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_name IS 'The unique case sensitive name of the SOSL configuration object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_value IS 'The configuration value always as VARCHAR2. Type handling and conversion must be done by the caller.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_type IS 'Defines how the config value has to be interpreted. Currently supports CHAR and NUMBER.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_max_length IS 'Defines a maximum length for CHAR type config values if set to a number > 0. Default is -1, do not not check length.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_description IS 'Optional description of the SOSL config object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- primary key
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_pk
  3    PRIMARY KEY (config_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_type
  3    CHECK (config_type IN ('CHAR', 'NUMBER'))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_max_length
  3    CHECK (config_max_length = -1 OR config_max_length > 0)
  4  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_config_ins_upd_trg
  2    BEFORE INSERT OR UPDATE ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok    BOOLEAN;
  6    l_date  DATE;
  7  BEGIN
  8    -- remove any leading and trailing blanks from config_value
  9    :NEW.config_value   := TRIM(:NEW.config_value);
 10    IF UPDATING
 11    THEN
 12  	 :NEW.created	     := :OLD.created;
 13  	 :NEW.created_by     := :OLD.created_by;
 14  	 :NEW.created_by_os  := :OLD.created_by_os;
 15    ELSE
 16  	 :NEW.created	     := SYSDATE;
 17  	 :NEW.created_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 18  	 :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 19    END IF;
 20    :NEW.updated	   := SYSDATE;
 21    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 22    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 23    -- check max length if defined
 24    IF :NEW.config_type = 'CHAR'
 25    THEN
 26  	 IF :NEW.config_max_length > 0
 27  	 THEN
 28  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 29  	   THEN
 30  	     sosl_log.full_log( p_message => 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value)
 31  			      , p_log_type => sosl_sys.FATAL_TYPE
 32  			      , p_log_category => 'SOSL_CONFIG/sosl_config_ins_upd_trg'
 33  			      , p_caller => 'sosl_config_ins_upd_trg'
 34  			      )
 35  	     ;
 36  	     RAISE_APPLICATION_ERROR(-20000, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 37  	   END IF;
 38  	 END IF;
 39    END IF;
 40    -- check number type
 41    IF :NEW.config_type = 'NUMBER'
 42    THEN
 43  	 l_ok := TRUE;
 44  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 45  	 BEGIN
 46  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 47  	 EXCEPTION
 48  	   WHEN OTHERS THEN
 49  	     l_ok := FALSE;
 50  	 END;
 51  	 IF NOT l_ok
 52  	 THEN
 53  	     sosl_log.full_log( p_message => 'The given config_value "' || :NEW.config_value || '" could not be converted successfully to a number.'
 54  			      , p_log_type => sosl_sys.FATAL_TYPE
 55  			      , p_log_category => 'SOSL_CONFIG/sosl_config_ins_upd_trg'
 56  			      , p_caller => 'sosl_config_ins_upd_trg'
 57  			      )
 58  	     ;
 59  	   RAISE_APPLICATION_ERROR(-20001, 'The given config_value "' || :NEW.config_value || '" could not be converted successfully to a number.');
 60  	 END IF;
 61    END IF;
 62  END;
 63  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_config_del_trg
  2    BEFORE DELETE ON sosl_config
  3    FOR EACH ROW
  4  BEGIN
  5    -- protect system parameters from delete
  6    IF :OLD.config_name IN ( 'SOSL_PATH_CFG'
  7  			      , 'SOSL_PATH_TMP'
  8  			      , 'SOSL_PATH_LOG'
  9  			      , 'SOSL_START_LOG'
 10  			      , 'SOSL_BASE_LOG'
 11  			      , 'SOSL_EXT_LOG'
 12  			      , 'SOSL_EXT_TMP'
 13  			      , 'SOSL_EXT_LOCK'
 14  			      , 'SOSL_EXT_ERROR'
 15  			      , 'SOSL_MAX_PARALLEL'
 16  			      , 'SOSL_RUNMODE'
 17  			      , 'SOSL_DEFAULT_WAIT'
 18  			      , 'SOSL_NOJOB_WAIT'
 19  			      , 'SOSL_PAUSE_WAIT'
 20  			      )
 21    THEN
 22  	 RAISE_APPLICATION_ERROR(-20002, 'The given system config_name "' || :OLD.config_name || '" cannot be deleted.');
 23    END IF;
 24  END;
 25  /

Trigger created.

SQL> -- load default values that can be configured in the database
SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_PATH_CFG', '..\..\sosl_cfg\', 'Relative path with delimiter at path end to configuration files the SOSL server uses. Set by SOSL server. As configuration files contain credentials and secrets the path should be in a safe space with controlled user rights.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_TMP', '..\..\sosl_tmp\', 239, 'Relative path with delimiter at path end to temporary files the SOSL server uses. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_LOG', '..\..\sosl_log\', 239, 'Relative path with delimiter at path end to log files the SOSL server creates. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_START_LOG', 'sosl_server', 'Log filename for start and end of SOSL server CMD. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_BASE_LOG', 'sosl_job_', 'Base log filename for single job runs. Will be extended by GUID. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOG', 'log', 'Log file extension to use. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_TMP', 'tmp', 'Log file extension for temporary logs to use. On error those file extension will be renamed to SOSL_EXT_ERROR extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOCK', 'lock', 'Default process lock file extension. Lock files will always get deleted either on service start or after a run. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_ERROR', 'err', 'Default process error file extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAX_PARALLEL', '8', 'NUMBER', 'The maximum of parallel started scripts. Read by the SOSL server. After this amount if scripts is started, next scripts are only loaded, if the run count is below this value.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_RUNMODE', 'RUN', 'CHAR', 'Determines if the server should RUN, WAIT or STOP. Read by the SOSL server. RUN will cause the SOSL server, if started to run as long as it does not get a STOP signal from the database. Set it to STOP to stop the SOSL server. Set to WAIT if the server should not call any script apart the check for the run mode. Can be locally overwritten.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_DEFAULT_WAIT', '1', 'NUMBER', 'Determines the normal sleep time in seconds the sosl server has between calls if scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_NOJOB_WAIT', '120', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if no scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_PAUSE_WAIT', '3600', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if run mode is set to wait.')
  5  ;

1 row created.

SQL> COMMIT;

Commit complete.

SQL> @@../sosl_ddl/tables/sosl_executor.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE TABLE sosl_executor
  2    ( executor_id	       NUMBER(38, 0)   GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , executor_name	       VARCHAR2(256)						 NOT NULL
  4    , db_user	       VARCHAR2(128)						 NOT NULL
  5    , function_owner        VARCHAR2(128)						 NOT NULL
  6    , fn_has_ids	       VARCHAR2(520)						 NOT NULL
  7    , fn_get_next_id        VARCHAR2(520)						 NOT NULL
  8    , fn_get_executor       VARCHAR2(520)						 NOT NULL
  9    , fn_get_script	       VARCHAR2(520)						 NOT NULL
 10    , fn_set_status	       VARCHAR2(520)						 NOT NULL
 11    , cfg_file	       VARCHAR2(4000)						 NOT NULL
 12    , use_mail	       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 13    , mail_sender	       VARCHAR2(1024)  DEFAULT 'n/a'				 NOT NULL
 14    , mail_recipients       VARCHAR2(1024)  DEFAULT 'n/a'				 NOT NULL
 15    , fn_send_db_mail       VARCHAR2(520)   DEFAULT 'sosl_sys.dummy_mail'		 NOT NULL
 16    , executor_active       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 17    , executor_reviewed     NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 18    , created	       DATE	       DEFAULT SYSDATE				 NOT NULL
 19    , updated	       DATE	       DEFAULT SYSDATE				 NOT NULL
 20    , created_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 21    , created_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 22    , updated_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 23    , updated_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 24    , script_schema	       VARCHAR2(128)   DEFAULT NULL
 25    , executor_description  VARCHAR2(4000)
 26    )
 27  ;

Table created.

SQL> COMMENT ON TABLE sosl_executor IS 'Defines the executors registered with SOSL. To improve security you may activate AUDIT on this table. Will use the alias sexe.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_id IS 'The generated unique id that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_name IS 'The unique name that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.db_user IS 'The login name of the database user must match cfg_file login and be USER after login. No mixed case support, converted to upper case. Must exist and have the necessary rights to execute the queued scripts. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.function_owner IS 'The owner user name of the API functions, refers to the schema where the functions are defined. No mixed case support, converted to upper case. Can differ from the database user that executes SOSL. All API functions must have the same owner for one executor. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_has_ids IS 'The name of the function to use by HAS_IDS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the amount of waiting scripts as NUMBER or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_get_next_id IS 'The name of the function to use by GET_NEXT_ID wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the script id as VARCHAR2. It should manage the given script id to ensure that scripts are not run twice.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_get_executor IS 'The name of the function to use by GET_EXECUTOR wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameter P_ID IN VARCHAR2 and return the executor id as NUMBER. P_ID is an script id retrieved from GET_NEXT_ID.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_get_script IS 'The name of the function to use by GET_SCRIPT wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameter P_ID IN VARCHAR2 and return the script name with full or relative path as VARCHAR2. The script must exist in the given path on the local server SOSL is running.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_set_status IS 'The name of the function to use by SET_STATUS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameters P_ID IN VARCHAR2, P_STATUS IN VARCHAR2 and return 0 or -1 on errors. P_ID is an script id retrieved from GET_NEXT_ID. P_STATUS will always start with the following key words: PREPARING, ENQUEUED, RUNNING, SUCCESS, ERROR. It may contain additional informations in case of errors separated by at least one space char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_send_db_mail IS 'The name of the function to use by SEND_DB_MAIL wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameters P_SENDER IN VARCHAR2, P_RECIPIENTS IN VARCHAR2, P_SUBJECT IN VARCHAR2, P_MESSAGE IN VARCHAR2 and return 0 or -1 on errors. P_SENDER is the email address of the sender. P_RECIPIENTS contains the email addresses of the recipients, delimited by semicolon ";". P_SUBJECT is the email subject to use. P_MESSAGE contains the email message.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.cfg_file IS 'The filename with absolute or relative path to the login config file for this executor. File and path must exist on the CMD server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_active IS 'Defines if the executor is active. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_reviewed IS 'Defines if the executor is reviewed, accepted and ready to be used. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.script_schema IS 'The (optional) schema the script should run in. If set will cause an ALTER SESSION SET CURRENT_SCHEMA before executing the script otherwise db user schema is used. DB user must have rights for this schema if set. If acting on own schema or scripts do ALTER SESSION by themselves, you should leave it NULL.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_description IS 'Optional executor description.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_pk
  3    PRIMARY KEY (executor_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- unique constraint
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_uk
  3    UNIQUE (executor_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- check constraints
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_use_mail
  3    CHECK (use_mail IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_active
  3    CHECK (executor_active IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_reviewed
  3    CHECK (executor_reviewed IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_executor_ins_trg
  2    BEFORE INSERT ON sosl_executor
  3    FOR EACH ROW
  4  DECLARE
  5    l_caller    VARCHAR2(256) := 'sosl_executor_ins_trg';
  6    l_category  VARCHAR2(256) := 'SOSL_EXECUTOR';
  7  BEGIN
  8    :NEW.created	       := SYSDATE;
  9    :NEW.created_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.created_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 11    :NEW.updated	       := SYSDATE;
 12    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 13    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 14    :NEW.executor_active    := 0;
 15    :NEW.executor_reviewed  := 0;
 16    -- transform users and functions to UPPERCASE, no support currently for special mix-case.
 17    :NEW.function_owner     := UPPER(:NEW.function_owner);
 18    :NEW.db_user	       := UPPER(:NEW.db_user);
 19    :NEW.fn_has_ids	       := UPPER(:NEW.fn_has_ids);
 20    :NEW.fn_get_next_id     := UPPER(:NEW.fn_get_next_id);
 21    :NEW.fn_get_executor    := UPPER(:NEW.fn_get_executor);
 22    :NEW.fn_get_script      := UPPER(:NEW.fn_get_script);
 23    :NEW.fn_set_status      := UPPER(:NEW.fn_set_status);
 24    :NEW.fn_send_db_mail    := UPPER(:NEW.fn_send_db_mail);
 25    -- check user
 26    IF NOT sosl_sys.has_db_user(:NEW.db_user)
 27    THEN
 28  	 sosl_log.full_log( p_message => 'The given database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 29  			  , p_log_type => sosl_sys.FATAL_TYPE
 30  			  , p_log_category => l_category
 31  			  , p_caller => l_caller
 32  			  )
 33  	 ;
 34  	 RAISE_APPLICATION_ERROR(-20003, 'The given database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 35    END IF;
 36    IF NOT sosl_sys.has_db_user(:NEW.function_owner)
 37    THEN
 38  	 sosl_log.full_log( p_message => 'The given function owner database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 39  			  , p_log_type => sosl_sys.FATAL_TYPE
 40  			  , p_log_category => l_category
 41  			  , p_caller => l_caller
 42  			  )
 43  	 ;
 44  	 RAISE_APPLICATION_ERROR(-20003, 'The given function owner database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 45    END IF;
 46    -- check configured functions
 47    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_has_ids, 'NUMBER')
 48    THEN
 49  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_has_ids || ' for has_ids is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 50  			  , p_log_type => sosl_sys.FATAL_TYPE
 51  			  , p_log_category => l_category
 52  			  , p_caller => l_caller
 53  			  )
 54  	 ;
 55  	 RAISE_APPLICATION_ERROR(-20004, 'The given function ' || :NEW.fn_has_ids || ' for has_ids is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 56    END IF;
 57    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_next_id, 'VARCHAR2')
 58    THEN
 59  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_next_id || ' for get_next_id is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.'
 60  			  , p_log_type => sosl_sys.FATAL_TYPE
 61  			  , p_log_category => l_category
 62  			  , p_caller => l_caller
 63  			  )
 64  	 ;
 65  	 RAISE_APPLICATION_ERROR(-20005, 'The given function ' || :NEW.fn_get_next_id || ' for get_next_id is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.');
 66    END IF;
 67    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_executor, 'NUMBER')
 68    THEN
 69  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_executor || ' for get_executor is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 70  			  , p_log_type => sosl_sys.FATAL_TYPE
 71  			  , p_log_category => l_category
 72  			  , p_caller => l_caller
 73  			  )
 74  	 ;
 75  	 RAISE_APPLICATION_ERROR(-20006, 'The given function ' || :NEW.fn_get_executor || ' for get_executor is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 76    END IF;
 77    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_script, 'VARCHAR2')
 78    THEN
 79  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_script || ' for get_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.'
 80  			  , p_log_type => sosl_sys.FATAL_TYPE
 81  			  , p_log_category => l_category
 82  			  , p_caller => l_caller
 83  			  )
 84  	 ;
 85  	 RAISE_APPLICATION_ERROR(-20007, 'The given function ' || :NEW.fn_get_script || ' for get_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.');
 86    END IF;
 87    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_set_status, 'NUMBER')
 88    THEN
 89  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_set_status || ' for set_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 90  			  , p_log_type => sosl_sys.FATAL_TYPE
 91  			  , p_log_category => l_category
 92  			  , p_caller => l_caller
 93  			  )
 94  	 ;
 95  	 RAISE_APPLICATION_ERROR(-20008, 'The given function ' || :NEW.fn_set_status || ' for set_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 96    END IF;
 97    IF     :NEW.use_mail = 1
 98  	  AND NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
 99    THEN
100  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_send_db_mail || ' for send db mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
101  			  , p_log_type => sosl_sys.FATAL_TYPE
102  			  , p_log_category => l_category
103  			  , p_caller => l_caller
104  			  )
105  	 ;
106  	 RAISE_APPLICATION_ERROR(-20009, 'The given function ' || :NEW.fn_send_db_mail || ' for send db mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
107    END IF;
108    -- log the insert
109    sosl_log.full_log( p_message => 'A new executor has been defined for DB user: ' || :NEW.db_user || ' with function owner: ' || :NEW.function_owner || ' created by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
110  			, p_log_type => sosl_sys.INFO_TYPE
111  			, p_log_category => l_category
112  			, p_caller => l_caller
113  			)
114    ;
115  EXCEPTION
116    WHEN OTHERS THEN
117  	 -- catch and log all undefined exceptions
118  	 IF SQLCODE NOT IN (-20003, -20004, -20005, -20006, -20007, -20008, -20009)
119  	 THEN
120  	   sosl_log.full_log( p_message => 'Unhandled exception in trigger sosl_executor_ins_trg: ' || SQLERRM
121  			    , p_log_type => sosl_sys.FATAL_TYPE
122  			    , p_log_category => l_category
123  			    , p_caller => l_caller
124  			    )
125  	   ;
126  	 END IF;
127  	 -- raise all errors
128  	 RAISE;
129  END;
130  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_executor_upd_trg
  2    BEFORE UPDATE ON sosl_executor
  3    FOR EACH ROW
  4  DECLARE
  5    l_change_record VARCHAR2(32767);
  6    l_caller        VARCHAR2(256) := 'sosl_executor_upd_trg';
  7    l_category      VARCHAR2(256) := 'SOSL_EXECUTOR';
  8  BEGIN
  9    l_change_record := 'Changes by OS user ' || SYS_CONTEXT('USERENV', 'OS_USER') || ': ';
 10    :NEW.updated	       := SYSDATE;
 11    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 12    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 13    -- no overwrite for this values
 14    IF :NEW.created != :OLD.created
 15    THEN
 16  	 l_change_record := l_change_record || 'Prohibited change of create date to: "' || TO_CHAR(:NEW.created, 'YYYY-MM-DD HH24:MI:SS') || '" ';
 17  	 :NEW.created		 := :OLD.created;
 18    END IF;
 19    :NEW.created_by	       := :OLD.created_by;
 20    :NEW.created_by_os      := :OLD.created_by_os;
 21    IF UPPER(:NEW.function_owner) != :OLD.function_owner
 22    THEN
 23  	 l_change_record := l_change_record || 'Prohibited change of function owner to: "' || :NEW.function_owner || '" ';
 24  	 :NEW.function_owner := :OLD.function_owner;
 25    END IF;
 26    IF UPPER(:NEW.db_user) != :OLD.db_user
 27    THEN
 28  	 l_change_record := l_change_record || 'Prohibited change of db user to: "' || :NEW.db_user || '" ';
 29  	 :NEW.db_user := :OLD.db_user;
 30    END IF;
 31    -- prepare possibly modified values
 32    IF :NEW.executor_active != :OLD.executor_active
 33    THEN
 34  	 l_change_record := l_change_record || 'Modified EXECUTOR_ACTIVE: "' || sosl_sys.yes_no(:NEW.executor_active) || '" ';
 35    END IF;
 36    IF :NEW.executor_reviewed != :OLD.executor_reviewed
 37    THEN
 38  	 l_change_record := l_change_record || 'Modified EXECUTOR_REVIEWED: "' || sosl_sys.yes_no(:NEW.executor_reviewed) || '" ';
 39    END IF;
 40    IF UPPER(:NEW.fn_has_ids) != :OLD.fn_has_ids
 41    THEN
 42  	 :NEW.fn_has_ids := UPPER(:NEW.fn_has_ids);
 43  	 l_change_record := l_change_record || 'Modified FN_HAS_IDS: "' || :NEW.fn_has_ids || '" ';
 44    END IF;
 45    IF UPPER(:NEW.fn_get_next_id) != :OLD.fn_get_next_id
 46    THEN
 47  	 :NEW.fn_get_next_id := UPPER(:NEW.fn_get_next_id);
 48  	 l_change_record     := l_change_record || 'Modified FN_GET_NEXT_ID: "' || :NEW.fn_get_next_id || '" ';
 49    END IF;
 50    IF UPPER(:NEW.fn_get_executor) != :NEW.fn_get_executor
 51    THEN
 52  	 :NEW.fn_get_executor  := UPPER(:NEW.fn_get_executor);
 53  	 l_change_record       := l_change_record || 'Modified FN_GET_EXECUTOR: "' || :NEW.fn_get_executor || '" ';
 54    END IF;
 55    IF UPPER(:NEW.fn_get_script) != :OLD.fn_get_script
 56    THEN
 57  	 :NEW.fn_get_script  := UPPER(:NEW.fn_get_script);
 58  	 l_change_record       := l_change_record || 'Modified FN_GET_SCRIPT: "' || :NEW.fn_get_script || '" ';
 59    END IF;
 60    IF UPPER(:NEW.fn_set_status) != :OLD.fn_set_status
 61    THEN
 62  	 :NEW.fn_set_status := UPPER(:NEW.fn_set_status);
 63  	 l_change_record       := l_change_record || 'Modified FN_SET_STATUS: "' || :NEW.fn_set_status || '" ';
 64    END IF;
 65    IF UPPER(:NEW.fn_send_db_mail) != :OLD.fn_send_db_mail
 66    THEN
 67  	 :NEW.fn_send_db_mail := UPPER(:NEW.fn_send_db_mail);
 68  	 l_change_record       := l_change_record || 'Modified FN_SEND_DB_MAIL: "' || :NEW.fn_send_db_mail || '" ';
 69    END IF;
 70    -- do all checks again including user
 71    -- check user
 72    IF NOT sosl_sys.has_db_user(:NEW.db_user)
 73    THEN
 74  	 sosl_log.full_log( p_message => 'The given database user is not longer visible for SOSL in ALL_USERS. Executor deactivated. Either the user does not exist or SOSL has no right to see this user.'
 75  			  , p_log_type => sosl_sys.FATAL_TYPE
 76  			  , p_log_category => l_category
 77  			  , p_caller => l_caller
 78  			  )
 79  	 ;
 80  	 :NEW.executor_active := 0;
 81    END IF;
 82    IF NOT sosl_sys.has_db_user(:NEW.function_owner)
 83    THEN
 84  	 sosl_log.full_log( p_message => 'The given function owner database user is not longer visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 85  			  , p_log_type => sosl_sys.FATAL_TYPE
 86  			  , p_log_category => l_category
 87  			  , p_caller => l_caller
 88  			  )
 89  	 ;
 90  	 :NEW.executor_active := 0;
 91    END IF;
 92    -- check configured functions
 93    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_has_ids, 'NUMBER')
 94    THEN
 95  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_has_ids || ' for has_ids is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 96  			  , p_log_type => sosl_sys.FATAL_TYPE
 97  			  , p_log_category => l_category
 98  			  , p_caller => l_caller
 99  			  )
100  	 ;
101  	 RAISE_APPLICATION_ERROR(-20004, 'The given function ' || :NEW.fn_has_ids || ' for has_ids is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
102    END IF;
103    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_next_id, 'VARCHAR2')
104    THEN
105  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_next_id || ' for get_next_id is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.'
106  			  , p_log_type => sosl_sys.FATAL_TYPE
107  			  , p_log_category => l_category
108  			  , p_caller => l_caller
109  			  )
110  	 ;
111  	 RAISE_APPLICATION_ERROR(-20005, 'The given function ' || :NEW.fn_get_next_id || ' for get_next_id is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.');
112    END IF;
113    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_executor, 'NUMBER')
114    THEN
115  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_executor || ' for get_executor is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
116  			  , p_log_type => sosl_sys.FATAL_TYPE
117  			  , p_log_category => l_category
118  			  , p_caller => l_caller
119  			  )
120  	 ;
121  	 RAISE_APPLICATION_ERROR(-20006, 'The given function ' || :NEW.fn_get_executor || ' for get_executor is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
122    END IF;
123    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_script, 'VARCHAR2')
124    THEN
125  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_script || ' for get_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.'
126  			  , p_log_type => sosl_sys.FATAL_TYPE
127  			  , p_log_category => l_category
128  			  , p_caller => l_caller
129  			  )
130  	 ;
131  	 RAISE_APPLICATION_ERROR(-20007, 'The given function ' || :NEW.fn_get_script || ' for get_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.');
132    END IF;
133    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_set_status, 'NUMBER')
134    THEN
135  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_set_status || ' for set_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
136  			  , p_log_type => sosl_sys.FATAL_TYPE
137  			  , p_log_category => l_category
138  			  , p_caller => l_caller
139  			  )
140  	 ;
141  	 RAISE_APPLICATION_ERROR(-20008, 'The given function ' || :NEW.fn_set_status || ' for set_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
142    END IF;
143    IF     :NEW.use_mail = 1
144  	  AND NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
145    THEN
146  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_send_db_mail || ' for send db mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
147  			  , p_log_type => sosl_sys.FATAL_TYPE
148  			  , p_log_category => l_category
149  			  , p_caller => l_caller
150  			  )
151  	 ;
152  	 RAISE_APPLICATION_ERROR(-20009, 'The given function ' || :NEW.fn_send_db_mail || ' for send db mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
153    END IF;
154    -- log the insert
155    sosl_log.full_log( p_message => 'The executor ID: ' || :OLD.executor_id || ' has been updated by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER') || ' see full_message for details.'
156  			, p_log_type => sosl_sys.INFO_TYPE
157  			, p_log_category => l_category
158  			, p_caller => l_caller
159  			, p_full_message => TO_CLOB(l_change_record)
160  			)
161    ;
162  EXCEPTION
163    WHEN OTHERS THEN
164  	 -- catch and log all undefined exceptions
165  	 IF SQLCODE NOT IN (-20004, -20005, -20006, -20007, -20008, -20009)
166  	 THEN
167  	   sosl_log.full_log( p_message => 'Unhandled exception in trigger sosl_executor_upd_trg: ' || SQLERRM
168  			    , p_log_type => sosl_sys.FATAL_TYPE
169  			    , p_log_category => l_category
170  			    , p_caller => l_caller
171  			    )
172  	   ;
173  	 END IF;
174  	 -- raise all errors
175  	 RAISE;
176  END;
177  /

Trigger created.

SQL> -- internal objects using the API
SQL> @@../sosl_ddl/tables/sosl_script.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_script
  2    ( script_id	     NUMBER(38, 0)  GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , script_name	     VARCHAR2(2000)					      NOT NULL
  4    , script_order	     NUMBER(38, 0)  DEFAULT 1				      NOT NULL
  5    , created	     DATE	    DEFAULT SYSDATE			      NOT NULL
  6    , updated	     DATE	    DEFAULT SYSDATE			      NOT NULL
  7    , created_by	     VARCHAR2(256)  DEFAULT USER			      NOT NULL
  8    , created_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
  9    , updated_by	     VARCHAR2(256)  DEFAULT USER			      NOT NULL
 10    , updated_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 11    , executor_id	     NUMBER(38, 0)
 12    , script_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_script IS 'Holds the script file names that should be executed by SOSL. Will use the alias scrt.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_id IS 'The generated unique id of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.executor_id IS 'The related executor id of the script file. If defined, must match an existing executor. If not defined, script is ignored.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_name IS 'The name of the script file including full or relative path. Use relative path (relative to batch_base_path or repository location) to ensure running scripts from different machines.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_order IS 'The order in which the script file should be executed. Same number means in parallel. Higher order numbers wait for scripts with lower order numbers to complete.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_description IS 'Optional description of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_script
  2    ADD CONSTRAINT sosl_script_pk
  3    PRIMARY KEY (script_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- foreign key
SQL> ALTER TABLE sosl_script
  2    ADD CONSTRAINT sosl_script_fk
  3    FOREIGN KEY (executor_id)
  4    REFERENCES sosl_executor (executor_id)
  5    ON DELETE SET NULL
  6    ENABLE
  7  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_script_ins_trg
  2    BEFORE INSERT ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := SYSDATE;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_script_upd_trg
  2    BEFORE UPDATE ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    :NEW.updated	   := SYSDATE;
 10    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12  END;
 13  /

Trigger created.

SQL> -- wrapper functions
SQL> @@../sosl_ddl/functions/has_ids.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE FUNCTION has_ids
  2    RETURN NUMBER
  3  IS
  4    /* Wrapper function for defined executor has_ids functions.
  5    * Collects and sums the output of all defined executor has_ids functions of active and reviewed executors that
  6    * return a number greater 0. Will log all functions in error.
  7    *
  8    * @return The amount of scripts waiting for all valid executor has_ids functions or -1 if all functions have errors.
  9    */
 10    -- variables
 11    l_cnt_valid   NUMBER;
 12    l_id_cnt      NUMBER;
 13    l_tmp_cnt     NUMBER;
 14    l_success_cnt NUMBER;
 15    l_category    VARCHAR2(256) := 'HAS_IDS';
 16    l_caller      VARCHAR2(256) := 'has_ids';
 17    -- cursors
 18    CURSOR cur_fn_call
 19    IS
 20  	 SELECT DISTINCT fn_has_ids AS fn_call
 21  	   FROM sosl_executor
 22  	  WHERE executor_active   = 1
 23  	    AND executor_reviewed = 1
 24    ;
 25  BEGIN
 26    l_id_cnt      := -1;
 27    l_success_cnt := 0;
 28    -- log the call
 29    sosl_log.full_log( p_message => 'HAS_IDS called by OS user ' || SYS_CONTEXT('USERENV', 'OS_USER')
 30  			, p_log_type => sosl_sys.INFO_TYPE
 31  			, p_log_category => l_category
 32  			, p_caller => l_caller
 33  			)
 34    ;
 35    SELECT COUNT(*) INTO l_cnt_valid FROM sosl_executor WHERE executor_active = 1 AND executor_reviewed = 1;
 36    IF l_cnt_valid > 0
 37    THEN
 38  	 -- get the results and sum them up
 39  	 FOR rec IN cur_fn_call
 40  	 LOOP
 41  	   l_tmp_cnt := -1;
 42  	   BEGIN
 43  	     EXECUTE IMMEDIATE rec.fn_call INTO l_tmp_cnt;
 44  	     l_success_cnt := l_success_cnt +1;
 45  	   EXCEPTION
 46  	     WHEN OTHERS THEN
 47  	       -- log the error
 48  	       sosl_log.full_log( p_message => 'Exception for defined function ' || rec.fn_call || ': ' || SQLERRM
 49  				, p_log_type => sosl_sys.ERROR_TYPE
 50  				, p_log_category => l_category
 51  				, p_caller => rec.fn_call
 52  				)
 53  	       ;
 54  	   END;
 55  	   IF l_tmp_cnt >= 0
 56  	   THEN
 57  	     l_id_cnt := l_id_cnt + l_tmp_cnt;
 58  	   ELSE
 59  	     -- log error functions including those returning -1 without throwing exceptions
 60  	     sosl_log.full_log( p_message => 'Error using defined function ' || rec.fn_call || ' either an exception occured (separately logged) or the function returned -1'
 61  			      , p_log_type => sosl_sys.ERROR_TYPE
 62  			      , p_log_category => l_category
 63  			      , p_caller => rec.fn_call
 64  			      )
 65  	     ;
 66  	   END IF;
 67  	 END LOOP;
 68  	 IF l_success_cnt = 0
 69  	 THEN
 70  	   sosl_log.full_log( p_message => 'HAS_IDS did not find any valid executor has_ids functions'
 71  			    , p_log_type => sosl_sys.ERROR_TYPE
 72  			    , p_log_category => l_category
 73  			    , p_caller => l_caller
 74  			    )
 75  	   ;
 76  	   l_id_cnt := -1;
 77  	 END IF;
 78    ELSE
 79  	 -- log no valid executors
 80  	 sosl_log.full_log( p_message => 'HAS_IDS called without valid executors defined'
 81  			  , p_log_type => sosl_sys.WARNING_TYPE
 82  			  , p_log_category => l_category
 83  			  , p_caller => l_caller
 84  			  )
 85  	 ;
 86  	 l_id_cnt := 0;
 87    END IF;
 88    RETURN l_id_cnt;
 89  EXCEPTION
 90    WHEN OTHERS THEN
 91  	 -- log the error
 92  	 sosl_log.full_log( p_message => 'Unhandled exception in HAS_IDS wrapper function: ' || SQLERRM
 93  			  , p_log_type => sosl_sys.FATAL_TYPE
 94  			  , p_log_category => l_category
 95  			  , p_caller => l_caller
 96  			  )
 97  	 ;
 98  	 RETURN -1;
 99  END;
100  /

Function created.

SQL> -- ==============INSTALL done==============
SQL> @@../sosl_sql/util/log_silent.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> SET ECHO OFF
SUCCESS - no errors found during setup          0
