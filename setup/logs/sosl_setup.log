SQL> -- roles
SQL> @@../sosl_ddl/roles/create_roles.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- create sosl roles
SQL> CREATE ROLE sosl_admin;

Role created.

SQL> CREATE ROLE sosl_executor;

Role created.

SQL> CREATE ROLE sosl_reviewer;

Role created.

SQL> CREATE ROLE sosl_user;

Role created.

SQL> CREATE ROLE sosl_guest;

Role created.

SQL> -- hierarchical grants
SQL> GRANT sosl_guest TO sosl_user;

Grant succeeded.

SQL> GRANT sosl_user TO sosl_reviewer;

Grant succeeded.

SQL> GRANT sosl_reviewer TO sosl_executor;

Grant succeeded.

SQL> GRANT sosl_executor TO sosl_admin;

Grant succeeded.

SQL> -- types
SQL> @@../sosl_ddl/types/sosl_payload.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- basic api exchange type, only header, no member function
SQL> CREATE OR REPLACE TYPE sosl_payload
  2    AS OBJECT
  3  	 /* This type is used to exchange information on executor, external script id and the script filename including
  4  	 * relative or full path which must exist on the server SOSL is running.
  5  	 * It does not provide any member functions only fields to fill. Object initialization basic example:
  6  	 * DECLARE
  7  	 *   -- to access the type from other schemas, do not forget to qualify it with the SOSL schema used
  8  	 *   l_sosl_payload SOSL.SOSL_PAYLOAD;
  9  	 * BEGIN
 10  	 *   l_sosl_payload := sosl_payload(1, 'My script ID', '../../mydir/scriptfile.sql');
 11  	 * END;
 12  	 */
 13  	 ( executor_id	  NUMBER(38, 0)  -- the executor_id from SOSL_EXECUTOR responsible for the script
 14  	 , ext_script_id  VARCHAR2(4000) -- the external script id managed by the executor
 15  	 , script_file	  VARCHAR2(4000) -- the script file name with full or relative path on the server where SOSL is running locally
 16  	 )
 17  ;
 18  /

Type created.

SQL> -- SQLPlus error logging table
SQL> @@../sosl_ddl/tables/soslerrorlog.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE TABLE soslerrorlog
  2    ( username    VARCHAR2(256)
  3    , timestamp   TIMESTAMP
  4  	 -- older versions than Oracle 23 use VARCHAR2(1024)
  5    , script      CLOB	   -- VARCHAR2(1024)
  6    , identifier  VARCHAR2(256)
  7    , message     CLOB
  8    , statement   CLOB
  9    )
 10  ;

Table created.

SQL> COMMENT ON TABLE soslerrorlog IS 'Userdefined table for SQLPlus error logging';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.username IS 'Oracle account name';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.timestamp IS 'Time when the error occurred';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.script IS 'Name of the originating script if applicable';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.identifier IS 'User defined identifier string';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.message IS 'ORA, PLA or SP2 error message. No feed back messages are included. For example, "PL/SQL Block Created" is not recorded.';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.statement IS 'The statement causing the error';

Comment created.

SQL> -- Grants, inherited by others, no guest access on table
SQL> GRANT SELECT ON soslerrorlog TO sosl_user;

Grant succeeded.

SQL> -- package with no dependency on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_sys.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic sys util package not using data objects of the Simple Oracle Script Loader, no dependencies.
SQL> CREATE OR REPLACE PACKAGE sosl_sys
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader that have no dependencies on any SOSL object.
  5    * As there are no dependencies, exceptions must be catched or handled by the caller. No logging for this functions and procedures.
  6    * For complex functions and procedures consider to put them in SOSL_UTIL where you have access and possibilities to log errors.
  7    */
  8  
  9    /*====================================== start package constants used by SOSL ======================================*/
 10    -- define log_type constants used in SOSL_SERVER_LOG
 11    ERROR_TYPE     CONSTANT CHAR(5) := 'ERROR';
 12    WARNING_TYPE   CONSTANT CHAR(7) := 'WARNING';
 13    FATAL_TYPE     CONSTANT CHAR(5) := 'FATAL';
 14    INFO_TYPE      CONSTANT CHAR(4) := 'INFO';
 15    SUCCESS_TYPE   CONSTANT CHAR(7) := 'SUCCESS';
 16    -- Generic n/a type. Should be different from table defaults like 'not set' as table triggers interpret their DDL default value as fallback
 17    -- to set default values using package variables, which is not supported in table DDL by Oracle using DEFAULT. Packages may use variables
 18    -- from other packages in DEFAULT declarations.
 19    NA_TYPE	      CONSTANT CHAR(3) := 'n/a';
 20    -- numerical equations to TRUE/YES and FALSE/NO
 21    YES	      CONSTANT INTEGER := 1;
 22    NO	      CONSTANT INTEGER := 0;
 23    -- default error numeric expression, that is returned by functions to indicate an error had occured
 24    ERR_NUM	      CONSTANT INTEGER := -1;
 25    -- default success numeric expression, that is returned by functions to indicate processing was successful
 26    SUCCESS_NUM    CONSTANT INTEGER := 0;
 27    /*====================================== end package constants used by SOSL ======================================*/
 28  
 29    /* FUNCTION SOSL_SYS.LOG_TYPE_VALID
 30    * Central function to check the log type. Currently supports INFO, WARNING, ERROR, FATAL, SUCCESS. If log types should get expanded
 31    * adjust this function first and probably the default value for SOSL_SERVER_LOG.
 32    *
 33    * @param p_log_type The log type to check. Case insensitive.
 34    *
 35    *@return TRUE if the given log type is supported. FALSE if not. Exceptions and errors will lead also to FALSE.
 36    */
 37    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 38  	 RETURN BOOLEAN
 39  	 DETERMINISTIC
 40  	 PARALLEL_ENABLE
 41    ;
 42  
 43    /* FUNCTION SOSL_SYS.GET_VALID_LOG_TYPE
 44    * Verifies an given log type, returns either the given log type as upper case or the defined error default.
 45    *
 46    * @param p_log_type The log type to verify and return. Case insensitive.
 47    * @param p_error_default The alternative log type to return, if the log type is invalid. Must be a valid log type and not INFO or SUCCESS. If invalid, FATAL is returned.
 48    *
 49    * @return The valid log type as upper case on success. The valid error default if log type not supported. FATAL if the error default is invalid.
 50    */
 51    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 52  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_sys.ERROR_TYPE
 53  				  )
 54  	 RETURN VARCHAR2
 55  	 DETERMINISTIC
 56  	 PARALLEL_ENABLE
 57    ;
 58  
 59    /* FUNCTION SOSL_SYS.DISTRIBUTE
 60    * This functions distributes char data between a VARCHAR2 and a CLOB variable by the following rules:
 61    * p_string empty or NULL: Fill p_string to p_max_string_length - p_split_end length.
 62    * p_string length > p_max_string_length: Cut p_string to p_max_string_length, including p_split_end appended.
 63    *	  p_clob NOT EMPTY: add split_start, rest of p_string before p_clob content.
 64    *	  p_clob EMPTY: add split_start and rest of p_string.
 65    * p_string length > 0 and < p_max_string_length: no change of p_string and p_clob.
 66    * p_string and p_clob empty or NULL: leave unchanged, return FALSE otherwise always TRUE.
 67    * In case of exceptions will try to write SQLERRM to p_string as CLOBs tend to be more error prone.
 68    * Mainly used by SOSL_SERVER_LOG.
 69    *
 70    * @param p_string The string to distribute or check. In PLSQL strings can get 32767 chars long, whereas table columns are limited currently to 4000.
 71    * @param p_clob The CLOB to distribute or check. Uses NOCOPY to guarantee that CLOB full length is used as given.
 72    * @param p_max_string_length The maximum length p_string should have. If this size is exeeded the string gets distribute between p_string and p_clob.
 73    * @param p_split_end The split end characters to indicate that the string is continued in p_clob.
 74    * @param p_split_start The split start characters for the continuing string in the CLOB.
 75    * @param p_delimiter The delimiter between rest of string in CLOB and original CLOB content, if both have content and string must be splitted.
 76    *
 77    * @return FALSE if p_string and p_clob are empty/NULL or an exception had occurred, otherwise TRUE.
 78    */
 79    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
 80  			  , p_clob		IN OUT NOCOPY  CLOB
 81  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
 82  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
 83  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
 84  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
 85  			  )
 86  	 RETURN BOOLEAN
 87    ;
 88  
 89    /* FUNCTION SOSL_SYS.TXT_BOOLEAN
 90    * Provides text values to display instead of BOOLEAN or NUMBER values interpreted as BOOLEAN. Numbers are interpreted
 91    * similar to Oracle SQL, where 0 is FALSE and 1 is TRUE. 1 is considered as TRUE, any other value as FALSE. NULL values
 92    * are interpreted as sosl_sys.NA_TYPE. Maximum 10 characters for TRUE/FALSE equation.
 93    *
 94    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
 95    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
 96    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
 97    *
 98    * @return The text equation for the given p_bool value.
 99    */
100    FUNCTION txt_boolean( p_bool   IN BOOLEAN
101  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
102  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
103  			   )
104  	 RETURN VARCHAR2
105  	 DETERMINISTIC
106  	 PARALLEL_ENABLE
107    ;
108    FUNCTION txt_boolean( p_bool   IN NUMBER
109  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
110  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
111  			   )
112  	 RETURN VARCHAR2
113  	 DETERMINISTIC
114  	 PARALLEL_ENABLE
115    ;
116  
117    /* FUNCTION SOSL_SYS.YES_NO
118    * A simple wrapper for txt_boolean with YES/NO instead of TRUE/FALSE.
119    *
120    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
121    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
122    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
123    *
124    * @return The text equation for the given p_bool value.
125    */
126    FUNCTION yes_no( p_bool	 IN BOOLEAN
127  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
128  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
129  		      )
130  	 RETURN VARCHAR2
131  	 DETERMINISTIC
132  	 PARALLEL_ENABLE
133    ;
134    FUNCTION yes_no( p_bool	 IN NUMBER
135  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
136  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
137  		      )
138  	 RETURN VARCHAR2
139  	 DETERMINISTIC
140  	 PARALLEL_ENABLE
141    ;
142  
143    /* FUNCTION SOSL_SYS.UTC_MAIL_DATE
144    * Returns the current date timestamp as a formatted string for date values in mail.
145    *
146    * @return A date string conform to RFC5322 for using mail.
147    *
148    * @see https://datatracker.ietf.org/doc/html/rfc5322
149    */
150    FUNCTION utc_mail_date
151  	 RETURN VARCHAR2
152    ;
153  
154    /* FUNCTION SOSL_SYS.FORMAT_MAIL
155    * This function formats a mail message conforming to RFC5322. The content of p_message is not checked against RFC. This is
156    * the repsonsibility of the user. This is for small messages that do not exceed 32k in total.
157    *
158    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
159    * @param p_recipients The semicolon separated list of mail recipient addresses.
160    * @param p_subject A preferablly short subject for the mail.
161    * @param p_message The correctly formatted mail message.
162    *
163    * @return A formatted string with complete mail message that can be used with RFC compliant mail servers.
164    */
165    FUNCTION format_mail( p_sender	   IN VARCHAR2
166  			   , p_recipients  IN VARCHAR2
167  			   , p_subject	   IN VARCHAR2
168  			   , p_message	   IN VARCHAR2
169  			   )
170  	 RETURN VARCHAR2
171    ;
172  
173  END;
174  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_sys.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_sys
  2  AS
  3    -- for description see header file
  4    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
  5  	 RETURN BOOLEAN
  6  	 DETERMINISTIC
  7  	 PARALLEL_ENABLE
  8    IS
  9  	 l_return  BOOLEAN;
 10    BEGIN
 11  	 l_return := FALSE;
 12  	 IF UPPER(p_log_type) IN ( sosl_sys.INFO_TYPE
 13  				 , sosl_sys.WARNING_TYPE
 14  				 , sosl_sys.ERROR_TYPE
 15  				 , sosl_sys.FATAL_TYPE
 16  				 , sosl_sys.SUCCESS_TYPE
 17  				 )
 18  	 THEN
 19  	   l_return := TRUE;
 20  	 END IF;
 21  	 RETURN l_return;
 22    EXCEPTION
 23  	 WHEN OTHERS THEN
 24  	   RETURN FALSE;
 25    END log_type_valid;
 26  
 27    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 28  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_sys.ERROR_TYPE
 29  				  )
 30  	 RETURN VARCHAR2
 31  	 DETERMINISTIC
 32  	 PARALLEL_ENABLE
 33    IS
 34  	 l_return  VARCHAR2(30);
 35    BEGIN
 36  	 l_return := sosl_sys.FATAL_TYPE;
 37  	 IF log_type_valid(p_log_type)
 38  	 THEN
 39  	   l_return := UPPER(p_log_type);
 40  	 ELSE
 41  	   IF	   log_type_valid(p_error_default)
 42  	      AND  UPPER(p_error_default) NOT IN ( sosl_sys.INFO_TYPE
 43  						 , sosl_sys.SUCCESS_TYPE
 44  						 )
 45  	   THEN
 46  	     l_return := UPPER(p_error_default);
 47  	   END IF;
 48  	 END IF;
 49  	 RETURN l_return;
 50    EXCEPTION
 51  	 WHEN OTHERS THEN
 52  	   RETURN sosl_sys.FATAL_TYPE;
 53    END get_valid_log_type;
 54  
 55    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
 56  			  , p_clob		IN OUT NOCOPY  CLOB
 57  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
 58  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
 59  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
 60  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
 61  			  )
 62  	 RETURN BOOLEAN
 63    IS
 64  	 l_string  VARCHAR2(32767);
 65    BEGIN
 66  	 IF	(p_string IS NULL OR NVL(LENGTH(TRIM(p_string)), 0) = 0)
 67  	    AND (p_clob   IS NULL OR NVL(LENGTH(TRIM(p_clob)), 0) = 0)
 68  	 THEN
 69  	   RETURN FALSE;
 70  	 END IF;
 71  	 IF	p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
 72  	    AND p_clob	 IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
 73  	 THEN
 74  	   IF LENGTH(p_string) > p_max_string_length
 75  	   THEN
 76  	     -- need to split
 77  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1)) || p_delimiter;
 78  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
 79  	     p_clob   := l_string || p_clob;
 80  	   END IF;
 81  	   RETURN TRUE;
 82  	 END IF;
 83  	 IF p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
 84  	 THEN
 85  	   IF LENGTH(p_string) > p_max_string_length
 86  	   THEN
 87  	     -- need to split
 88  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1));
 89  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
 90  	     p_clob   := TO_CLOB(l_string);
 91  	   ELSE
 92  	     p_clob := TO_CLOB(l_string);
 93  	   END IF;
 94  	   RETURN TRUE;
 95  	 END IF;
 96  	 IF p_clob IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
 97  	 THEN
 98  	   IF LENGTH(p_clob) > p_max_string_length
 99  	   THEN
100  	     p_string := TO_CHAR(SUBSTR(p_clob, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end);
101  	   ELSE
102  	     p_string := TO_CHAR(p_clob);
103  	   END IF;
104  	   RETURN TRUE;
105  	 END IF;
106  	 -- should not reach this point
107  	 p_string := 'ERROR sosl_sys.distribute: INCOMPLETE LOGIC';
108  	 RETURN FALSE;
109    EXCEPTION
110  	 WHEN OTHERS THEN
111  	   p_string := TRIM(SUBSTR(SQLERRM, 1, 4000));
112  	   RETURN FALSE;
113    END distribute;
114  
115    FUNCTION txt_boolean( p_bool   IN BOOLEAN
116  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
117  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
118  			   )
119  	 RETURN VARCHAR2
120  	 DETERMINISTIC
121  	 PARALLEL_ENABLE
122    IS
123    BEGIN
124  	 IF p_bool
125  	 THEN
126  	   RETURN TRIM(SUBSTR(NVL(p_true, 'TRUE'), 1, 10));
127  	 ELSE
128  	   RETURN TRIM(SUBSTR(NVL(p_false, 'FALSE'), 1, 10));
129  	 END IF;
130    END txt_boolean; -- boolean input
131  
132    FUNCTION txt_boolean( p_bool   IN NUMBER
133  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
134  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
135  			   )
136  	 RETURN VARCHAR2
137  	 DETERMINISTIC
138  	 PARALLEL_ENABLE
139    IS
140    BEGIN
141  	 RETURN sosl_sys.txt_boolean((p_bool = 1), p_true, p_false);
142    END txt_boolean; -- number input
143  
144    FUNCTION yes_no( p_bool	 IN BOOLEAN
145  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
146  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
147  		      )
148  	 RETURN VARCHAR2
149  	 DETERMINISTIC
150  	 PARALLEL_ENABLE
151    IS
152    BEGIN
153  	 RETURN sosl_sys.txt_boolean(p_bool, p_true, p_false);
154    END yes_no;
155  
156    FUNCTION yes_no( p_bool	 IN NUMBER
157  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
158  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
159  		      )
160  	 RETURN VARCHAR2
161  	 DETERMINISTIC
162  	 PARALLEL_ENABLE
163    IS
164    BEGIN
165  	 RETURN sosl_sys.txt_boolean((p_bool = 1), p_true, p_false);
166    END yes_no;
167  
168    FUNCTION utc_mail_date
169  	 RETURN VARCHAR2
170    IS
171  	 l_date VARCHAR2(500);
172    BEGIN
173  	 l_date := TO_CHAR(SYSTIMESTAMP AT TIME ZONE SESSIONTIMEZONE, 'Dy, DD Mon YYYY HH24:MI:SS TZHTZM');
174  	 RETURN l_date;
175    END utc_mail_date;
176  
177    FUNCTION format_mail( p_sender	   IN VARCHAR2
178  			   , p_recipients  IN VARCHAR2
179  			   , p_subject	   IN VARCHAR2
180  			   , p_message	   IN VARCHAR2
181  			   )
182  	 RETURN VARCHAR2
183    IS
184  	 l_crlf 	 VARCHAR2(2)	   := CHR(13) || CHR(10);
185  	 l_mail_message  VARCHAR2(32767);
186    BEGIN
187  	 l_mail_message := 'From: ' || p_sender || l_crlf ||
188  			   'To: ' || p_recipients || l_crlf ||
189  			   'Date: ' || sosl_sys.utc_mail_date || l_crlf ||
190  			   'Subject: ' || p_subject || l_crlf ||
191  			   p_message
192  	 ;
193  	 RETURN l_mail_message;
194    END format_mail;
195  
196  END;
197  /

Package body created.

SQL> -- logging table
SQL> @@../sosl_ddl/tables/sosl_server_log.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_server_log
  2    ( exec_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP 		     NOT NULL
  3  	 -- due to Oracle limitations we must use trigger not a package variable, trigger takes care
  4  	 -- to assign a default INFO log type if getting sosl_sys.NA_TYPE
  5    , log_type	   VARCHAR2(30)    DEFAULT 'n/a'			     NOT NULL
  6    , log_category	   VARCHAR2(256)   DEFAULT 'n/a'			     NOT NULL
  7    , message	   VARCHAR2(4000)					     NOT NULL
  8    , run_id 	   NUMBER(38, 0)
  9    , executor_id	   NUMBER(38, 0)
 10    , guid		   VARCHAR2(64)
 11    , sosl_identifier   VARCHAR2(256)
 12    , caller 	   VARCHAR2(256)
 13    , ext_script_id	   VARCHAR2(4000)
 14    , script_file	   VARCHAR2(4000)
 15    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 16    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , full_message	   CLOB
 18    )
 19    -- monthly partitions
 20    PARTITION BY RANGE (exec_timestamp)
 21    INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
 22    (PARTITION P_OLD
 23  	   VALUES LESS THAN (TO_TIMESTAMP('01-01-2024','DD-MM-YYYY'))
 24    )
 25  ;

Table created.

SQL> COMMENT ON TABLE sosl_server_log IS 'Holds the log events of the SOSL server CMD and interaction with the database as well as database events. Update is not allowed. Will use the alias slog.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.exec_timestamp IS 'The timestamp of the event. Automatically set by trigger, no set allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_type IS 'The logging type, supports currently INFO, WARNING, ERROR, FATAL, SUCCESS. Mandatory. Defined in package SOSL_SYS.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_category IS 'The log writer may provide an short log category description.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.message IS 'The shortend log message. Mandatory. If only a CLOB is passed, the short message is build from the CLOB. Categories too long will be cutted.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.full_message IS 'The full log message. For messages longer than 4000 bytes or char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.guid IS 'The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.sosl_identifier IS 'The exact identifier for SOSLERRORLOG if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.run_id IS 'The associated run id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.executor_id IS 'The associated executor id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.ext_script_id IS 'The (external) script id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.caller IS 'Caller identification if available, to distinguish database processes from SOSL CMD server processes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by IS 'The logged in DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- no primary key, only index
SQL> CREATE INDEX sosl_server_log_idx
  2    ON sosl_server_log (exec_timestamp, log_type, log_category)
  3  ;

Index created.

SQL> -- no constraints, as Oracle does not allow package functions in CHECK conditions
SQL> 
SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_server_log_ins_trg
  2    BEFORE INSERT ON sosl_server_log
  3    FOR EACH ROW
  4  DECLARE
  5    l_split BOOLEAN;
  6  BEGIN
  7    -- first set default value if not set, as Oracle does not support default values from package variables
  8    IF :NEW.log_type = sosl_sys.NA_TYPE
  9    THEN
 10  	 :NEW.log_type := sosl_sys.INFO_TYPE;
 11    END IF;
 12    -- instead of check constraint to get package support
 13    IF NOT sosl_sys.log_type_valid(:NEW.log_type)
 14    THEN
 15  	 -- do not block logging, log the error instead, move message to full message
 16  	 :NEW.full_message := :NEW.message || :NEW.full_message;
 17  	 :NEW.message	   := 'Invalid log type. Not supported by package SOSL_SYS. Given log type: ' || :NEW.log_type;
 18  	 :NEW.log_type	   := sosl_sys.FATAL_TYPE;
 19    ELSE
 20  	 :NEW.log_type := sosl_sys.get_valid_log_type(:NEW.log_type);
 21    END IF;
 22    :NEW.exec_timestamp := SYSTIMESTAMP;
 23    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 24    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 25    -- split messages
 26    IF NOT sosl_sys.distribute(:NEW.message, :NEW.full_message, 4000)
 27    THEN
 28  	 -- do not block logging, log the error instead, if :NEW.message contains error information leave it there
 29  	 IF :NEW.message IS NULL AND :NEW.full_message IS NULL
 30  	 THEN
 31  	   :NEW.message := 'Full message must be given, if message is NULL or vice versa.';
 32  	 END IF;
 33  	 :NEW.log_type := sosl_sys.FATAL_TYPE;
 34    END IF;
 35  END;
 36  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_upd_trg
  2    BEFORE UPDATE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20005, 'No updates allowed on a log table.');
  6  END;
  7  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_del_trg
  2    BEFORE DELETE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20006, 'Delete records from a log table is not allowed. This is an admin job which needs sufficient rights.');
  6  END;
  7  /

Trigger created.

SQL> -- Grants, inherited by others, no guest access on table
SQL> GRANT SELECT ON sosl_server_log TO sosl_user;

Grant succeeded.

SQL> -- logging package
SQL> @@../sosl_ddl/packages/sosl_log.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic logging package, dependencies only to sosl_server_log and sosl_sys.
SQL> CREATE OR REPLACE PACKAGE sosl_log
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader for managing logging.
  5    * Apart from sosl_server_log table, there are no dependencies, severe exceptions must be catched or handled by the caller.
  6    * The interface has as well functions and procedures. Functions inform about success or error, whereas procedure exceptions
  7    * must be handled by the caller. The intention is to log as much information as possible before running into an exception
  8    * that can't be handled any longer.
  9    *
 10    * CURRENT ORACLE error: NOCOPY for IN parameters creates compile errors, whereas documentation allows IN NOCOPY var. Any
 11    * CLOB handling errors are possibly caused by the inability to provide a CLOB as reference.
 12    */
 13  
 14    /*====================================== start internal functions made visible for testing ======================================*/
 15    /* PROCEDURE SOSL_LOG.LOG_FALLBACK
 16    * This procedure tries some fallback actions, if logging raised an exception. It will not throw an extra exception. Intended to be
 17    * used during exception handling before raising the error.
 18    * It will try to log the error in one of this tables: SOSL_SERVER_LOG, SOSLERRORLOG, SPERRORLOG or, if everything fails output the error
 19    * via DBMS_OUTPUT.
 20    *
 21    * As we can't determine if the message contains an illegal character forcing the exception, the caller should transfer SQLERRM and
 22    * verify the transmitted content before passing it to this procedure or avoid transmitting parameters which should cause errors.
 23    *
 24    * If error could be logged it matches as follows:
 25    * SOSL_SERVER_LOG(caller, sosl_identifier, message) VALUES (p_script, p_identifier, p_message)
 26    * SOSLERRORLOG, SPERRORLOG(script, identifier, message) VALUES (p_script, p_identifier, p_message)
 27    * It will not prevent the exception, only try to log it somewhere, where it could be found without needing to analyze the db server
 28    * logs. Everything runs as autonomous transaction.
 29    *
 30    * DO NOT USE THIS PROCEDURE. It is internal for this package and only visible for testing.
 31    *
 32    * @param p_script The package function or procedure causing the error, e.g. sosl_log.log_event.
 33    * @param p_identifier The identifier for this error. Saved in SOSL_IDENTIFIER in SOSL_SERVER_LOG or IDENTIFIER in the error log tables.
 34    * @param p_message The message to save. Reduce it to SQLERRM if possible.
 35    */
 36    PROCEDURE log_fallback( p_script      IN VARCHAR2
 37  			     , p_identifier  IN VARCHAR2
 38  			     , p_message     IN VARCHAR2
 39  			     )
 40    ;
 41    /* PROCEDURE SOSL_LOG.LOG_EVENT
 42    * Writes a log entry as autonomous transaction. This is the internal base procedure, exposed for testing.
 43    * If on errors writing log entries is not possible the procedure hands the exception to the caller. This is the pure insert without
 44    * any checks. It takes the values as given and table may trigger exceptions. DO NOT USE THIS PROCEDURE. It is internal for this package.
 45    *
 46    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 47    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Must be valid.
 48    * @param p_log_category An optional logging category.
 49    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 50    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 51    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 52    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 53    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 54    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 55    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 56    */
 57    PROCEDURE log_event( p_message	       IN VARCHAR2
 58  			  , p_log_type	       IN VARCHAR2
 59  			  , p_log_category     IN VARCHAR2
 60  			  , p_guid	       IN VARCHAR2
 61  			  , p_sosl_identifier  IN VARCHAR2
 62  			  , p_executor_id      IN NUMBER
 63  			  , p_ext_script_id    IN VARCHAR2
 64  			  , p_caller	       IN VARCHAR2
 65  			  , p_run_id	       IN NUMBER
 66  			  , p_full_message     IN CLOB
 67  			  )
 68    ;
 69  /*====================================== end internal functions made visible for testing ======================================*/
 70  
 71    /* PROCEDURE SOSL_LOG.FULL_LOG
 72    * Procedure with all parameters for logging. Will check parameters before logging. You should at least set also p_log_category
 73    * and p_caller, to be able to assign the log entry to a specific event and object. On parameter errors a separate log entry is
 74    * created. Intention is to write a log in any case and not throw any exception. This still may happen on main system malfunctions
 75    * but is limited to this events.
 76    * To keep things as fast as possible, column length checks are hardcoded, no extra round trip to USER_TAB_COLUMNS. If table definition
 77    * changes, this package has to be adjusted.
 78    *
 79    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 80    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Will be set to ERROR if not valid.
 81    * @param p_log_category An optional logging category.
 82    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 83    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 84    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 85    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 86    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 87    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 88    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 89    */
 90    PROCEDURE full_log( p_message	      IN VARCHAR2
 91  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_sys.INFO_TYPE
 92  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
 93  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
 94  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
 95  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
 96  			 , p_executor_id      IN NUMBER      DEFAULT NULL
 97  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
 98  			 , p_run_id	      IN NUMBER      DEFAULT NULL
 99  			 , p_full_message     IN CLOB	     DEFAULT NULL
100  			 )
101    ;
102  
103    /* FUNCTION SOSL_LOG.DUMMY_MAIL
104    * This is a testing function that will NOT send any mail. It will log the mail message created in SOSL_SERVER_LOG using
105    * the field full_message, so output can be controlled.
106    *
107    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
108    * @param p_recipients The semicolon separated list of mail recipient addresses.
109    * @param p_subject A preferablly short subject for the mail.
110    * @param p_message The correctly formatted mail message.
111    *
112    * @return Will return 0 on success or -1 on errors.
113    */
114    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
115  			  , p_recipients  IN VARCHAR2
116  			  , p_subject	  IN VARCHAR2
117  			  , p_message	  IN VARCHAR2
118  			  )
119  	 RETURN NUMBER
120    ;
121  
122  END;
123  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_log.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_log
  2  AS
  3    -- for description see header file
  4    PROCEDURE log_fallback( p_script      IN VARCHAR2
  5  			     , p_identifier  IN VARCHAR2
  6  			     , p_message     IN VARCHAR2
  7  			     )
  8    IS
  9  	 PRAGMA AUTONOMOUS_TRANSACTION;
 10  	 l_saved BOOLEAN;
 11    BEGIN
 12  	 l_saved := FALSE;
 13  	 -- try to save information in tables probably available
 14  	 BEGIN
 15  	   INSERT INTO sosl_server_log
 16  	     ( message
 17  	     , log_type
 18  	     , log_category
 19  	     , sosl_identifier
 20  	     , caller
 21  	     )
 22  	     VALUES
 23  	       ( p_message
 24  	       , sosl_sys.FATAL_TYPE
 25  	       , 'SOSL_LOG internal error'
 26  	       , p_identifier
 27  	       , p_script
 28  	       )
 29  	   ;
 30  	   COMMIT;
 31  	   l_saved := TRUE;
 32  	 EXCEPTION
 33  	   WHEN OTHERS THEN
 34  	     l_saved := FALSE;
 35  	 END;
 36  	 IF NOT l_saved
 37  	 THEN
 38  	   BEGIN
 39  	     INSERT INTO soslerrorlog
 40  	       ( message
 41  	       , identifier
 42  	       , script
 43  	       , username
 44  	       , timestamp
 45  	       )
 46  	       VALUES
 47  		 ( p_message
 48  		 , p_identifier
 49  		 , p_script
 50  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 51  		 , SYSTIMESTAMP
 52  		 )
 53  	     ;
 54  	     COMMIT;
 55  	     l_saved := TRUE;
 56  	   EXCEPTION
 57  	     WHEN OTHERS THEN
 58  	       l_saved := FALSE;
 59  	   END;
 60  	 END IF;
 61  	 IF NOT l_saved
 62  	 THEN
 63  	   BEGIN
 64  	     INSERT INTO sperrorlog
 65  	       ( message
 66  	       , identifier
 67  	       , script
 68  	       , username
 69  	       , timestamp
 70  	       )
 71  	       VALUES
 72  		 ( p_message
 73  		 , p_identifier
 74  		 , p_script
 75  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 76  		 , SYSTIMESTAMP
 77  		 )
 78  	     ;
 79  	     COMMIT;
 80  	     l_saved := TRUE;
 81  	   EXCEPTION
 82  	     WHEN OTHERS THEN
 83  	       l_saved := FALSE;
 84  	   END;
 85  	 END IF;
 86  	 -- all inserts failed, use DBMS_OUTPUT
 87  	 IF NOT l_saved
 88  	 THEN
 89  	   DBMS_OUTPUT.PUT_LINE('SOSL_LOG.LOG_FALLBACK could not save error. Fatal error in ' || p_script || ' error: ' || p_message);
 90  	 END IF;
 91    EXCEPTION
 92  	 WHEN OTHERS THEN
 93  	   -- fallback failed, let caller handle and raise the error, do nothing therefore.
 94  	   NULL;
 95    END log_fallback;
 96  
 97    PROCEDURE log_event( p_message	       IN VARCHAR2
 98  			  , p_log_type	       IN VARCHAR2
 99  			  , p_log_category     IN VARCHAR2
100  			  , p_guid	       IN VARCHAR2
101  			  , p_sosl_identifier  IN VARCHAR2
102  			  , p_executor_id      IN NUMBER
103  			  , p_ext_script_id    IN VARCHAR2
104  			  , p_caller	       IN VARCHAR2
105  			  , p_run_id	       IN NUMBER
106  			  , p_full_message     IN CLOB
107  			  )
108    IS
109  	 PRAGMA AUTONOMOUS_TRANSACTION;
110    BEGIN
111  	 INSERT INTO sosl_server_log
112  	   ( message
113  	   , log_type
114  	   , log_category
115  	   , guid
116  	   , sosl_identifier
117  	   , executor_id
118  	   , ext_script_id
119  	   , caller
120  	   , run_id
121  	   , full_message
122  	   )
123  	   VALUES
124  	     ( p_message
125  	     , p_log_type
126  	     , p_log_category
127  	     , p_guid
128  	     , p_sosl_identifier
129  	     , p_executor_id
130  	     , p_ext_script_id
131  	     , p_caller
132  	     , p_run_id
133  	     , p_full_message
134  	     )
135  	 ;
136  	 COMMIT;
137    EXCEPTION
138  	 WHEN OTHERS THEN
139  	   -- try fallback
140  	   log_fallback('sosl_log.log_event', 'SOSL_LOG', SQLERRM);
141  	   -- try ROLLBACK
142  	   ROLLBACK;
143  	   -- and raise the error again now
144  	   RAISE;
145    END log_event;
146  
147    PROCEDURE full_log( p_message	      IN VARCHAR2
148  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_sys.INFO_TYPE
149  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
150  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
151  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
152  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
153  			 , p_executor_id      IN NUMBER      DEFAULT NULL
154  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
155  			 , p_run_id	      IN NUMBER      DEFAULT NULL
156  			 , p_full_message     IN CLOB	     DEFAULT NULL
157  			 )
158    IS
159  	 -- set variables to current type
160  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
161  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.full_log';
162  	 l_log_category      sosl_server_log.log_category%TYPE;
163  	 l_caller	     sosl_server_log.caller%TYPE;
164  	 l_guid 	     sosl_server_log.guid%TYPE;
165  	 l_sosl_identifier   sosl_server_log.sosl_identifier%TYPE;
166  	 l_executor_id	     sosl_server_log.executor_id%TYPE;
167  	 l_ext_script_id     sosl_server_log.ext_script_id%TYPE;
168  	 l_run_id	     sosl_server_log.run_id%TYPE;
169  	 l_col_length	     INTEGER;
170    BEGIN
171  	 -- basic column checks message splitting is left to table triggers
172  	 -- LOG_CATEGORY
173  	 IF NVL(LENGTH(TRIM(p_log_category)), 0) > 256
174  	 THEN
175  	   -- write extra log entry and cut original content to limit
176  	   log_event( p_message => 'p_log_category length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
177  		    , p_log_type => sosl_sys.FATAL_TYPE
178  		    , p_log_category => l_self_log_category
179  		    , p_guid => NULL
180  		    , p_sosl_identifier => NULL
181  		    , p_executor_id => NULL
182  		    , p_ext_script_id => NULL
183  		    , p_caller => l_self_caller
184  		    , p_run_id => NULL
185  		      -- details and original message
186  		    , p_full_message => ('LOG_CATEGORY: ' || TRIM(p_log_category) || ' length: ' || LENGTH(TRIM(p_log_category)) || ' msg: ' || p_message || ' - ' || p_full_message)
187  		    )
188  	   ;
189  	   l_log_category := SUBSTR(TRIM(p_log_category), 1, 256);
190  	 ELSE
191  	   l_log_category := NVL(TRIM(p_log_category), sosl_sys.NA_TYPE);
192  	 END IF;
193  	 -- CALLER
194  	 IF NVL(LENGTH(TRIM(p_caller)), 0) > 256
195  	 THEN
196  	   -- write extra log entry and cut original content to limit
197  	   log_event( p_message => 'p_caller length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
198  		    , p_log_type => sosl_sys.FATAL_TYPE
199  		    , p_log_category => l_self_log_category
200  		    , p_guid => NULL
201  		    , p_sosl_identifier => NULL
202  		    , p_executor_id => NULL
203  		    , p_ext_script_id => NULL
204  		    , p_caller => l_self_caller
205  		    , p_run_id => NULL
206  		      -- details and original message
207  		    , p_full_message => ('CALLER: ' || TRIM(p_caller) || ' length: ' || LENGTH(TRIM(p_caller)) || ' msg: ' || p_message || ' - ' || p_full_message)
208  		    )
209  	   ;
210  	   l_caller := SUBSTR(TRIM(p_caller), 1, 256);
211  	 ELSE
212  	   l_caller := TRIM(p_caller);
213  	 END IF;
214  	 -- GUID
215  	 IF NVL(LENGTH(TRIM(p_guid)), 0) > 64
216  	 THEN
217  	   -- write extra log entry and cut original content to limit
218  	   log_event( p_message => 'p_guid length exceeds column length (64) in SOSL_SERVER_LOG. See full message for message causing the error.'
219  		    , p_log_type => sosl_sys.FATAL_TYPE
220  		    , p_log_category => l_self_log_category
221  		    , p_guid => NULL
222  		    , p_sosl_identifier => NULL
223  		    , p_executor_id => NULL
224  		    , p_ext_script_id => NULL
225  		    , p_caller => l_self_caller
226  		    , p_run_id => NULL
227  		      -- details and original message
228  		    , p_full_message => ('GUID: ' || TRIM(p_guid) || ' length: ' || LENGTH(TRIM(p_guid)) || ' msg: ' || p_message || ' - ' || p_full_message)
229  		    )
230  	   ;
231  	   l_guid := SUBSTR(TRIM(p_guid), 1, 64);
232  	 ELSE
233  	   l_guid := TRIM(p_guid);
234  	 END IF;
235  	 -- SOSL_IDENTIFIER
236  	 IF NVL(LENGTH(TRIM(p_sosl_identifier)), 0) > 256
237  	 THEN
238  	   -- write extra log entry and cut original content to limit
239  	   log_event( p_message => 'p_sosl_identifier length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
240  		    , p_log_type => sosl_sys.FATAL_TYPE
241  		    , p_log_category => l_self_log_category
242  		    , p_guid => NULL
243  		    , p_sosl_identifier => NULL
244  		    , p_executor_id => NULL
245  		    , p_ext_script_id => NULL
246  		    , p_caller => l_self_caller
247  		    , p_run_id => NULL
248  		      -- details and original message
249  		    , p_full_message => ('SOSL_IDENTIFIER: ' || TRIM(p_sosl_identifier) || ' length: ' || LENGTH(TRIM(p_sosl_identifier)) || ' msg: ' || p_message || ' - ' || p_full_message)
250  		    )
251  	   ;
252  	   l_sosl_identifier := SUBSTR(TRIM(p_sosl_identifier), 1, 256);
253  	 ELSE
254  	   l_sosl_identifier := TRIM(p_sosl_identifier);
255  	 END IF;
256  	 -- EXT_SCRIPT_ID
257  	 IF NVL(LENGTH(TRIM(p_ext_script_id)), 0) > 4000
258  	 THEN
259  	   -- write extra log entry and cut original content to limit
260  	   log_event( p_message => 'p_ext_script_id length exceeds column length (4000) in SOSL_SERVER_LOG. See full message for message causing the error.'
261  		    , p_log_type => sosl_sys.FATAL_TYPE
262  		    , p_log_category => l_self_log_category
263  		    , p_guid => NULL
264  		    , p_sosl_identifier => NULL
265  		    , p_executor_id => NULL
266  		    , p_ext_script_id => NULL
267  		    , p_caller => l_self_caller
268  		    , p_run_id => NULL
269  		      -- details and original message
270  		    , p_full_message => ('EXT_SCRIPT_ID: ' || TRIM(p_ext_script_id) || ' length: ' || LENGTH(TRIM(p_ext_script_id)) || ' msg: ' || p_message || ' - ' || p_full_message)
271  		    )
272  	   ;
273  	   l_ext_script_id := SUBSTR(TRIM(p_ext_script_id), 1, 4000);
274  	 ELSE
275  	   l_ext_script_id := TRIM(p_ext_script_id);
276  	 END IF;
277  	 -- no check on numbers
278  	 l_executor_id := p_executor_id;
279  	 l_run_id := p_run_id;
280  	 -- try to write the given data to SOSL_SERVER_LOG
281  	 log_event( p_message => p_message
282  		  , p_log_type => p_log_type
283  		  , p_log_category => l_log_category
284  		  , p_guid => l_guid
285  		  , p_sosl_identifier => l_sosl_identifier
286  		  , p_executor_id => l_executor_id
287  		  , p_ext_script_id => l_ext_script_id
288  		  , p_caller => l_caller
289  		  , p_run_id => l_run_id
290  		  , p_full_message => p_full_message
291  		  )
292  	 ;
293    EXCEPTION
294  	 WHEN OTHERS THEN
295  	   log_event( p_message => 'full log error: ' || TRIM(SUBSTR(SQLERRM, 1, 3900))
296  		    , p_log_type => sosl_sys.FATAL_TYPE
297  		    , p_log_category => l_self_log_category
298  		    , p_guid => NULL
299  		    , p_sosl_identifier => NULL
300  		    , p_executor_id => NULL
301  		    , p_ext_script_id => NULL
302  		    , p_caller => l_self_caller
303  		    , p_run_id => NULL
304  		      -- full details and original message
305  		    , p_full_message => (SQLERRM || ': ' || p_message)
306  		    )
307  	   ;
308    END full_log;
309  
310    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
311  			  , p_recipients  IN VARCHAR2
312  			  , p_subject	  IN VARCHAR2
313  			  , p_message	  IN VARCHAR2
314  			  )
315  	 RETURN NUMBER
316    IS
317  	 l_message	 VARCHAR2(32767);
318  	 l_category	 sosl_server_log.log_category%TYPE   := 'MAIL DUMMY';
319  	 l_caller	 sosl_server_log.caller%TYPE	     := 'sosl_log.dummy_mail';
320    BEGIN
321  	 l_message := sosl_sys.format_mail(p_sender, p_recipients, p_subject, p_message);
322  	 full_log( p_message => 'Fake mail with subject "' || p_subject || '" created in full_message. Check the results.'
323  		 , p_log_type => sosl_sys.INFO_TYPE
324  		 , p_log_category => l_category
325  		 , p_caller => l_caller
326  		 , p_full_message => l_message
327  		 )
328  	 ;
329  	 RETURN sosl_sys.SUCCESS_NUM;
330    EXCEPTION
331  	 WHEN OTHERS THEN
332  	   -- log the error instead of RAISE
333  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl_log.dummy_mail function: ' || SQLERRM
334  			    , p_log_type => sosl_sys.FATAL_TYPE
335  			    , p_log_category => l_category
336  			    , p_caller => l_caller
337  			    )
338  	   ;
339  	   RETURN sosl_sys.ERR_NUM;
340    END dummy_mail;
341  
342  END;
343  /

Package body created.

SQL> -- util package
SQL> @@../sosl_ddl/packages/sosl_util.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic util package not using data objects of the Simple Oracle Script Loader, apart from sosl_sys and logging.
SQL> CREATE OR REPLACE PACKAGE sosl_util
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader that have minimal dependencies on
  5    * SOSL object. Provides logging.
  6    */
  7  
  8    /* PROCEDURE SOSL_UTIL.SPLIT_FUNCTION_NAME
  9    * Splits the given function name into its parts. Supposed delimiter is the point ".".
 10    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 11    * @param p_package OUT parameter, contains the package name if any or NULL.
 12    * @param p_function OUT parameter, contains the pure function name.
 13    */
 14    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
 15  				    , p_package       OUT VARCHAR2
 16  				    , p_function      OUT VARCHAR2
 17  				    )
 18    ;
 19  
 20    /* FUNCTION SOSL_UTIL.HAS_DB_USER
 21    * Checks if a given user is visible for SOSL by checking ALL_USERS. Users must be visible to SOSL to be able to dynamically
 22    * grant the necessary rights on the API for script execution.
 23    *
 24    * @param p_username The database user name to check.
 25    *
 26    * @return TRUE if the user is visible in ALL_USERS to SOSL, otherwise FALSE.
 27    */
 28    FUNCTION has_db_user(p_username IN VARCHAR2)
 29  	 RETURN BOOLEAN
 30    ;
 31  
 32    /* FUNCTION SOSL_SYS.HAS_FUNCTION
 33    * Checks if a given function or package function name is visible for SOSL by checking ALL_ATTRIBUTES. The package SOSL_API is
 34    * excluded from the search to avoid references in SOSL_EXECUTOR.
 35    *
 36    * @param p_owner The owner of the function or package function name to check.
 37    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 38    * @param p_datatype The return datatype of the function expected, e.g. a valid Oracle datatype like NUMBER or VARCHAR2.
 39    *
 40    * @return TRUE if the function is visible in ALL_ATTRIBUTES to SOSL and has the required return datatype, otherwise FALSE.
 41    */
 42    FUNCTION has_function( p_owner	       IN VARCHAR2
 43  			    , p_function_name  IN VARCHAR2
 44  			    , p_datatype       IN VARCHAR2
 45  			    )
 46  	 RETURN BOOLEAN
 47    ;
 48  
 49    /*FUNCTION SOSL_SYS.GET_COL_LENGTH
 50    * Returns the column length for a given table and column or -1 if table or column does not exist from USER_TAB_COLUMNS using
 51    * DATA_LENGTH. DATA_LENGTH is misleading if not a char type or CLOB, as CLOB types report 4000 which is definitely wrong.
 52    * The only types handled are NUMBER and CLOB. All other types return the DATA_LENGTH.
 53    *
 54    * Length for numbers is calculated by adding precision and scale.
 55    *
 56    * CLOB will return the PLSQL equation of a VARCHAR2/CLOB, which is 32767 and still wrong, but useful to see if a PLSQL can handle
 57    * the CLOB. Be careful with CLOB handling. If source is not a table column, PLSQL most likely limits it to 32767 cutting longer content.
 58    *
 59    * Objects not in the current schema will not be considered and return -1 AS USER_TAB_COLUMN is used.
 60    *
 61    * No handling for date and timestamp values, as their char representation has too much dependencies on NLS and formatting to get a
 62    * reliable length.
 63    *
 64    * Byte and char semantic is not considered only the effective chars that can be stored in CHAR or VARCHAR2 as defined by DATA_LENGTH.
 65    *
 66    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
 67    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
 68    *
 69    * @return The calculated length of the column. Fix PLSQL limit 32767 for CLOB types. DATA_LENGTH for data and timestamp types.
 70    */
 71    FUNCTION get_col_length( p_table  IN VARCHAR2
 72  			      , p_column IN VARCHAR2
 73  			      )
 74  	 RETURN INTEGER
 75    ;
 76  
 77    /* FUNCTION SOSL_SYS.GET_COL_TYPE
 78    * Returns the type of a column from USER_TAB_COLUMNS as defined in DATA_TYPE or NA_TYPE if table or column doesn't exist.
 79    * Objects not in the current schema will not be considered and return NA_TYPE.
 80    *
 81    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
 82    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
 83    *
 84    * @return The type of the column as defined in DATA_TYPE or sosl_sys.NA_TYPE on errors or not found columns and tables.
 85    */
 86    FUNCTION get_col_type( p_table  IN VARCHAR2
 87  			    , p_column IN VARCHAR2
 88  			    )
 89  	 RETURN VARCHAR2
 90    ;
 91  
 92    /* FUNCTION SOSL_SYS.CHECK_COL
 93    * This function can check NUMBER and VARCHAR2/CHAR columns for length and type. Passing a number for a char column type will result
 94    * in FALSE. Providing a P_VALUE with a length longer than the length calculated, will result in FALSE. It will not consider
 95    * implicite Oracle conversions. Expects type like defined.
 96    *
 97    * Number length is calculated by TO_CHAR string representation removing all delimiters and counting only numbers 0-9.
 98    * Passing a VARCHAR2 value is valid for CHAR and VARCHAR2 column types.
 99    *
100    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
101    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
102    * @param p_value The value for the table column to check against column definition.
103    *
104    * @return TRUE if value and column match in type and length, otherwise FALSE.
105    */
106    FUNCTION check_col( p_table  IN VARCHAR2
107  			 , p_column IN VARCHAR2
108  			 , p_value  IN VARCHAR2
109  			 )
110  	 RETURN BOOLEAN
111    ;
112    FUNCTION check_col( p_table  IN VARCHAR2
113  			 , p_column IN VARCHAR2
114  			 , p_value  IN NUMBER
115  			 )
116  	 RETURN BOOLEAN
117    ;
118  
119  END;
120  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_util.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_util
  2  AS
  3    -- for description see header file
  4    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
  5  				    , p_package       OUT VARCHAR2
  6  				    , p_function      OUT VARCHAR2
  7  				    )
  8    IS
  9    BEGIN
 10  	 IF INSTR(p_function_name, '.') > 0
 11  	 THEN
 12  	   p_package   := TRIM(SUBSTR(p_function_name, 1, INSTR(p_function_name, '.') -1));
 13  	   p_function  := TRIM(SUBSTR(p_function_name, INSTR(p_function_name, '.') +1));
 14  	 ELSE
 15  	   p_package   := NULL;
 16  	   p_function  := TRIM(p_function_name);
 17  	 END IF;
 18    END split_function_name;
 19  
 20    FUNCTION has_db_user(p_username IN VARCHAR2)
 21  	 RETURN BOOLEAN
 22    IS
 23  	 l_has_user  NUMBER;
 24  	 l_return    BOOLEAN;
 25    BEGIN
 26  	 l_return := FALSE;
 27  	 SELECT COUNT(*) INTO l_has_user FROM all_users WHERE username = p_username;
 28  	 IF l_has_user != 0
 29  	 THEN
 30  	   l_return := TRUE;
 31  	 END IF;
 32  	 RETURN l_return;
 33    END has_db_user;
 34  
 35    FUNCTION has_function( p_owner	       IN VARCHAR2
 36  			    , p_function_name  IN VARCHAR2
 37  			    , p_datatype       IN VARCHAR2
 38  			    )
 39  	 RETURN BOOLEAN
 40    IS
 41  	 l_has_function  NUMBER;
 42  	 l_package	 VARCHAR2(128);
 43  	 l_function	 VARCHAR2(128);
 44  	 l_return	 BOOLEAN;
 45    BEGIN
 46  	 l_return := FALSE;
 47  	 split_function_name(p_function_name, l_package, l_function);
 48  	 SELECT COUNT(*)
 49  	   INTO l_has_function
 50  	   FROM all_arguments
 51  	  WHERE position		   = 0				     -- only functions
 52  	    AND argument_name		   IS NULL			     -- only functions
 53  	    AND data_type		   = p_datatype
 54  	    AND owner			   = UPPER(p_owner)
 55  	    AND NVL(package_name, 'N/A')   = NVL(UPPER(l_package), 'N/A')    -- may not contain a package name
 56  	    AND object_name		   = UPPER(l_function)
 57  	    AND package_name		  != 'SOSL'			     -- exclude base package should never be referenced
 58  	 ;
 59  	 IF l_has_function != 0
 60  	 THEN
 61  	   l_return := TRUE;
 62  	 END IF;
 63  	 RETURN l_return;
 64    END has_function;
 65  
 66    FUNCTION get_col_length( p_table  IN VARCHAR2
 67  			      , p_column IN VARCHAR2
 68  			      )
 69  	 RETURN INTEGER
 70    IS
 71  	 l_return	   INTEGER;
 72  	 l_has_column	   INTEGER;
 73  	 l_data_type	   user_tab_columns.data_type%TYPE;
 74  	 l_data_length	   user_tab_columns.data_length%TYPE;
 75  	 l_data_precision  user_tab_columns.data_precision%TYPE;
 76  	 l_data_scale	   user_tab_columns.data_scale%TYPE;
 77    BEGIN
 78  	 l_return := -1;
 79  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
 80  	 IF l_has_column = 1
 81  	 THEN
 82  	   -- column match calculate length
 83  	   SELECT data_type
 84  		, data_length
 85  		, data_precision
 86  		, data_scale
 87  	     INTO l_data_type
 88  		, l_data_length
 89  		, l_data_precision
 90  		, l_data_scale
 91  	     FROM user_tab_columns
 92  	    WHERE table_name  = UPPER(p_table)
 93  	      AND column_name = UPPER(p_column)
 94  	   ;
 95  	   IF l_data_type = 'NUMBER'
 96  	   THEN
 97  	     IF l_data_scale != 0
 98  	     THEN
 99  	       -- consider delimiter
100  	       l_return := l_data_precision + l_data_scale;
101  	     ELSE
102  	       l_return := l_data_precision;
103  	     END IF;
104  	   ELSIF l_data_type = 'CLOB'
105  	   THEN
106  	     l_return := 32767;
107  	   ELSE
108  	     l_return := l_data_length;
109  	   END IF;
110  	 END IF;
111  	 RETURN l_return;
112    EXCEPTION
113  	 WHEN OTHERS THEN
114  	   RETURN sosl_sys.ERR_NUM;
115    END get_col_length;
116  
117    FUNCTION get_col_type( p_table  IN VARCHAR2
118  			    , p_column IN VARCHAR2
119  			    )
120  	 RETURN VARCHAR2
121    IS
122  	 l_return      VARCHAR2(128);
123  	 l_has_column  INTEGER;
124  	 l_data_type   user_tab_columns.data_type%TYPE;
125    BEGIN
126  	 l_return := sosl_sys.NA_TYPE;
127  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
128  	 IF l_has_column = 1
129  	 THEN
130  	   -- column match get data type
131  	   SELECT data_type
132  	     INTO l_return
133  	     FROM user_tab_columns
134  	    WHERE table_name  = UPPER(p_table)
135  	      AND column_name = UPPER(p_column)
136  	   ;
137  	 END IF;
138  	 RETURN l_return;
139    EXCEPTION
140  	 WHEN OTHERS THEN
141  	   RETURN sosl_sys.NA_TYPE;
142    END get_col_type;
143  
144    FUNCTION check_col( p_table  IN VARCHAR2
145  			 , p_column IN VARCHAR2
146  			 , p_value  IN VARCHAR2
147  			 )
148  	 RETURN BOOLEAN
149    IS
150  	 l_return  BOOLEAN;
151    BEGIN
152  	 l_return := FALSE;
153  	 IF sosl_util.get_col_type(p_table, p_column) IN ('VARCHAR2', 'CHAR')
154  	 THEN
155  	   IF NVL(LENGTH(p_value), 0) <= sosl_util.get_col_length(p_table, p_column)
156  	   THEN
157  	     l_return := TRUE;
158  	   END IF;
159  	 END IF;
160  	 RETURN l_return;
161    END check_col; -- VARCHAR2 variant
162  
163    FUNCTION check_col( p_table  IN VARCHAR2
164  			 , p_column IN VARCHAR2
165  			 , p_value  IN NUMBER
166  			 )
167  	 RETURN BOOLEAN
168    IS
169  	 l_return  BOOLEAN;
170  	 l_number  VARCHAR2(128);
171    BEGIN
172  	 l_return := FALSE;
173  	 IF sosl_util.get_col_type(p_table, p_column) = 'NUMBER'
174  	 THEN
175  	   l_number := REGEXP_REPLACE(TO_CHAR(p_value), '[^0-9]', '');
176  	   IF NVL(LENGTH(l_number), 0) <= sosl_util.get_col_length(p_table, p_column)
177  	   THEN
178  	     l_return := TRUE;
179  	   END IF;
180  	 END IF;
181  	 RETURN l_return;
182    END check_col; -- NUMBER variant
183  
184  END;
185  /

Package body created.

SQL> -- SOSL objects with possible references to sosl_log and sosl_sys
SQL> @@../sosl_ddl/tables/sosl_config.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_config
  2    ( config_name	     VARCHAR2(128)					       NOT NULL
  3    , config_value	     VARCHAR2(4000)					       NOT NULL
  4    , config_max_length   NUMBER	     DEFAULT -1 			       NOT NULL
  5    , config_type	     VARCHAR2(6)     DEFAULT 'CHAR'			       NOT NULL
  6    , created	     DATE	     DEFAULT SYSDATE			       NOT NULL
  7    , updated	     DATE	     DEFAULT SYSDATE			       NOT NULL
  8    , created_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
  9    , created_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
 11    , updated_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , config_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_config IS 'Holds the configuration used by SOSL. Will use the alias scfg.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_name IS 'The unique case sensitive name of the SOSL configuration object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_value IS 'The configuration value always as VARCHAR2. Type handling and conversion must be done by the caller.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_type IS 'Defines how the config value has to be interpreted. Currently supports CHAR and NUMBER.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_max_length IS 'Defines a maximum length for CHAR type config values if set to a number > 0. Default is -1, do not not check length.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_description IS 'Optional description of the SOSL config object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- primary key
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_pk
  3    PRIMARY KEY (config_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_type
  3    CHECK (config_type IN ('CHAR', 'NUMBER'))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_max_length
  3    CHECK (config_max_length = -1 OR config_max_length > 0)
  4  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_config_ins_upd_trg
  2    BEFORE INSERT OR UPDATE ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok    BOOLEAN;
  6    l_date  DATE;
  7  BEGIN
  8    -- remove any leading and trailing blanks from config_value
  9    :NEW.config_value   := TRIM(:NEW.config_value);
 10    IF UPDATING
 11    THEN
 12  	 :NEW.created	     := :OLD.created;
 13  	 :NEW.created_by     := :OLD.created_by;
 14  	 :NEW.created_by_os  := :OLD.created_by_os;
 15    ELSE
 16  	 :NEW.created	     := SYSDATE;
 17  	 :NEW.created_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 18  	 :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 19    END IF;
 20    :NEW.updated	   := SYSDATE;
 21    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 22    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 23    -- check max length if defined
 24    IF :NEW.config_type = 'CHAR'
 25    THEN
 26  	 IF :NEW.config_max_length > 0
 27  	 THEN
 28  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 29  	   THEN
 30  	     sosl_log.full_log( p_message => 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value)
 31  			      , p_log_type => sosl_sys.FATAL_TYPE
 32  			      , p_log_category => 'SOSL_CONFIG/sosl_config_ins_upd_trg'
 33  			      , p_caller => 'sosl_config_ins_upd_trg'
 34  			      )
 35  	     ;
 36  	     RAISE_APPLICATION_ERROR(-20000, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 37  	   END IF;
 38  	 END IF;
 39    END IF;
 40    -- check number type
 41    IF :NEW.config_type = 'NUMBER'
 42    THEN
 43  	 l_ok := TRUE;
 44  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 45  	 BEGIN
 46  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 47  	 EXCEPTION
 48  	   WHEN OTHERS THEN
 49  	     l_ok := FALSE;
 50  	 END;
 51  	 IF NOT l_ok
 52  	 THEN
 53  	     sosl_log.full_log( p_message => 'The given config_value "' || :NEW.config_value || '" could not be converted successfully to a number.'
 54  			      , p_log_type => sosl_sys.FATAL_TYPE
 55  			      , p_log_category => 'SOSL_CONFIG/sosl_config_ins_upd_trg'
 56  			      , p_caller => 'sosl_config_ins_upd_trg'
 57  			      )
 58  	     ;
 59  	   RAISE_APPLICATION_ERROR(-20001, 'The given config_value "' || :NEW.config_value || '" could not be converted successfully to a number.');
 60  	 END IF;
 61    END IF;
 62  END;
 63  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_config_del_trg
  2    BEFORE DELETE ON sosl_config
  3    FOR EACH ROW
  4  BEGIN
  5    -- protect system parameters from delete
  6    IF :OLD.config_name IN ( 'SOSL_PATH_CFG'
  7  			      , 'SOSL_PATH_TMP'
  8  			      , 'SOSL_PATH_LOG'
  9  			      , 'SOSL_START_LOG'
 10  			      , 'SOSL_BASE_LOG'
 11  			      , 'SOSL_EXT_LOG'
 12  			      , 'SOSL_EXT_TMP'
 13  			      , 'SOSL_EXT_LOCK'
 14  			      , 'SOSL_EXT_ERROR'
 15  			      , 'SOSL_MAX_PARALLEL'
 16  			      , 'SOSL_RUNMODE'
 17  			      , 'SOSL_DEFAULT_WAIT'
 18  			      , 'SOSL_NOJOB_WAIT'
 19  			      , 'SOSL_PAUSE_WAIT'
 20  			      )
 21    THEN
 22  	 RAISE_APPLICATION_ERROR(-20002, 'The given system config_name "' || :OLD.config_name || '" cannot be deleted.');
 23    END IF;
 24  END;
 25  /

Trigger created.

SQL> -- load default values that can be configured in the database
SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_PATH_CFG', '..\..\sosl_cfg\', 'Relative path with delimiter at path end to configuration files the SOSL server uses. Set by SOSL server. As configuration files contain credentials and secrets the path should be in a safe space with controlled user rights.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_TMP', '..\..\sosl_tmp\', 239, 'Relative path with delimiter at path end to temporary files the SOSL server uses. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_LOG', '..\..\sosl_log\', 239, 'Relative path with delimiter at path end to log files the SOSL server creates. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_START_LOG', 'sosl_server', 'Log filename for start and end of SOSL server CMD. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_BASE_LOG', 'sosl_job_', 'Base log filename for single job runs. Will be extended by GUID. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOG', 'log', 'Log file extension to use. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_TMP', 'tmp', 'Log file extension for temporary logs to use. On error those file extension will be renamed to SOSL_EXT_ERROR extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOCK', 'lock', 'Default process lock file extension. Lock files will always get deleted either on service start or after a run. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_ERROR', 'err', 'Default process error file extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAX_PARALLEL', '8', 'NUMBER', 'The maximum of parallel started scripts. Read by the SOSL server. After this amount if scripts is started, next scripts are only loaded, if the run count is below this value.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_RUNMODE', 'RUN', 'CHAR', 'Determines if the server should RUN, WAIT or STOP. Read by the SOSL server. RUN will cause the SOSL server, if started to run as long as it does not get a STOP signal from the database. Set it to STOP to stop the SOSL server. Set to WAIT if the server should not call any script apart the check for the run mode. Can be locally overwritten.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_DEFAULT_WAIT', '1', 'NUMBER', 'Determines the normal sleep time in seconds the sosl server has between calls if scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_NOJOB_WAIT', '120', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if no scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_PAUSE_WAIT', '3600', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if run mode is set to wait.')
  5  ;

1 row created.

SQL> COMMIT;

Commit complete.

SQL> @@../sosl_ddl/tables/sosl_executor.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE TABLE sosl_executor
  2    ( executor_id	       NUMBER(38, 0)   GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , executor_name	       VARCHAR2(256)						 NOT NULL
  4    , db_user	       VARCHAR2(128)						 NOT NULL
  5    , function_owner        VARCHAR2(128)						 NOT NULL
  6    , fn_has_scripts        VARCHAR2(520)						 NOT NULL
  7    , fn_get_next_script    VARCHAR2(520)						 NOT NULL
  8    , fn_set_script_status  VARCHAR2(520)						 NOT NULL
  9    , cfg_file	       VARCHAR2(4000)						 NOT NULL
 10    , use_mail	       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 11    , mail_sender	       VARCHAR2(1024)  DEFAULT 'n/a'				 NOT NULL
 12    , mail_recipients       VARCHAR2(1024)  DEFAULT 'n/a'				 NOT NULL
 13    , fn_send_db_mail       VARCHAR2(520)   DEFAULT 'sosl_log.dummy_mail'		 NOT NULL
 14    , executor_active       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 15    , executor_reviewed     NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 16    , created	       DATE	       DEFAULT SYSDATE				 NOT NULL
 17    , updated	       DATE	       DEFAULT SYSDATE				 NOT NULL
 18    , created_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 19    , created_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 20    , updated_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 21    , updated_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 22    , script_schema	       VARCHAR2(128)   DEFAULT NULL
 23    , executor_description  VARCHAR2(4000)
 24    )
 25  ;

Table created.

SQL> COMMENT ON TABLE sosl_executor IS 'Defines the executors registered with SOSL. To improve security you may activate AUDIT on this table. Will use the alias sexe.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_id IS 'The generated unique id that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_name IS 'The unique name that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.db_user IS 'The login name of the database user must match cfg_file login and be USER after login. No mixed case support, converted to upper case. Must exist and have the necessary rights to execute the queued scripts. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.function_owner IS 'The owner user name of the API functions, refers to the schema where the functions are defined. No mixed case support, converted to upper case. Can differ from the database user that executes SOSL. All API functions must have the same owner for one executor. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_has_scripts IS 'The name of the function to use by HAS_SCRIPTS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the amount of waiting scripts as NUMBER or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_get_next_script IS 'The name of the function to use by GET_NEXT_SCRIPT wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the script id, executor id and script file name as type SOSL_PAYLOAD. It should manage the given script id to ensure that scripts are not run twice.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_set_script_status IS 'The name of the function to use by SET_SCRIPT_STATUS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameters P_REFERENCE IN SOSL_PAYLOAD, P_STATUS IN VARCHAR2 and return 0 or -1 on errors. P_REFERENCE is an object retrieved from GET_NEXT_ID. P_STATUS will always start with the following key words: PREPARING, ENQUEUED, RUNNING, SUCCESS, ERROR. It may contain additional informations in case of errors separated by at least one space char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_send_db_mail IS 'The name of the function to use by SEND_DB_MAIL wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameters P_SENDER IN VARCHAR2, P_RECIPIENTS IN VARCHAR2, P_SUBJECT IN VARCHAR2, P_MESSAGE IN VARCHAR2 and return 0 or -1 on errors. P_SENDER is the email address of the sender. P_RECIPIENTS contains the email addresses of the recipients, delimited by semicolon ";". P_SUBJECT is the email subject to use. P_MESSAGE contains the email message. The default logs to SOSL_SERVER_LOG instead of sending a mail. Can be used to test mail formatting.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.cfg_file IS 'The filename with absolute or relative path to the login config file for this executor. File and path must exist on the CMD server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_active IS 'Defines if the executor is active. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_reviewed IS 'Defines if the executor is reviewed, accepted and ready to be used. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.script_schema IS 'The (optional) schema the script should run in. If set will cause an ALTER SESSION SET CURRENT_SCHEMA before executing the script otherwise db user schema is used. DB user must have rights for this schema if set. If acting on own schema or scripts do ALTER SESSION by themselves, you should leave it NULL.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_description IS 'Optional executor description.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_pk
  3    PRIMARY KEY (executor_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- unique constraint
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_uk
  3    UNIQUE (executor_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- check constraints
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_use_mail
  3    CHECK (use_mail IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_active
  3    CHECK (executor_active IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_reviewed
  3    CHECK (executor_reviewed IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_executor_ins_trg
  2    BEFORE INSERT ON sosl_executor
  3    FOR EACH ROW
  4  DECLARE
  5    l_caller    VARCHAR2(256) := 'sosl_executor_ins_trg';
  6    l_category  VARCHAR2(256) := 'SOSL_EXECUTOR';
  7  BEGIN
  8    :NEW.created	       := SYSDATE;
  9    :NEW.created_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.created_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 11    :NEW.updated	       := SYSDATE;
 12    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 13    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 14    :NEW.executor_active    := 0;
 15    :NEW.executor_reviewed  := 0;
 16    -- transform users and functions to UPPERCASE, no support currently for special mix-case.
 17    :NEW.function_owner	 := UPPER(:NEW.function_owner);
 18    :NEW.db_user		 := UPPER(:NEW.db_user);
 19    :NEW.fn_has_scripts	 := UPPER(:NEW.fn_has_scripts);
 20    :NEW.fn_get_next_script	 := UPPER(:NEW.fn_get_next_script);
 21    :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 22    :NEW.fn_send_db_mail	 := UPPER(:NEW.fn_send_db_mail);
 23    -- check user
 24    IF NOT sosl_util.has_db_user(:NEW.db_user)
 25    THEN
 26  	 sosl_log.full_log( p_message => 'The given database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 27  			  , p_log_type => sosl_sys.FATAL_TYPE
 28  			  , p_log_category => l_category
 29  			  , p_caller => l_caller
 30  			  )
 31  	 ;
 32  	 RAISE_APPLICATION_ERROR(-20003, 'The given database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 33    END IF;
 34    IF NOT sosl_util.has_db_user(:NEW.function_owner)
 35    THEN
 36  	 sosl_log.full_log( p_message => 'The given function owner database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 37  			  , p_log_type => sosl_sys.FATAL_TYPE
 38  			  , p_log_category => l_category
 39  			  , p_caller => l_caller
 40  			  )
 41  	 ;
 42  	 RAISE_APPLICATION_ERROR(-20003, 'The given function owner database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 43    END IF;
 44    -- check configured functions
 45    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 46    THEN
 47  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_has_scripts || ' for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 48  			  , p_log_type => sosl_sys.FATAL_TYPE
 49  			  , p_log_category => l_category
 50  			  , p_caller => l_caller
 51  			  , p_full_message => 'Call sosl_sys.has_function(' || :NEW.function_owner || ',' || :NEW.fn_has_scripts || ')'
 52  			  )
 53  	 ;
 54  	 RAISE_APPLICATION_ERROR(-20004, 'The given function ' || :NEW.fn_has_scripts || ' for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 55    END IF;
 56    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'OBJECT')
 57    THEN
 58  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_next_script || ' for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to SOSL.'
 59  			  , p_log_type => sosl_sys.FATAL_TYPE
 60  			  , p_log_category => l_category
 61  			  , p_caller => l_caller
 62  			  )
 63  	 ;
 64  	 RAISE_APPLICATION_ERROR(-20005, 'The given function ' || :NEW.fn_get_next_script || ' for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to SOSL.');
 65    END IF;
 66    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
 67    THEN
 68  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_set_script_status || ' for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 69  			  , p_log_type => sosl_sys.FATAL_TYPE
 70  			  , p_log_category => l_category
 71  			  , p_caller => l_caller
 72  			  )
 73  	 ;
 74  	 RAISE_APPLICATION_ERROR(-20008, 'The given function ' || :NEW.fn_set_script_status || ' for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 75    END IF;
 76    IF     :NEW.use_mail = 1
 77  	  AND NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
 78    THEN
 79  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_send_db_mail || ' for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 80  			  , p_log_type => sosl_sys.FATAL_TYPE
 81  			  , p_log_category => l_category
 82  			  , p_caller => l_caller
 83  			  )
 84  	 ;
 85  	 RAISE_APPLICATION_ERROR(-20009, 'The given function ' || :NEW.fn_send_db_mail || ' for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 86    END IF;
 87    -- log the insert
 88    sosl_log.full_log( p_message => 'A new executor has been defined for DB user: ' || :NEW.db_user || ' with function owner: ' || :NEW.function_owner || ' created by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 89  			, p_log_type => sosl_sys.INFO_TYPE
 90  			, p_log_category => l_category
 91  			, p_caller => l_caller
 92  			)
 93    ;
 94  EXCEPTION
 95    WHEN OTHERS THEN
 96  	 -- catch and log all undefined exceptions
 97  	 IF SQLCODE NOT IN (-20003, -20004, -20005, -20006, -20007, -20008, -20009)
 98  	 THEN
 99  	   sosl_log.full_log( p_message => 'Unhandled exception in trigger sosl_executor_ins_trg: ' || SQLERRM
100  			    , p_log_type => sosl_sys.FATAL_TYPE
101  			    , p_log_category => l_category
102  			    , p_caller => l_caller
103  			    )
104  	   ;
105  	 END IF;
106  	 -- raise all errors
107  	 RAISE;
108  END;
109  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_executor_upd_trg
  2    BEFORE UPDATE ON sosl_executor
  3    FOR EACH ROW
  4  DECLARE
  5    l_change_record VARCHAR2(32767);
  6    l_caller        VARCHAR2(256) := 'sosl_executor_upd_trg';
  7    l_category      VARCHAR2(256) := 'SOSL_EXECUTOR';
  8  BEGIN
  9    l_change_record := 'Changes by OS user ' || SYS_CONTEXT('USERENV', 'OS_USER') || ': ';
 10    :NEW.updated	       := SYSDATE;
 11    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 12    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 13    -- no overwrite for this values
 14    IF :NEW.created != :OLD.created
 15    THEN
 16  	 l_change_record := l_change_record || 'Prohibited change of create date to: "' || TO_CHAR(:NEW.created, 'YYYY-MM-DD HH24:MI:SS') || '" ';
 17  	 :NEW.created		 := :OLD.created;
 18    END IF;
 19    :NEW.created_by	       := :OLD.created_by;
 20    :NEW.created_by_os      := :OLD.created_by_os;
 21    IF UPPER(:NEW.function_owner) != :OLD.function_owner
 22    THEN
 23  	 l_change_record := l_change_record || 'Prohibited change of function owner to: "' || :NEW.function_owner || '" ';
 24  	 :NEW.function_owner := :OLD.function_owner;
 25    END IF;
 26    IF UPPER(:NEW.db_user) != :OLD.db_user
 27    THEN
 28  	 l_change_record := l_change_record || 'Prohibited change of db user to: "' || :NEW.db_user || '" ';
 29  	 :NEW.db_user := :OLD.db_user;
 30    END IF;
 31    -- prepare possibly modified values
 32    IF :NEW.executor_active != :OLD.executor_active
 33    THEN
 34  	 l_change_record := l_change_record || 'Modified EXECUTOR_ACTIVE: "' || sosl_sys.yes_no(:NEW.executor_active) || '" ';
 35    END IF;
 36    IF :NEW.executor_reviewed != :OLD.executor_reviewed
 37    THEN
 38  	 l_change_record := l_change_record || 'Modified EXECUTOR_REVIEWED: "' || sosl_sys.yes_no(:NEW.executor_reviewed) || '" ';
 39    END IF;
 40    IF UPPER(:NEW.fn_has_scripts) != :OLD.fn_has_scripts
 41    THEN
 42  	 :NEW.fn_has_scripts := UPPER(:NEW.fn_has_scripts);
 43  	 l_change_record := l_change_record || 'Modified fn_has_scripts: "' || :NEW.fn_has_scripts || '" ';
 44    END IF;
 45    IF UPPER(:NEW.fn_get_next_script) != :OLD.fn_get_next_script
 46    THEN
 47  	 :NEW.fn_get_next_script := UPPER(:NEW.fn_get_next_script);
 48  	 l_change_record     := l_change_record || 'Modified fn_get_next_script: "' || :NEW.fn_get_next_script || '" ';
 49    END IF;
 50    IF UPPER(:NEW.fn_set_script_status) != :OLD.fn_set_script_status
 51    THEN
 52  	 :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 53  	 l_change_record       := l_change_record || 'Modified fn_set_script_status: "' || :NEW.fn_set_script_status || '" ';
 54    END IF;
 55    IF UPPER(:NEW.fn_send_db_mail) != :OLD.fn_send_db_mail
 56    THEN
 57  	 :NEW.fn_send_db_mail := UPPER(:NEW.fn_send_db_mail);
 58  	 l_change_record       := l_change_record || 'Modified FN_SEND_DB_MAIL: "' || :NEW.fn_send_db_mail || '" ';
 59    END IF;
 60    -- do all checks again including user
 61    -- check user
 62    IF NOT sosl_util.has_db_user(:NEW.db_user)
 63    THEN
 64  	 sosl_log.full_log( p_message => 'The given database user is not longer visible for SOSL in ALL_USERS. Executor deactivated. Either the user does not exist or SOSL has no right to see this user.'
 65  			  , p_log_type => sosl_sys.FATAL_TYPE
 66  			  , p_log_category => l_category
 67  			  , p_caller => l_caller
 68  			  )
 69  	 ;
 70  	 :NEW.executor_active := 0;
 71    END IF;
 72    IF NOT sosl_util.has_db_user(:NEW.function_owner)
 73    THEN
 74  	 sosl_log.full_log( p_message => 'The given function owner database user is not longer visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 75  			  , p_log_type => sosl_sys.FATAL_TYPE
 76  			  , p_log_category => l_category
 77  			  , p_caller => l_caller
 78  			  )
 79  	 ;
 80  	 :NEW.executor_active := 0;
 81    END IF;
 82    -- check configured functions
 83    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 84    THEN
 85  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_has_scripts || ' for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 86  			  , p_log_type => sosl_sys.FATAL_TYPE
 87  			  , p_log_category => l_category
 88  			  , p_caller => l_caller
 89  			  )
 90  	 ;
 91  	 RAISE_APPLICATION_ERROR(-20004, 'The given function ' || :NEW.fn_has_scripts || ' for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 92    END IF;
 93    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'SOSL_PAYLOAD')
 94    THEN
 95  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_next_script || ' for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype SOSL_PAYLOAD or is not granted with EXECUTE rights to SOSL.'
 96  			  , p_log_type => sosl_sys.FATAL_TYPE
 97  			  , p_log_category => l_category
 98  			  , p_caller => l_caller
 99  			  )
100  	 ;
101  	 RAISE_APPLICATION_ERROR(-20005, 'The given function ' || :NEW.fn_get_next_script || ' for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype SOSL_PAYLOAD or is not granted with EXECUTE rights to SOSL.');
102    END IF;
103    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
104    THEN
105  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_set_script_status || ' for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
106  			  , p_log_type => sosl_sys.FATAL_TYPE
107  			  , p_log_category => l_category
108  			  , p_caller => l_caller
109  			  )
110  	 ;
111  	 RAISE_APPLICATION_ERROR(-20008, 'The given function ' || :NEW.fn_set_script_status || ' for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
112    END IF;
113    IF     :NEW.use_mail = 1
114  	  AND NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
115    THEN
116  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_send_db_mail || ' for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
117  			  , p_log_type => sosl_sys.FATAL_TYPE
118  			  , p_log_category => l_category
119  			  , p_caller => l_caller
120  			  )
121  	 ;
122  	 RAISE_APPLICATION_ERROR(-20009, 'The given function ' || :NEW.fn_send_db_mail || ' for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
123    END IF;
124    -- log the insert
125    sosl_log.full_log( p_message => 'The configuration for executor ID: ' || :OLD.executor_id || ' has been updated by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER') || ' see full_message for details.'
126  			, p_log_type => sosl_sys.INFO_TYPE
127  			, p_log_category => l_category
128  			, p_caller => l_caller
129  			, p_full_message => TO_CLOB(l_change_record)
130  			)
131    ;
132  EXCEPTION
133    WHEN OTHERS THEN
134  	 -- catch and log all undefined exceptions
135  	 IF SQLCODE NOT IN (-20004, -20005, -20006, -20007, -20008, -20009)
136  	 THEN
137  	   sosl_log.full_log( p_message => 'Unhandled exception in trigger sosl_executor_upd_trg: ' || SQLERRM
138  			    , p_log_type => sosl_sys.FATAL_TYPE
139  			    , p_log_category => l_category
140  			    , p_caller => l_caller
141  			    )
142  	   ;
143  	 END IF;
144  	 -- raise all errors
145  	 RAISE;
146  END;
147  /

Trigger created.

SQL> -- internal objects using the API
SQL> @@../sosl_ddl/tables/sosl_script.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_script
  2    ( script_id	     NUMBER(38, 0)  GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , script_name	     VARCHAR2(2000)					      NOT NULL
  4    , script_order	     NUMBER(38, 0)  DEFAULT 1				      NOT NULL
  5    , run_state	     NUMBER(1, 0)   DEFAULT 0				      NOT NULL
  6    , created	     DATE	    DEFAULT SYSDATE			      NOT NULL
  7    , updated	     DATE	    DEFAULT SYSDATE			      NOT NULL
  8    , created_by	     VARCHAR2(256)  DEFAULT USER			      NOT NULL
  9    , created_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	     VARCHAR2(256)  DEFAULT USER			      NOT NULL
 11    , updated_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , executor_id	     NUMBER(38, 0)
 13    , script_description  VARCHAR2(4000)
 14    )
 15  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_script IS 'Holds the script file names that should be executed by SOSL. Will use the alias scrt.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_id IS 'The generated unique id of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.executor_id IS 'The related executor id of the script file. If defined, must match an existing executor. If not defined, script is ignored.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_name IS 'The name of the script file including full or relative path. Use relative path (relative to batch_base_path or repository location) to ensure running scripts from different machines.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_order IS 'The order in which the script file should be executed. Same number means in parallel. Higher order numbers wait for scripts with lower order numbers to complete. Must be greater than 0.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_description IS 'Optional description of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_script
  2    ADD CONSTRAINT sosl_script_pk
  3    PRIMARY KEY (script_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- foreign key
SQL> ALTER TABLE sosl_script
  2    ADD CONSTRAINT sosl_script_fk
  3    FOREIGN KEY (executor_id)
  4    REFERENCES sosl_executor (executor_id)
  5    ON DELETE SET NULL
  6    ENABLE
  7  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_script_ins_trg
  2    BEFORE INSERT ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := SYSDATE;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_script_upd_trg
  2    BEFORE UPDATE ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    :NEW.updated	   := SYSDATE;
 10    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12  END;
 13  /

Trigger created.

SQL> -- packages depending on SOSL objects
SQL> @@../sosl_ddl/packages/sosl.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- main package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl
  2  AS
  3    /**
  4    * This package contains the main functions and procedures used by the Simple Oracle Script Loader to handle executors and scripts.
  5    * It is not allowed to use this package for function assignments in SOSL_EXECUTOR.
  6    */
  7  
  8    /* FUNCTION SOSL.HAS_SCRIPTS
  9    * This function will be used by the wrapper function HAS_SCRIPTS.
 10    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
 11    * return a number greater 0 as well as messages waiting in the queue to be processed. Errors will get logged.
 12    *
 13    * @return The amount of scripts waiting for all valid executor has_ids functions and waiting queue messages or -1 on unhandled exceptions or if all functions have errors.
 14    */
 15    FUNCTION has_scripts
 16  	 RETURN NUMBER
 17    ;
 18  
 19    /* FUNCTION SOSL.HAS_SCRIPTS
 20    * Gets any waiting scripts for a defined active and reviewed executor has_scripts function or for a given queue table name.
 21    * Will return 0 if the executor/queue does not exist or is not active and reviewed. Will return -1 on exceptions caused by this
 22    * function or the defined function. Errors will get logged.
 23    *
 24    * @param p_identifier The executor id or queue table name to get waiting script count.
 25    *
 26    * @return The amount of scripts waiting for processing or -1 on errors.
 27    */
 28    FUNCTION has_scripts(p_identifier IN NUMBER)
 29  	 RETURN NUMBER
 30    ;
 31    FUNCTION has_scripts(p_identifier IN VARCHAR2)
 32  	 RETURN NUMBER
 33    ;
 34  
 35    /* FUNCTION SOSL.HAS_SCRIPTS_FOR_FN
 36    * Checks only by function, to avoid duplicate counts, if different executors share the same function and are both active.
 37    *
 38    * @param p_fn_has_scripts The defined function call for HAS_SCRIPTS.
 39    *
 40    * @return The amount of scripts waiting for processing or -1 on errors.
 41    */
 42    FUNCTION has_scripts_for_fn(p_fn_has_scripts IN VARCHAR2)
 43  	 RETURN NUMBER
 44    ;
 45  
 46    /* FUNCTION SOSL.GET_NEXT_SCRIPT
 47    * This function will be used by the wrapper function GET_NEXT_SCRIPT.
 48    * It collects from all executors the next script to execute, queues them in SOSL_SCRIPT_QUEUE and then fetches the first script in the
 49    * message queue as next script to execute. If no scripts are available or on errors, the function will return NULL.
 50    * Errors will be logged.
 51    *
 52    * @return The next script as SOSL_PAYLOAD type, containing the external script id, the executor id and the script filename including relative or full path.
 53    */
 54    FUNCTION get_next_script
 55  	 RETURN SOSL_PAYLOAD
 56    ;
 57  
 58  
 59    /** Function SOSL.SET_CONFIG
 60    * Sets an existing configuration value for a given configuration name.
 61    *
 62    * @return Exit code, either 0 = successful or -1 on error.
 63    */
 64    FUNCTION set_config( p_config_name  IN VARCHAR2
 65  			  , p_config_value IN VARCHAR2
 66  			  )
 67  	 RETURN NUMBER
 68    ;
 69  
 70    /** Function SOSL.GET_CONFIG
 71    * Gets an existing configuration value for a given and existing case sensitive configuration name.
 72    *
 73    * @return The configured value as VARCHAR2 or -1 string on error.
 74    */
 75    FUNCTION get_config(p_config_name IN VARCHAR2)
 76  	 RETURN VARCHAR2
 77    ;
 78  
 79  
 80    /** Function SOSL.BASE_PATH
 81    * Returns the base path to use for the given run id. Used to switch the run base path for scripts
 82    * running from a different directory.
 83    *
 84    * @return The configured full base path or a simple point for current directory if nothing is configured.
 85    */
 86    FUNCTION base_path(p_run_id IN NUMBER)
 87  	 RETURN VARCHAR2
 88    ;
 89  
 90    /** Function SOSL.CFG_PATH
 91    * Returns the relative configuration path to use for the given run id. A sosl_login.cfg file is expected
 92    * at the given location.
 93    *
 94    * @return The configured relative configuration path or the configured default set by the sosl server.
 95    */
 96    FUNCTION cfg_path(p_run_id IN NUMBER)
 97  	 RETURN VARCHAR2
 98    ;
 99  
100    /** Function SOSL.TMP_PATH
101    * Returns the relative temporary path to use for the given run id.
102    *
103    * @return The configured relative temporary path or the configured default set by the sosl server.
104    */
105    FUNCTION tmp_path(p_run_id IN NUMBER)
106  	 RETURN VARCHAR2
107    ;
108  
109    /** Function SOSL.LOG_PATH
110    * Returns the relative log path to use for the given run id.
111    *
112    * @return The configured relative log path or the configured default set by the sosl server.
113    */
114    FUNCTION log_path(p_run_id IN NUMBER)
115  	 RETURN VARCHAR2
116    ;
117  
118  END;
119  /

Package created.

SQL> @@../sosl_ddl/packages/sosl.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl
  2  AS
  3    -- for description see header file
  4    FUNCTION has_scripts
  5  	 RETURN NUMBER
  6    IS
  7  	 l_return      NUMBER;
  8  	 l_success_cnt NUMBER;
  9  	 l_cnt_valid   NUMBER;
 10  	 l_tmp_cnt     NUMBER;
 11  	 l_queue_table VARCHAR2(128)			 := 'SOSL_SCRIPT_QUEUE';
 12  	 l_category    sosl_server_log.log_category%TYPE := 'HAS_SCRIPTS';
 13  	 l_caller      sosl_server_log.caller%TYPE	 := 'sosl.has_scripts queue and executor';
 14  	 CURSOR cur_executors
 15  	 IS
 16  	   SELECT UPPER(fn_has_scripts) AS fn_has_scripts
 17  	     FROM sosl_executor
 18  	    WHERE executor_active	= 1
 19  	      AND executor_reviewed	= 1
 20  	    GROUP BY UPPER(fn_has_scripts)
 21  	 ;
 22    BEGIN
 23  	 l_return      := -1;
 24  	 l_success_cnt := 0;
 25  	 sosl_log.full_log( p_message => 'sosl.has_scripts called'
 26  			  , p_log_type => sosl_sys.INFO_TYPE
 27  			  , p_log_category => l_category
 28  			  , p_caller => l_caller
 29  			  )
 30  	 ;
 31  	 SELECT COUNT(*) INTO l_cnt_valid FROM sosl_executor WHERE executor_active = 1 AND executor_reviewed = 1;
 32  	 IF l_cnt_valid > 0
 33  	 THEN
 34  	   l_return := 0;
 35  	   -- loop through unique defined functions
 36  	   FOR rec IN cur_executors
 37  	   LOOP
 38  	     l_tmp_cnt := sosl.has_scripts_for_fn(rec.fn_has_scripts);
 39  	     IF l_tmp_cnt > 0
 40  	     THEN
 41  	       l_success_cnt := l_success_cnt +1;
 42  	       l_return      := l_return + l_tmp_cnt;
 43  	     END IF;
 44  	   END LOOP;
 45  	   -- now check queue for waiting message, overrule failed functions calls if messages waiting
 46  	   l_tmp_cnt := sosl.has_scripts(l_queue_table);
 47  	   IF l_tmp_cnt > 0
 48  	   THEN
 49  	     l_success_cnt := l_success_cnt +1;
 50  	     l_return	   := l_return + l_tmp_cnt;
 51  	   END IF;
 52  	   -- if not at least one successful executed
 53  	   IF l_success_cnt <= 0
 54  	   THEN
 55  	     sosl_log.full_log( p_message => 'sosl.has_scripts did not find any valid executor has_scripts functions and messages in the queue. Return 0 scripts waiting.'
 56  			      , p_log_type => sosl_sys.ERROR_TYPE
 57  			      , p_log_category => l_category
 58  			      , p_caller => l_caller
 59  			      )
 60  	     ;
 61  	     l_return := 0;
 62  	   END IF;
 63  	 ELSE
 64  	   -- log no valid executors
 65  	   sosl_log.full_log( p_message => 'sosl.has_scripts called without valid executors defined. Return 0 scripts waiting.'
 66  			    , p_log_type => sosl_sys.WARNING_TYPE
 67  			    , p_log_category => l_category
 68  			    , p_caller => l_caller
 69  			    )
 70  	   ;
 71  	   l_return := 0;
 72  	 END IF;
 73  	 RETURN l_return;
 74    EXCEPTION
 75  	 WHEN OTHERS THEN
 76  	   -- log the error instead of RAISE
 77  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl.has_scripts function: ' || SQLERRM
 78  			    , p_log_type => sosl_sys.FATAL_TYPE
 79  			    , p_log_category => l_category
 80  			    , p_caller => l_caller
 81  			    )
 82  	   ;
 83  	   RETURN -1;
 84    END has_scripts;
 85  
 86    FUNCTION has_scripts(p_identifier IN NUMBER)
 87  	 RETURN NUMBER
 88    IS
 89  	 l_has_executor  NUMBER;
 90  	 l_return	 NUMBER;
 91  	 l_fn_call	 sosl_executor.fn_has_scripts%TYPE;
 92  	 l_category	 sosl_server_log.log_category%TYPE   := 'HAS_SCRIPTS';
 93  	 l_caller	 sosl_server_log.caller%TYPE	     := 'sosl.has_scripts executor';
 94    BEGIN
 95  	 l_return := -1;
 96  	 sosl_log.full_log( p_message => 'sosl.has_scripts executer check p_identifier: ' || p_identifier
 97  			  , p_log_type => sosl_sys.INFO_TYPE
 98  			  , p_log_category => l_category
 99  			  , p_caller => l_caller
100  			  )
101  	 ;
102  	 SELECT COUNT(*)
103  	   INTO l_has_executor
104  	   FROM sosl_executor
105  	  WHERE executor_active   = 1
106  	    AND executor_reviewed = 1
107  	 ;
108  	 IF l_has_executor = 0
109  	 THEN
110  	   sosl_log.full_log( p_message => 'The given executor id does not exist or is not active and reviewed: "' || p_identifier || '". Return 0 scripts waiting.'
111  			    , p_log_type => sosl_sys.ERROR_TYPE
112  			    , p_log_category => l_category
113  			    , p_caller => l_caller
114  			    )
115  	   ;
116  	   l_return := 0;
117  	 ELSE
118  	   SELECT fn_has_scripts INTO l_fn_call FROM sosl_executor WHERE executor_id = p_identifier;
119  	   l_return := sosl.has_scripts_for_fn(l_fn_call);
120  	 END IF;
121  	 RETURN l_return;
122    EXCEPTION
123  	 WHEN OTHERS THEN
124  	   -- log the error instead of RAISE
125  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl.has_scripts for executor function: ' || SQLERRM
126  			    , p_log_type => sosl_sys.FATAL_TYPE
127  			    , p_log_category => l_category
128  			    , p_caller => l_caller
129  			    )
130  	   ;
131  	   RETURN -1;
132    END has_scripts;
133  
134    FUNCTION has_scripts(p_identifier IN VARCHAR2)
135  	 RETURN NUMBER
136    IS
137  	 l_has_queue   NUMBER;
138  	 l_return      NUMBER;
139  	 l_category    sosl_server_log.log_category%TYPE := 'HAS_SCRIPTS';
140  	 l_caller      sosl_server_log.caller%TYPE	 := 'sosl.has_scripts queue';
141    BEGIN
142  	 l_return := -1;
143  	 sosl_log.full_log( p_message => 'sosl.has_scripts queue check p_identifier: ' || p_identifier
144  			  , p_log_type => sosl_sys.INFO_TYPE
145  			  , p_log_category => l_category
146  			  , p_caller => l_caller
147  			  )
148  	 ;
149  	 SELECT COUNT(*)
150  	   INTO l_has_queue
151  	   FROM user_objects
152  	  WHERE object_name = UPPER(p_identifier)
153  	    AND object_type = 'TABLE'
154  	 ;
155  	 IF l_has_queue = 0
156  	 THEN
157  	   sosl_log.full_log( p_message => 'The given queue table name does not exist in the current user schema: "' || UPPER(p_identifier) || '". Return 0 scripts waiting.'
158  			    , p_log_type => sosl_sys.ERROR_TYPE
159  			    , p_log_category => l_category
160  			    , p_caller => l_caller
161  			    )
162  	   ;
163  	   l_return := 0;
164  	 ELSE
165  	   BEGIN
166  	     EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_identifier INTO l_return;
167  	   EXCEPTION
168  	     WHEN OTHERS THEN
169  	       sosl_log.full_log( p_message => 'Unhandled exception in sosl.has_scripts for queue function checking queue table: ' || SQLERRM
170  				, p_log_type => sosl_sys.FATAL_TYPE
171  				, p_log_category => l_category
172  				, p_caller => l_caller
173  				)
174  	       ;
175  	       l_return := -1;
176  	   END;
177  	 END IF;
178  	 RETURN l_return;
179    EXCEPTION
180  	 WHEN OTHERS THEN
181  	   -- log the error instead of RAISE
182  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl.has_scripts for queue function: ' || SQLERRM
183  			    , p_log_type => sosl_sys.FATAL_TYPE
184  			    , p_log_category => l_category
185  			    , p_caller => l_caller
186  			    )
187  	   ;
188  	   RETURN -1;
189    END has_scripts;
190  
191    FUNCTION has_scripts_for_fn(p_fn_has_scripts IN VARCHAR2)
192  	 RETURN NUMBER
193    IS
194  	 l_has_function  NUMBER;
195  	 l_return	 NUMBER;
196  	 l_fn_valid	 BOOLEAN;
197  	 l_fn_call	 sosl_executor.fn_has_scripts%TYPE;
198  	 l_category	 sosl_server_log.log_category%TYPE   := 'HAS_SCRIPTS';
199  	 l_caller	 sosl_server_log.caller%TYPE	     := 'sosl.has_scripts_for_fn';
200  	 CURSOR cur_fn_owner(cp_fn_name IN VARCHAR2)
201  	 IS
202  	   SELECT function_owner
203  	     FROM sosl_executor
204  	    WHERE UPPER(fn_has_scripts) = UPPER(cp_fn_name)
205  	      AND executor_active	= 1
206  	      AND executor_reviewed	= 1
207  	    GROUP BY function_owner
208  	 ;
209    BEGIN
210  	 l_return  := -1;
211  	 sosl_log.full_log( p_message => 'sosl.has_scripts_for_fn defined function check p_fn_has_scripts: ' || p_fn_has_scripts
212  			  , p_log_type => sosl_sys.INFO_TYPE
213  			  , p_log_category => l_category
214  			  , p_caller => l_caller
215  			  )
216  	 ;
217  	 SELECT COUNT(*)
218  	   INTO l_has_function
219  	   FROM sosl_executor
220  	  WHERE UPPER(fn_has_scripts) = UPPER(p_fn_has_scripts)
221  	    AND executor_active       = 1
222  	    AND executor_reviewed     = 1
223  	 ;
224  	 IF l_has_function = 0
225  	 THEN
226  	   sosl_log.full_log( p_message => 'The given function name does not have an active and reviewed executor: "' || UPPER(p_fn_has_scripts) || '". Return 0 scripts waiting.'
227  			    , p_log_type => sosl_sys.ERROR_TYPE
228  			    , p_log_category => l_category
229  			    , p_caller => l_caller
230  			    )
231  	   ;
232  	   l_return := 0;
233  	 ELSE
234  	   -- check function owner, to verify function exists
235  	   l_fn_valid := FALSE;
236  	   FOR rec IN cur_fn_owner(p_fn_has_scripts)
237  	   LOOP
238  	     IF sosl_util.has_function(rec.function_owner, UPPER(p_fn_has_scripts), 'NUMBER')
239  	     THEN
240  	       l_fn_valid := TRUE;
241  	       EXIT;
242  	     END IF;
243  	   END LOOP;
244  	   IF l_fn_valid
245  	   THEN
246  	     BEGIN
247  	       EXECUTE IMMEDIATE p_fn_has_scripts INTO l_return;
248  	     EXCEPTION
249  	       WHEN OTHERS THEN
250  		 sosl_log.full_log( p_message => 'Unhandled exception in sosl.has_scripts_for_fn for calling defined function: ' || p_fn_has_scripts || ' Error: ' || SQLERRM
251  				  , p_log_type => sosl_sys.FATAL_TYPE
252  				  , p_log_category => l_category
253  				  , p_caller => l_caller
254  				  )
255  		 ;
256  		 l_return := -1;
257  	     END;
258  	   ELSE
259  	     sosl_log.full_log( p_message => 'The given function ' || p_fn_has_scripts || ' is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL. Return 0 scripts waiting.'
260  			      , p_log_type => sosl_sys.ERROR_TYPE
261  			      , p_log_category => l_category
262  			      , p_caller => l_caller
263  			      )
264  	     ;
265  	     l_return := 0;
266  	   END IF;
267  	 END IF;
268  	 RETURN l_return;
269    EXCEPTION
270  	 WHEN OTHERS THEN
271  	   -- log the error instead of RAISE
272  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl.has_scripts_for_fn function: ' || SQLERRM
273  			    , p_log_type => sosl_sys.FATAL_TYPE
274  			    , p_log_category => l_category
275  			    , p_caller => l_caller
276  			    )
277  	   ;
278  	   RETURN -1;
279    END has_scripts_for_fn;
280  
281    FUNCTION get_next_script
282  	 RETURN SOSL_PAYLOAD
283    IS
284    BEGIN
285  	 RETURN NULL;
286    END get_next_script;
287  
288    FUNCTION set_config( p_config_name  IN VARCHAR2
289  			  , p_config_value IN VARCHAR2
290  			  )
291  	 RETURN NUMBER
292    IS
293    BEGIN
294  	 RETURN NULL;
295    END set_config;
296  
297    FUNCTION get_config(p_config_name IN VARCHAR2)
298  	 RETURN VARCHAR2
299    IS
300    BEGIN
301  	 RETURN NULL;
302    END get_config;
303  
304    FUNCTION base_path(p_run_id IN NUMBER)
305  	 RETURN VARCHAR2
306    IS
307    BEGIN
308  	 RETURN NULL;
309    END base_path;
310  
311    FUNCTION cfg_path(p_run_id IN NUMBER)
312  	 RETURN VARCHAR2
313    IS
314    BEGIN
315  	 RETURN NULL;
316    END cfg_path;
317  
318    FUNCTION tmp_path(p_run_id IN NUMBER)
319  	 RETURN VARCHAR2
320    IS
321    BEGIN
322  	 RETURN NULL;
323    END tmp_path;
324  
325    FUNCTION log_path(p_run_id IN NUMBER)
326  	 RETURN VARCHAR2
327    IS
328    BEGIN
329  	 RETURN NULL;
330    END log_path;
331  
332  END;
333  /

Package body created.

SQL> @@../sosl_ddl/packages/sosl_if.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- interface package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl_if
  2  AS
  3    /**
  4    * This package contains the internal interface to SOSL used by the Simple Oracle Script Loader.
  5    * Can be seen as tutorial and implementation hint for own interfaces.
  6    */
  7  
  8    /** Function SOSL_IF.HAS_SCRIPTS
  9    * Determines if script ids are available to be executed. To be defined in SOSL_EXECUTOR.
 10    *
 11    * @return The number of script ids waiting for execution.
 12    */
 13    FUNCTION has_scripts
 14  	 RETURN NUMBER
 15    ;
 16  
 17    /** Function SOSL_IF.GET_NEXT_SCRIPT
 18    * Returns the next script id to execute. To be defined in SOSL_EXECUTOR.
 19    *
 20    * @return The id of the next script to execute.
 21    */
 22    FUNCTION get_next_script
 23  	 RETURN SOSL_PAYLOAD
 24    ;
 25  
 26    /** Function SOSL_IF.SET_SCRIPT_STATUS
 27    * Sets the status of a script. To be defined in SOSL_EXECUTOR.
 28    *
 29    * @param p_reference The reference to the script to update as SOSL_PAYLOAD containing executor_id, ext_script_id and script_file.
 30    * @param p_status The status for the script to set. Status: 0 WAITING, 1 PREPARING, 2 ENQUEUED, 3 RUNNING, 4 SUCCESS, 5 ERROR.
 31    * @param p_status_msg An optional message related to current status change, like error messages. SOSL will provide the identifier of SOSLERRORLOG in case of errors.
 32    *
 33    * @return 0 on success, -1 on errors.
 34    */
 35    FUNCTION set_script_status( p_reference	 IN SOSL_PAYLOAD
 36  				 , p_status	 IN NUMBER
 37  				 , p_status_msg  IN VARCHAR2 DEFAULT NULL
 38  				 )
 39  	 RETURN NUMBER
 40    ;
 41  
 42    /* FUNCTION SOSL_IF.SEND_MAIL
 43    * This function is mainly used for testing. In the default setting, it will only send the mail message to
 44    * SOSL_SERVER_LOG.
 45    *
 46    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
 47    * @param p_recipients The semicolon separated list of mail recipient addresses.
 48    * @param p_subject A preferablly short subject for the mail.
 49    * @param p_message The correctly formatted mail message.
 50    * @param p_test_mode The default is test mode, set to FALSE if mail should be used.
 51    *
 52    * @return Will return 0 on success or -1 on errors.
 53    */
 54    FUNCTION send_mail( p_sender	 IN VARCHAR2
 55  			 , p_recipients  IN VARCHAR2
 56  			 , p_subject	 IN VARCHAR2
 57  			 , p_message	 IN VARCHAR2
 58  			 , p_test_mode	 IN BOOLEAN  DEFAULT TRUE
 59  			 )
 60  	 RETURN NUMBER
 61    ;
 62  
 63  END;
 64  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_if.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_if
  2  AS
  3    -- see package header for documentation
  4    FUNCTION has_scripts
  5  	 RETURN NUMBER
  6    IS
  7  	 l_return    NUMBER;
  8  	 l_category  sosl_server_log.log_category%TYPE	 := 'HAS_SCRIPTS';
  9  	 l_caller    sosl_server_log.caller%TYPE	 := 'sosl.has_scripts';
 10    BEGIN
 11  	 SELECT COUNT(*)
 12  	   INTO l_return
 13  	   FROM sosl_script
 14  	 ;
 15  	 RETURN -1;
 16    EXCEPTION
 17  	 WHEN OTHERS THEN
 18  	   -- log the error instead of RAISE
 19  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl.has_scripts function: ' || SQLERRM
 20  			    , p_log_type => sosl_sys.FATAL_TYPE
 21  			    , p_log_category => l_category
 22  			    , p_caller => l_caller
 23  			    )
 24  	   ;
 25  	   RETURN -1;
 26    END has_scripts;
 27  
 28    FUNCTION get_next_script
 29  	 RETURN SOSL_PAYLOAD
 30    IS
 31    BEGIN
 32  	 RETURN NULL;
 33    END get_next_script;
 34  
 35    FUNCTION set_script_status( p_reference	 IN SOSL_PAYLOAD
 36  				 , p_status	 IN NUMBER
 37  				 , p_status_msg  IN VARCHAR2 DEFAULT NULL
 38  				 )
 39  	 RETURN NUMBER
 40    IS
 41    BEGIN
 42  	 RETURN -1;
 43    END set_script_status;
 44  
 45    FUNCTION send_mail( p_sender	 IN VARCHAR2
 46  			 , p_recipients  IN VARCHAR2
 47  			 , p_subject	 IN VARCHAR2
 48  			 , p_message	 IN VARCHAR2
 49  			 , p_test_mode	 IN BOOLEAN  DEFAULT TRUE
 50  			 )
 51  	 RETURN NUMBER
 52    IS
 53  	 l_return  NUMBER;
 54    BEGIN
 55  	 RETURN sosl_log.dummy_mail(p_sender, p_recipients, p_subject, p_message);
 56    END send_mail;
 57  
 58  END;
 59  /

Package body created.

SQL> -- wrapper functions
SQL> @@../sosl_ddl/functions/has_scripts.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE FUNCTION has_scripts
  2    RETURN NUMBER
  3  IS
  4    /* Wrapper function for defined executor has_scripts functions.
  5    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
  6    * return a number greater 0. Will log all functions in error.
  7    *
  8    * @return The amount of scripts waiting for all valid executor has_scripts functions or -1 if all functions have errors.
  9    */
 10    l_return    NUMBER;
 11    l_category  sosl_server_log.log_category%TYPE := 'HAS_SCRIPTS';
 12    l_caller    sosl_server_log.caller%TYPE	     := 'has_scripts wrapper';
 13  BEGIN
 14    l_return := sosl.has_scripts;
 15    RETURN l_return;
 16  EXCEPTION
 17    WHEN OTHERS THEN
 18  	 -- log the error instead of RAISE
 19  	 sosl_log.full_log( p_message => 'Unhandled exception in HAS_SCRIPTS wrapper function: ' || SQLERRM
 20  			  , p_log_type => sosl_sys.FATAL_TYPE
 21  			  , p_log_category => l_category
 22  			  , p_caller => l_caller
 23  			  )
 24  	 ;
 25  	 RETURN -1;
 26  END;
 27  /

Function created.

SQL> -- grants, everyone can see if scripts are available, inherited by others
SQL> GRANT EXECUTE ON has_scripts TO sosl_guest;

Grant succeeded.

SQL> -- ==============INSTALL done==============
SQL> @@../sosl_sql/util/log_silent.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> SET ECHO OFF
SUCCESS - no errors found during setup          0
