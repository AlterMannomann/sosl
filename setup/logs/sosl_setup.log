SQL> @@../sosl_ddl/tables/soslerrorlog.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE TABLE soslerrorlog
  2    ( username    VARCHAR2(256)
  3    , timestamp   TIMESTAMP
  4  	 -- older versions than Oracle 23 use VARCHAR2(1024)
  5    , script      CLOB	   -- VARCHAR2(1024)
  6    , identifier  VARCHAR2(256)
  7    , message     CLOB
  8    , statement   CLOB
  9    )
 10  ;

Table created.

SQL> COMMENT ON TABLE soslerrorlog IS 'Userdefined table for SQLPlus error logging';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.username IS 'Oracle account name';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.timestamp IS 'Time when the error occurred';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.script IS 'Name of the originating script if applicable';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.identifier IS 'User defined identifier string';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.message IS 'ORA, PLA or SP2 error message. No feed back messages are included. For example, "PL/SQL Block Created" is not recorded.';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.statement IS 'The statement causing the error';

Comment created.

SQL> -- package with no dependency on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_sys.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Basic sys util package not using data objects of the Simple Oracle Script Loader, no dependencies.
SQL> CREATE OR REPLACE PACKAGE sosl_sys
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader that have no dependencies on any SOSL object.
  5    * As there are no dependencies, exceptions must be catched or handled by the caller. No logging for this functions and procedures.
  6    */
  7  
  8    /*====================================== start package constants used by SOSL ======================================*/
  9    -- define log_type constants used in SOSL_SERVER_LOG
 10    ERROR_TYPE     CONSTANT CHAR(5) := 'ERROR';
 11    WARNING_TYPE   CONSTANT CHAR(7) := 'WARNING';
 12    FATAL_TYPE     CONSTANT CHAR(5) := 'FATAL';
 13    INFO_TYPE      CONSTANT CHAR(4) := 'INFO';
 14    SUCCESS_TYPE   CONSTANT CHAR(7) := 'SUCCESS';
 15    -- Generic n/a type. Should be different from table defaults like 'not set' as table triggers interpret their DDL default value as fallback
 16    -- to set default values using package variables, which is not supported in table DDL by Oracle using DEFAULT. Packages may use variables
 17    -- from other packages in DEFAULT declarations.
 18    NA_TYPE	      CONSTANT CHAR(3) := 'n/a';
 19    /*====================================== end package constants used by SOSL ======================================*/
 20  
 21    /*====================================== start internal functions made visible for testing ======================================*/
 22    /* PROCEDURE SOSL_SYS.SPLIT_FUNCTION_NAME
 23    * Splits the given function name into its parts. Supposed delimiter is the point ".".
 24    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 25    * @param p_package OUT parameter, contains the package name if any or NULL.
 26    * @param p_function OUT parameter, contains the pure function name.
 27    */
 28    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
 29  				    , p_package       OUT VARCHAR2
 30  				    , p_function      OUT VARCHAR2
 31  				    )
 32    ;
 33    /*====================================== end internal functions made visible for testing ======================================*/
 34  
 35    /* FUNCTION SOSL_SYS.HAS_DB_USER
 36    * Checks if a given user is visible for SOSL by checking ALL_USERS. Users must be visible to SOSL to be able to dynamically
 37    * grant the necessary rights on the API for script execution.
 38    *
 39    * @param p_username The database user name to check.
 40    *
 41    * @return TRUE if the user is visible in ALL_USERS to SOSL, otherwise FALSE.
 42    */
 43    FUNCTION has_db_user(p_username IN VARCHAR2)
 44  	 RETURN BOOLEAN
 45    ;
 46  
 47    /* FUNCTION SOSL_SYS.HAS_FUNCTION
 48    * Checks if a given function or package function name is visible for SOSL by checking ALL_ATTRIBUTES. The package SOSL_API is
 49    * excluded from the search to avoid references in SOSL_EXECUTOR.
 50    *
 51    * @param p_owner The owner of the function or package function name to check.
 52    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 53    * @param p_datatype The return datatype of the function expected, e.g. a valid Oracle datatype like NUMBER or VARCHAR2.
 54    *
 55    * @return TRUE if the function is visible in ALL_ATTRIBUTES to SOSL and has the required return datatype, otherwise FALSE.
 56    */
 57    FUNCTION has_function( p_owner	       IN VARCHAR2
 58  			    , p_function_name  IN VARCHAR2
 59  			    , p_datatype       IN VARCHAR2
 60  			    )
 61  	 RETURN BOOLEAN
 62    ;
 63  
 64    /* FUNCTION SOSL_SYS.LOG_TYPE_VALID
 65    * Central function to check the log type. Currently supports INFO, WARNING, ERROR, FATAL, SUCCESS. If log types should get expanded
 66    * adjust this function first and probably the default value for SOSL_SERVER_LOG.
 67    *
 68    * @param p_log_type The log type to check. Case insensitive.
 69    *
 70    *@return TRUE if the given log type is supported. FALSE if not. Exceptions and errors will lead also to FALSE.
 71    */
 72    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 73  	 RETURN BOOLEAN
 74  	 DETERMINISTIC
 75  	 PARALLEL_ENABLE
 76    ;
 77  
 78    /* FUNCTION SOSL_SYS.GET_VALID_LOG_TYPE
 79    * Verifies an given log type, returns either the given log type as upper case or the defined error default.
 80    *
 81    * @param p_log_type The log type to verify and return. Case insensitive.
 82    * @param p_error_default The alternative log type to return, if the log type is invalid. Must be a valid log type and not INFO or SUCCESS. If invalid, FATAL is returned.
 83    *
 84    * @return The valid log type as upper case on success. The valid error default if log type not supported. FATAL if the error default is invalid.
 85    */
 86    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 87  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_sys.ERROR_TYPE
 88  				  )
 89  	 RETURN VARCHAR2
 90  	 DETERMINISTIC
 91  	 PARALLEL_ENABLE
 92    ;
 93  
 94    /*FUNCTION SOSL_SYS.GET_COL_LENGTH
 95    * Returns the column length for a given table and column or -1 if table or column does not exist from USER_TAB_COLUMNS using
 96    * DATA_LENGTH. DATA_LENGTH is misleading if not a char type or CLOB, as CLOB types report 4000 which is definitely wrong.
 97    * The only types handled are NUMBER and CLOB. All other types return the DATA_LENGTH.
 98    *
 99    * Length for numbers is calculated by adding precision and scale.
100    *
101    * CLOB will return the PLSQL equation of a VARCHAR2/CLOB, which is 32767 and still wrong, but useful to see if a PLSQL can handle
102    * the CLOB. Be careful with CLOB handling. If source is not a table column, PLSQL most likely limits it to 32767 cutting longer content.
103    *
104    * Objects not in the current schema will not be considered and return -1 AS USER_TAB_COLUMN is used.
105    *
106    * No handling for date and timestamp values, as their char representation has too much dependencies on NLS and formatting to get a
107    * reliable length.
108    *
109    * Byte and char semantic is not considered only the effective chars that can be stored in CHAR or VARCHAR2 as defined by DATA_LENGTH.
110    *
111    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
112    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
113    *
114    * @return The calculated length of the column. Fix PLSQL limit 32767 for CLOB types. DATA_LENGTH for data and timestamp types.
115    */
116    FUNCTION get_col_length( p_table  IN VARCHAR2
117  			      , p_column IN VARCHAR2
118  			      )
119  	 RETURN INTEGER
120    ;
121  
122    /* FUNCTION SOSL_SYS.GET_COL_TYPE
123    * Returns the type of a column from USER_TAB_COLUMNS as defined in DATA_TYPE or NA_TYPE if table or column doesn't exist.
124    * Objects not in the current schema will not be considered and return NA_TYPE.
125    *
126    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
127    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
128    *
129    * @return The type of the column as defined in DATA_TYPE or sosl_sys.NA_TYPE on errors or not found columns and tables.
130    */
131    FUNCTION get_col_type( p_table  IN VARCHAR2
132  			    , p_column IN VARCHAR2
133  			    )
134  	 RETURN VARCHAR2
135    ;
136  
137    /* FUNCTION SOSL_SYS.DISTRIBUTE
138    * This functions distributes char data between a VARCHAR2 and a CLOB variable by the following rules:
139    * p_string empty or NULL: Fill p_string to p_max_string_length - p_split_end length.
140    * p_string length > p_max_string_length: Cut p_string to p_max_string_length, including p_split_end appended.
141    *	  p_clob NOT EMPTY: add split_start, rest of p_string before p_clob content.
142    *	  p_clob EMPTY: add split_start and rest of p_string.
143    * p_string length > 0 and < p_max_string_length: no change of p_string and p_clob.
144    * p_string and p_clob empty or NULL: leave unchanged, return FALSE otherwise always TRUE.
145    * In case of exceptions will try to write SQLERRM to p_string as CLOBs tend to be more error prone.
146    *
147    * @param p_string The string to distribute or check. In PLSQL strings can get 32767 chars long, whereas table columns are limited currently to 4000.
148    * @param p_clob The CLOB to distribute or check. Uses NOCOPY to guarantee that CLOB full length is used as given.
149    * @param p_max_string_length The maximum length p_string should have. If this size is exeeded the string gets distribute between p_string and p_clob.
150    * @param p_split_end The split end characters to indicate that the string is continued in p_clob.
151    * @param p_split_start The split start characters for the continuing string in the CLOB.
152    * @param p_delimiter The delimiter between rest of string in CLOB and original CLOB content, if both have content and string must be splitted.
153    *
154    * @return FALSE if p_string and p_clob are empty/NULL or an exception had occurred, otherwise TRUE.
155    */
156    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
157  			  , p_clob		IN OUT NOCOPY  CLOB
158  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
159  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
160  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
161  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
162  			  )
163  	 RETURN BOOLEAN
164    ;
165  
166    /* FUNCTION SOSL_SYS.CHECK_COL
167    * This function can check NUMBER and VARCHAR2/CHAR columns for length and type. Passing a number for a char column type will result
168    * in FALSE. Providing a P_VALUE with a length longer than the length calculated, will result in FALSE. It will not consider
169    * implicite Oracle conversions. Expects type like defined.
170    *
171    * Number length is calculated by TO_CHAR string representation removing all delimiters and counting only numbers 0-9.
172    * Passing a VARCHAR2 value is valid for CHAR and VARCHAR2 column types.
173    *
174    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
175    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
176    * @param p_value The value for the table column to check against column definition.
177    *
178    * @return TRUE if value and column match in type and length, otherwise FALSE.
179    */
180    FUNCTION check_col( p_table  IN VARCHAR2
181  			 , p_column IN VARCHAR2
182  			 , p_value  IN VARCHAR2
183  			 )
184  	 RETURN BOOLEAN
185    ;
186    FUNCTION check_col( p_table  IN VARCHAR2
187  			 , p_column IN VARCHAR2
188  			 , p_value  IN NUMBER
189  			 )
190  	 RETURN BOOLEAN
191    ;
192  
193    /* FUNCTION SOSL_SYS.TXT_BOOLEAN
194    * Provides text values to display instead of BOOLEAN or NUMBER values interpreted as BOOLEAN. Numbers are interpreted
195    * similar to Oracle SQL, where 0 is FALSE and 1 is TRUE. 1 is considered as TRUE, any other value as FALSE. NULL values
196    * are interpreted as sosl_sys.NA_TYPE. Maximum 10 characters for TRUE/FALSE equation.
197    *
198    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
199    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
200    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
201    *
202    * @return The text equation for the given p_bool value.
203    */
204    FUNCTION txt_boolean( p_bool   IN BOOLEAN
205  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
206  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
207  			   )
208  	 RETURN VARCHAR2
209  	 DETERMINISTIC
210  	 PARALLEL_ENABLE
211    ;
212    FUNCTION txt_boolean( p_bool   IN NUMBER
213  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
214  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
215  			   )
216  	 RETURN VARCHAR2
217  	 DETERMINISTIC
218  	 PARALLEL_ENABLE
219    ;
220  
221    /* FUNCTION SOSL_SYS.YES_NO
222    * A simple wrapper for txt_boolean with YES/NO instead of TRUE/FALSE.
223    *
224    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
225    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
226    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
227    *
228    * @return The text equation for the given p_bool value.
229    */
230    FUNCTION yes_no( p_bool	 IN BOOLEAN
231  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
232  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
233  		      )
234  	 RETURN VARCHAR2
235  	 DETERMINISTIC
236  	 PARALLEL_ENABLE
237    ;
238    FUNCTION yes_no( p_bool	 IN NUMBER
239  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
240  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
241  		      )
242  	 RETURN VARCHAR2
243  	 DETERMINISTIC
244  	 PARALLEL_ENABLE
245    ;
246  
247    /* FUNCTION SOSL_SYS.UTC_MAIL_DATE
248    * Returns the current date timestamp as a formatted string for date values in mail.
249    *
250    * @return A date string conform to RFC5322 for using mail.
251    *
252    * @see https://datatracker.ietf.org/doc/html/rfc5322
253    */
254    FUNCTION utc_mail_date
255  	 RETURN VARCHAR2
256    ;
257  
258    /* FUNCTION SOSL_SYS.FORMAT_MAIL
259    * This function formats a mail message conforming to RFC5322. The content of p_message is not checked against RFC. This is
260    * the repsonsibility of the user. This is for small messages that do not exceed 32k in total.
261    *
262    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
263    * @param p_recipients The semicolon separated list of mail recipient addresses.
264    * @param p_subject A preferablly short subject for the mail.
265    * @param p_message The correctly formatted mail message.
266    *
267    * @return A formatted string with complete mail message that can be used with RFC compliant mail servers.
268    */
269    FUNCTION format_mail( p_sender	   IN VARCHAR2
270  			   , p_recipients  IN VARCHAR2
271  			   , p_subject	   IN VARCHAR2
272  			   , p_message	   IN VARCHAR2
273  			   )
274  	 RETURN VARCHAR2
275    ;
276  
277  END;
278  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_sys.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE PACKAGE BODY sosl_sys
  2  AS
  3    -- for description see header file
  4    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
  5  				    , p_package       OUT VARCHAR2
  6  				    , p_function      OUT VARCHAR2
  7  				    )
  8    IS
  9    BEGIN
 10  	 IF INSTR(p_function_name, '.') > 0
 11  	 THEN
 12  	   p_package   := TRIM(SUBSTR(p_function_name, 1, INSTR(p_function_name, '.') -1));
 13  	   p_function  := TRIM(SUBSTR(p_function_name, INSTR(p_function_name, '.') +1));
 14  	 ELSE
 15  	   p_package   := NULL;
 16  	   p_function  := TRIM(p_function_name);
 17  	 END IF;
 18    END split_function_name;
 19  
 20    FUNCTION has_db_user(p_username IN VARCHAR2)
 21  	 RETURN BOOLEAN
 22    IS
 23  	 l_has_user  NUMBER;
 24  	 l_return    BOOLEAN;
 25    BEGIN
 26  	 l_return := FALSE;
 27  	 SELECT COUNT(*) INTO l_has_user FROM all_users WHERE username = p_username;
 28  	 IF l_has_user != 0
 29  	 THEN
 30  	   l_return := TRUE;
 31  	 END IF;
 32  	 RETURN l_return;
 33    END has_db_user;
 34  
 35    FUNCTION has_function( p_owner	       IN VARCHAR2
 36  			    , p_function_name  IN VARCHAR2
 37  			    , p_datatype       IN VARCHAR2
 38  			    )
 39  	 RETURN BOOLEAN
 40    IS
 41  	 l_has_function  NUMBER;
 42  	 l_package	 VARCHAR2(128);
 43  	 l_function	 VARCHAR2(128);
 44  	 l_return	 BOOLEAN;
 45    BEGIN
 46  	 l_return := FALSE;
 47  	 sosl_sys.split_function_name(p_function_name, l_package, l_function);
 48  	 SELECT COUNT(*)
 49  	   INTO l_has_function
 50  	   FROM all_arguments
 51  	  WHERE position		   = 0				     -- only functions
 52  	    AND argument_name		   IS NULL			     -- only functions
 53  	    AND data_type		   = p_datatype
 54  	    AND owner			   = UPPER(p_owner)
 55  	    AND NVL(package_name, 'N/A')   = NVL(UPPER(l_package), 'N/A')    -- may not contain a package name
 56  	    AND object_name		   = UPPER(l_function)
 57  	    AND package_name		  != 'SOSL_API' 		     -- exclude API package should never be referenced
 58  	 ;
 59  	 IF l_has_function != 0
 60  	 THEN
 61  	   l_return := TRUE;
 62  	 END IF;
 63  	 RETURN l_return;
 64    END has_function;
 65  
 66    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 67  	 RETURN BOOLEAN
 68  	 DETERMINISTIC
 69  	 PARALLEL_ENABLE
 70    IS
 71  	 l_return  BOOLEAN;
 72    BEGIN
 73  	 l_return := FALSE;
 74  	 IF UPPER(p_log_type) IN ( sosl_sys.INFO_TYPE
 75  				 , sosl_sys.WARNING_TYPE
 76  				 , sosl_sys.ERROR_TYPE
 77  				 , sosl_sys.FATAL_TYPE
 78  				 , sosl_sys.SUCCESS_TYPE
 79  				 )
 80  	 THEN
 81  	   l_return := TRUE;
 82  	 END IF;
 83  	 RETURN l_return;
 84    EXCEPTION
 85  	 WHEN OTHERS THEN
 86  	   RETURN FALSE;
 87    END log_type_valid;
 88  
 89    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 90  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_sys.ERROR_TYPE
 91  				  )
 92  	 RETURN VARCHAR2
 93  	 DETERMINISTIC
 94  	 PARALLEL_ENABLE
 95    IS
 96  	 l_return  VARCHAR2(30);
 97    BEGIN
 98  	 l_return := sosl_sys.FATAL_TYPE;
 99  	 IF log_type_valid(p_log_type)
100  	 THEN
101  	   l_return := UPPER(p_log_type);
102  	 ELSE
103  	   IF	   log_type_valid(p_error_default)
104  	      AND  UPPER(p_error_default) NOT IN ( sosl_sys.INFO_TYPE
105  						 , sosl_sys.SUCCESS_TYPE
106  						 )
107  	   THEN
108  	     l_return := UPPER(p_error_default);
109  	   END IF;
110  	 END IF;
111  	 RETURN l_return;
112    EXCEPTION
113  	 WHEN OTHERS THEN
114  	   RETURN sosl_sys.FATAL_TYPE;
115    END get_valid_log_type;
116  
117    FUNCTION get_col_length( p_table  IN VARCHAR2
118  			      , p_column IN VARCHAR2
119  			      )
120  	 RETURN INTEGER
121    IS
122  	 l_return	   INTEGER;
123  	 l_has_column	   INTEGER;
124  	 l_data_type	   user_tab_columns.data_type%TYPE;
125  	 l_data_length	   user_tab_columns.data_length%TYPE;
126  	 l_data_precision  user_tab_columns.data_precision%TYPE;
127  	 l_data_scale	   user_tab_columns.data_scale%TYPE;
128    BEGIN
129  	 l_return := -1;
130  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
131  	 IF l_has_column = 1
132  	 THEN
133  	   -- column match calculate length
134  	   SELECT data_type
135  		, data_length
136  		, data_precision
137  		, data_scale
138  	     INTO l_data_type
139  		, l_data_length
140  		, l_data_precision
141  		, l_data_scale
142  	     FROM user_tab_columns
143  	    WHERE table_name  = UPPER(p_table)
144  	      AND column_name = UPPER(p_column)
145  	   ;
146  	   IF l_data_type = 'NUMBER'
147  	   THEN
148  	     IF l_data_scale != 0
149  	     THEN
150  	       -- consider delimiter
151  	       l_return := l_data_precision + l_data_scale;
152  	     ELSE
153  	       l_return := l_data_precision;
154  	     END IF;
155  	   ELSIF l_data_type = 'CLOB'
156  	   THEN
157  	     l_return := 32767;
158  	   ELSE
159  	     l_return := l_data_length;
160  	   END IF;
161  	 END IF;
162  	 RETURN l_return;
163    EXCEPTION
164  	 WHEN OTHERS THEN
165  	   RETURN -1;
166    END get_col_length;
167  
168    FUNCTION get_col_type( p_table  IN VARCHAR2
169  			    , p_column IN VARCHAR2
170  			    )
171  	 RETURN VARCHAR2
172    IS
173  	 l_return      VARCHAR2(128);
174  	 l_has_column  INTEGER;
175  	 l_data_type   user_tab_columns.data_type%TYPE;
176    BEGIN
177  	 l_return := sosl_sys.NA_TYPE;
178  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
179  	 IF l_has_column = 1
180  	 THEN
181  	   -- column match get data type
182  	   SELECT data_type
183  	     INTO l_return
184  	     FROM user_tab_columns
185  	    WHERE table_name  = UPPER(p_table)
186  	      AND column_name = UPPER(p_column)
187  	   ;
188  	 END IF;
189  	 RETURN l_return;
190    EXCEPTION
191  	 WHEN OTHERS THEN
192  	   RETURN sosl_sys.NA_TYPE;
193    END get_col_type;
194  
195    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
196  			  , p_clob		IN OUT NOCOPY  CLOB
197  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
198  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
199  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
200  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
201  			  )
202  	 RETURN BOOLEAN
203    IS
204  	 l_string  VARCHAR2(32767);
205    BEGIN
206  	 IF	(p_string IS NULL OR NVL(LENGTH(TRIM(p_string)), 0) = 0)
207  	    AND (p_clob   IS NULL OR NVL(LENGTH(TRIM(p_clob)), 0) = 0)
208  	 THEN
209  	   RETURN FALSE;
210  	 END IF;
211  	 IF	p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
212  	    AND p_clob	 IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
213  	 THEN
214  	   IF LENGTH(p_string) > p_max_string_length
215  	   THEN
216  	     -- need to split
217  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1)) || p_delimiter;
218  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
219  	     p_clob   := l_string || p_clob;
220  	   END IF;
221  	   RETURN TRUE;
222  	 END IF;
223  	 IF p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
224  	 THEN
225  	   IF LENGTH(p_string) > p_max_string_length
226  	   THEN
227  	     -- need to split
228  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1));
229  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
230  	     p_clob   := TO_CLOB(l_string);
231  	   ELSE
232  	     p_clob := TO_CLOB(l_string);
233  	   END IF;
234  	   RETURN TRUE;
235  	 END IF;
236  	 IF p_clob IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
237  	 THEN
238  	   IF LENGTH(p_clob) > p_max_string_length
239  	   THEN
240  	     p_string := TO_CHAR(SUBSTR(p_clob, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end);
241  	   ELSE
242  	     p_string := TO_CHAR(p_clob);
243  	   END IF;
244  	   RETURN TRUE;
245  	 END IF;
246  	 -- should not reach this point
247  	 p_string := 'ERROR sosl_sys.distribute: INCOMPLETE LOGIC';
248  	 RETURN FALSE;
249    EXCEPTION
250  	 WHEN OTHERS THEN
251  	   p_string := TRIM(SUBSTR(SQLERRM, 1, 4000));
252  	   RETURN FALSE;
253    END distribute;
254  
255    FUNCTION check_col( p_table  IN VARCHAR2
256  			 , p_column IN VARCHAR2
257  			 , p_value  IN VARCHAR2
258  			 )
259  	 RETURN BOOLEAN
260    IS
261  	 l_return  BOOLEAN;
262    BEGIN
263  	 l_return := FALSE;
264  	 IF sosl_sys.get_col_type(p_table, p_column) IN ('VARCHAR2', 'CHAR')
265  	 THEN
266  	   IF NVL(LENGTH(p_value), 0) <= sosl_sys.get_col_length(p_table, p_column)
267  	   THEN
268  	     l_return := TRUE;
269  	   END IF;
270  	 END IF;
271  	 RETURN l_return;
272    END check_col; -- VARCHAR2 variant
273  
274    FUNCTION check_col( p_table  IN VARCHAR2
275  			 , p_column IN VARCHAR2
276  			 , p_value  IN NUMBER
277  			 )
278  	 RETURN BOOLEAN
279    IS
280  	 l_return  BOOLEAN;
281  	 l_number  VARCHAR2(128);
282    BEGIN
283  	 l_return := FALSE;
284  	 IF sosl_sys.get_col_type(p_table, p_column) = 'NUMBER'
285  	 THEN
286  	   l_number := REGEXP_REPLACE(TO_CHAR(p_value), '[^0-9]', '');
287  	   IF NVL(LENGTH(l_number), 0) <= sosl_sys.get_col_length(p_table, p_column)
288  	   THEN
289  	     l_return := TRUE;
290  	   END IF;
291  	 END IF;
292  	 RETURN l_return;
293    END check_col; -- NUMBER variant
294  
295    FUNCTION txt_boolean( p_bool   IN BOOLEAN
296  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
297  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
298  			   )
299  	 RETURN VARCHAR2
300  	 DETERMINISTIC
301  	 PARALLEL_ENABLE
302    IS
303    BEGIN
304  	 IF p_bool
305  	 THEN
306  	   RETURN TRIM(SUBSTR(NVL(p_true, 'TRUE'), 1, 10));
307  	 ELSE
308  	   RETURN TRIM(SUBSTR(NVL(p_false, 'FALSE'), 1, 10));
309  	 END IF;
310    END txt_boolean; -- boolean input
311  
312    FUNCTION txt_boolean( p_bool   IN NUMBER
313  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
314  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
315  			   )
316  	 RETURN VARCHAR2
317  	 DETERMINISTIC
318  	 PARALLEL_ENABLE
319    IS
320    BEGIN
321  	 RETURN sosl_sys.txt_boolean((p_bool = 1), p_true, p_false);
322    END txt_boolean; -- number input
323  
324    FUNCTION yes_no( p_bool	 IN BOOLEAN
325  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
326  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
327  		      )
328  	 RETURN VARCHAR2
329  	 DETERMINISTIC
330  	 PARALLEL_ENABLE
331    IS
332    BEGIN
333  	 RETURN sosl_sys.txt_boolean(p_bool, p_true, p_false);
334    END yes_no;
335  
336    FUNCTION yes_no( p_bool	 IN NUMBER
337  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
338  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
339  		      )
340  	 RETURN VARCHAR2
341  	 DETERMINISTIC
342  	 PARALLEL_ENABLE
343    IS
344    BEGIN
345  	 RETURN sosl_sys.txt_boolean((p_bool = 1), p_true, p_false);
346    END yes_no;
347  
348    FUNCTION utc_mail_date
349  	 RETURN VARCHAR2
350    IS
351  	 l_date VARCHAR2(500);
352    BEGIN
353  	 l_date := TO_CHAR(SYSTIMESTAMP AT TIME ZONE SESSIONTIMEZONE, 'Dy, DD Mon YYYY HH24:MI:SS TZHTZM');
354  	 RETURN l_date;
355    END utc_mail_date;
356  
357    FUNCTION format_mail( p_sender	   IN VARCHAR2
358  			   , p_recipients  IN VARCHAR2
359  			   , p_subject	   IN VARCHAR2
360  			   , p_message	   IN VARCHAR2
361  			   )
362  	 RETURN VARCHAR2
363    IS
364  	 l_crlf 	 VARCHAR2(2)	   := CHR(13) || CHR(10);
365  	 l_mail_message  VARCHAR2(32767);
366    BEGIN
367  	 l_mail_message := 'From: ' || p_sender || l_crlf ||
368  			   'To: ' || p_recipients || l_crlf ||
369  			   'Date: ' || sosl_sys.utc_mail_date || l_crlf ||
370  			   'Subject: ' || p_subject || l_crlf ||
371  			   p_message
372  	 ;
373  	 RETURN l_mail_message;
374    END format_mail;
375  
376  END;
377  /

Package body created.

SQL> -- logging table
SQL> @@../sosl_ddl/tables/sosl_server_log.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_server_log
  2    ( exec_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP 		     NOT NULL
  3  	 -- due to Oracle limitations we must use trigger not a package variable, trigger takes care
  4  	 -- to assign a default INFO log type if getting sosl_sys.NA_TYPE
  5    , log_type	   VARCHAR2(30)    DEFAULT 'n/a'			     NOT NULL
  6    , log_category	   VARCHAR2(256)   DEFAULT 'n/a'			     NOT NULL
  7    , message	   VARCHAR2(4000)					     NOT NULL
  8    , run_id 	   NUMBER(38, 0)
  9    , executor_id	   NUMBER(38, 0)
 10    , guid		   VARCHAR2(64)
 11    , sosl_identifier   VARCHAR2(256)
 12    , caller 	   VARCHAR2(256)
 13    , ext_script_id	   VARCHAR2(4000)
 14    , script_file	   VARCHAR2(4000)
 15    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 16    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , full_message	   CLOB
 18    )
 19    -- monthly partitions
 20    PARTITION BY RANGE (exec_timestamp)
 21    INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
 22    (PARTITION P_OLD
 23  	   VALUES LESS THAN (TO_TIMESTAMP('01-01-2024','DD-MM-YYYY'))
 24    )
 25  ;

Table created.

SQL> COMMENT ON TABLE sosl_server_log IS 'Holds the log events of the SOSL server CMD and interaction with the database as well as database events. Update is not allowed. Will use the alias slog.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.exec_timestamp IS 'The timestamp of the event. Automatically set by trigger, no set allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_type IS 'The logging type, supports currently INFO, WARNING, ERROR, FATAL, SUCCESS. Mandatory. Defined in package SOSL_SYS.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_category IS 'The log writer may provide an short log category description.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.message IS 'The shortend log message. Mandatory. If only a CLOB is passed, the short message is build from the CLOB. Categories too long will be cutted.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.full_message IS 'The full log message. For messages longer than 4000 bytes or char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.guid IS 'The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.sosl_identifier IS 'The exact identifier for SOSLERRORLOG if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.run_id IS 'The associated run id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.executor_id IS 'The associated executor id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.ext_script_id IS 'The (external) script id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.caller IS 'Caller identification if available, to distinguish database processes from SOSL CMD server processes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by IS 'The logged in DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- no primary key, only index
SQL> CREATE INDEX sosl_server_log_idx
  2    ON sosl_server_log (exec_timestamp, log_type, log_category)
  3  ;

Index created.

SQL> -- no constraints, as Oracle does not allow package functions in CHECK conditions
SQL> 
SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_server_log_ins_trg
  2    BEFORE INSERT ON sosl_server_log
  3    FOR EACH ROW
  4  DECLARE
  5    l_split BOOLEAN;
  6  BEGIN
  7    -- first set default value if not set, as Oracle does not support default values from package variables
  8    IF :NEW.log_type = sosl_sys.NA_TYPE
  9    THEN
 10  	 :NEW.log_type := sosl_sys.INFO_TYPE;
 11    END IF;
 12    -- instead of check constraint to get package support
 13    IF NOT sosl_sys.log_type_valid(:NEW.log_type)
 14    THEN
 15  	 -- do not block logging, log the error instead, move message to full message
 16  	 :NEW.full_message := :NEW.message || :NEW.full_message;
 17  	 :NEW.message	   := 'Invalid log type. Not supported by package SOSL_SYS. Given log type: ' || :NEW.log_type;
 18  	 :NEW.log_type	   := sosl_sys.FATAL_TYPE;
 19    ELSE
 20  	 :NEW.log_type := sosl_sys.get_valid_log_type(:NEW.log_type);
 21    END IF;
 22    :NEW.exec_timestamp := SYSTIMESTAMP;
 23    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 24    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 25    -- split messages
 26    IF NOT sosl_sys.distribute(:NEW.message, :NEW.full_message, 4000)
 27    THEN
 28  	 -- do not block logging, log the error instead, if :NEW.message contains error information leave it there
 29  	 IF :NEW.message IS NULL AND :NEW.full_message IS NULL
 30  	 THEN
 31  	   :NEW.message := 'Full message must be given, if message is NULL or vice versa.';
 32  	 END IF;
 33  	 :NEW.log_type := sosl_sys.FATAL_TYPE;
 34    END IF;
 35  END;
 36  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_upd_trg
  2    BEFORE UPDATE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20005, 'No updates allowed on a log table.');
  6  END;
  7  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_del_trg
  2    BEFORE DELETE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20006, 'Delete records from a log table is not allowed. This is an admin job which needs sufficient rights.');
  6  END;
  7  /

Trigger created.

SQL> -- logging package
SQL> @@../sosl_ddl/packages/sosl_log.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Basic logging package, dependencies only to sosl_server_log.
SQL> CREATE OR REPLACE PACKAGE sosl_log
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader for managing logging.
  5    * Apart from sosl_server_log table, there are no dependencies, severe exceptions must be catched or handled by the caller.
  6    * The interface has as well functions and procedures. Functions inform about success or error, whereas procedure exceptions
  7    * must be handled by the caller.
  8    *
  9    * CURRENT ORACLE error: NOCOPY for IN parameters creates compile errors, whereas documentation allows IN NOCOPY var. Any
 10    * CLOB handling errors are possibly caused by the inability to provide a CLOB as reference.
 11    */
 12  
 13    /*====================================== start internal functions made visible for testing ======================================*/
 14    /* PROCEDURE SOSL_LOG.LOG_FALLBACK
 15    * This procedure tries some fallback actions, if logging raised an exception. It will not throw an exception. It will try to log the error in
 16    * SOSL_SERVER_LOG, SOSLERRORLOG, SPERRORLOG or, if everything fails output the error via DBMS_OUTPUT. As we can't determine if the message contains
 17    * an illegal character forcing the exception, the caller should transfer SQLERRM and verify the transmitted content before passing it to this procedure
 18    * or avoid transmitting parameters which should cause errors. If error could be logged to one of the tables, it can be found in this tables with
 19    * identifier SOSL_LOG. It will not prevent the exception, only try to log it somewhere, where it could be found without needing to analyze the db server
 20    * logs. Everything runs as autonomous transaction. DO NOT USE THIS PROCEDURE. It is internal for this package.
 21    *
 22    * @param p_script The package function or procedure causing the error, e.g. SOSL_LOG.LOG_EVENT.
 23    * @param p_identifier The identifier for this error. Saved in SOSL_IDENTIFIER in SOSL_SERVER_LOG or IDENTIFIER in the error log tables.
 24    * @param p_message The message to save. Reduce it to SQLERRM if possible.
 25    */
 26    PROCEDURE log_fallback( p_script      IN VARCHAR2
 27  			     , p_identifier  IN VARCHAR2
 28  			     , p_message     IN VARCHAR2
 29  			     )
 30    ;
 31    /* PROCEDURE SOSL_LOG.LOG_EVENT
 32    * Writes a log entry as autonomous transaction. This is the internal base procedure, exposed for testing.
 33    * If on errors writing log entries is not possible the procedure hands the exception to the caller. This is the pure insert without
 34    * any checks. It takes the values as given and table may trigger exceptions. DO NOT USE THIS PROCEDURE. It is internal for this package.
 35    *
 36    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 37    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Must be valid.
 38    * @param p_log_category An optional logging category.
 39    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 40    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 41    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 42    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 43    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 44    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 45    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 46    */
 47    PROCEDURE log_event( p_message	       IN VARCHAR2
 48  			  , p_log_type	       IN VARCHAR2
 49  			  , p_log_category     IN VARCHAR2
 50  			  , p_guid	       IN VARCHAR2
 51  			  , p_sosl_identifier  IN VARCHAR2
 52  			  , p_executor_id      IN NUMBER
 53  			  , p_ext_script_id    IN VARCHAR2
 54  			  , p_caller	       IN VARCHAR2
 55  			  , p_run_id	       IN NUMBER
 56  			  , p_full_message     IN CLOB
 57  			  )
 58    ;
 59  /*====================================== end internal functions made visible for testing ======================================*/
 60  
 61    /* PROCEDURE SOSL_LOG.FULL_LOG
 62    * Procedure with all parameters for logging. Will check parameters before logging. You should at least set also p_log_category
 63    * and p_caller, to be able to assign the log entry to a specific event and object. On parameter errors a separate log entry is
 64    * created. Intention is to write a log in any case and not throw any exception. This still may happen on main system malfunctions
 65    * but is limited to this events.
 66    *
 67    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 68    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Will be set to ERROR if not valid.
 69    * @param p_log_category An optional logging category.
 70    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 71    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 72    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 73    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 74    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 75    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 76    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 77    */
 78    PROCEDURE full_log( p_message	      IN VARCHAR2
 79  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_sys.INFO_TYPE
 80  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
 81  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
 82  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
 83  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
 84  			 , p_executor_id      IN NUMBER      DEFAULT NULL
 85  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
 86  			 , p_run_id	      IN NUMBER      DEFAULT NULL
 87  			 , p_full_message     IN CLOB	     DEFAULT NULL
 88  			 )
 89    ;
 90  
 91    PROCEDURE cmd_log( p_message	     IN VARCHAR2
 92  			, p_log_type	     IN VARCHAR2     DEFAULT sosl_sys.INFO_TYPE
 93  			, p_caller	     IN VARCHAR2     DEFAULT NULL
 94  			, p_guid	     IN VARCHAR2     DEFAULT NULL
 95  			, p_sosl_identifier  IN VARCHAR2     DEFAULT NULL
 96  			, p_executor_id      IN NUMBER	     DEFAULT NULL
 97  			, p_ext_script_id    IN VARCHAR2     DEFAULT NULL
 98  			, p_full_message     IN CLOB	     DEFAULT NULL
 99  			)
100    ;
101  
102    /* FUNCTION SOSL_LOG.DUMMY_MAIL
103    * This is a testing function that will NOT send any mail. It will log the mail message created in SOSL_SERVER_LOG using
104    * the field full_message, so output can be controlled.
105    *
106    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
107    * @param p_recipients The semicolon separated list of mail recipient addresses.
108    * @param p_subject A preferablly short subject for the mail.
109    * @param p_message The correctly formatted mail message.
110    *
111    * @return Will return 0 on success or -1 on errors.
112    */
113    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
114  			  , p_recipients  IN VARCHAR2
115  			  , p_subject	  IN VARCHAR2
116  			  , p_message	  IN VARCHAR2
117  			  )
118  	 RETURN NUMBER
119    ;
120  
121  END;
122  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_log.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE PACKAGE BODY sosl_log
  2  AS
  3    -- for description see header file
  4    PROCEDURE log_fallback( p_script      IN VARCHAR2
  5  			     , p_identifier  IN VARCHAR2
  6  			     , p_message     IN VARCHAR2
  7  			     )
  8    IS
  9  	 PRAGMA AUTONOMOUS_TRANSACTION;
 10  	 l_saved BOOLEAN;
 11    BEGIN
 12  	 l_saved := FALSE;
 13  	 -- try to save information in tables probably available
 14  	 BEGIN
 15  	   INSERT INTO sosl_server_log
 16  	     ( message
 17  	     , log_type
 18  	     , log_category
 19  	     , sosl_identifier
 20  	     , caller
 21  	     )
 22  	     VALUES
 23  	       ( p_message
 24  	       , sosl_sys.FATAL_TYPE
 25  	       , 'SOSL_LOG internal error'
 26  	       , p_identifier
 27  	       , p_script
 28  	       )
 29  	   ;
 30  	   COMMIT;
 31  	   l_saved := TRUE;
 32  	 EXCEPTION
 33  	   WHEN OTHERS THEN
 34  	     l_saved := FALSE;
 35  	 END;
 36  	 IF NOT l_saved
 37  	 THEN
 38  	   BEGIN
 39  	     INSERT INTO soslerrorlog
 40  	       ( message
 41  	       , identifier
 42  	       , script
 43  	       , username
 44  	       , timestamp
 45  	       )
 46  	       VALUES
 47  		 ( p_message
 48  		 , p_identifier
 49  		 , p_script
 50  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 51  		 , SYSTIMESTAMP
 52  		 )
 53  	     ;
 54  	     COMMIT;
 55  	     l_saved := TRUE;
 56  	   EXCEPTION
 57  	     WHEN OTHERS THEN
 58  	       l_saved := FALSE;
 59  	   END;
 60  	 END IF;
 61  	 IF NOT l_saved
 62  	 THEN
 63  	   BEGIN
 64  	     INSERT INTO sperrorlog
 65  	       ( message
 66  	       , identifier
 67  	       , script
 68  	       , username
 69  	       , timestamp
 70  	       )
 71  	       VALUES
 72  		 ( p_message
 73  		 , p_identifier
 74  		 , p_script
 75  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 76  		 , SYSTIMESTAMP
 77  		 )
 78  	     ;
 79  	     COMMIT;
 80  	     l_saved := TRUE;
 81  	   EXCEPTION
 82  	     WHEN OTHERS THEN
 83  	       l_saved := FALSE;
 84  	   END;
 85  	 END IF;
 86  	 -- all inserts failed, use DBMS_OUTPUT
 87  	 IF NOT l_saved
 88  	 THEN
 89  	   BEGIN
 90  	     DBMS_OUTPUT.PUT_LINE('Fatal error in ' || p_script || ' error: ' || p_message);
 91  	   EXCEPTION
 92  	     WHEN OTHERS THEN
 93  	       NULL;
 94  	   END;
 95  	 END IF;
 96    EXCEPTION
 97  	 WHEN OTHERS THEN
 98  	   -- do exactly nothing to avoid an additional exception on database malfunction
 99  	   NULL;
100    END log_fallback;
101  
102    PROCEDURE log_event( p_message	       IN VARCHAR2
103  			  , p_log_type	       IN VARCHAR2
104  			  , p_log_category     IN VARCHAR2
105  			  , p_guid	       IN VARCHAR2
106  			  , p_sosl_identifier  IN VARCHAR2
107  			  , p_executor_id      IN NUMBER
108  			  , p_ext_script_id    IN VARCHAR2
109  			  , p_caller	       IN VARCHAR2
110  			  , p_run_id	       IN NUMBER
111  			  , p_full_message     IN CLOB
112  			  )
113    IS
114  	 PRAGMA AUTONOMOUS_TRANSACTION;
115    BEGIN
116  	 INSERT INTO sosl_server_log
117  	   ( message
118  	   , log_type
119  	   , log_category
120  	   , guid
121  	   , sosl_identifier
122  	   , executor_id
123  	   , ext_script_id
124  	   , caller
125  	   , run_id
126  	   , full_message
127  	   )
128  	   VALUES
129  	     ( p_message
130  	     , p_log_type
131  	     , p_log_category
132  	     , p_guid
133  	     , p_sosl_identifier
134  	     , p_executor_id
135  	     , p_ext_script_id
136  	     , p_caller
137  	     , p_run_id
138  	     , p_full_message
139  	     )
140  	 ;
141  	 COMMIT;
142    EXCEPTION
143  	 WHEN OTHERS THEN
144  	   -- use fallback
145  	   log_fallback('SOSL_LOG.LOG_EVENT', 'SOSL_LOG', SQLERRM);
146  	   -- try ROLLBACK
147  	   ROLLBACK;
148  	   -- and raise the error again now
149  	   RAISE;
150    END log_event;
151  
152    PROCEDURE full_log( p_message	      IN VARCHAR2
153  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_sys.INFO_TYPE
154  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
155  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
156  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
157  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
158  			 , p_executor_id      IN NUMBER      DEFAULT NULL
159  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
160  			 , p_run_id	      IN NUMBER      DEFAULT NULL
161  			 , p_full_message     IN CLOB	     DEFAULT NULL
162  			 )
163    IS
164  	 -- set variables to current type
165  	 l_log_category    sosl_server_log.log_category%TYPE;
166  	 l_caller	   sosl_server_log.caller%TYPE;
167  	 l_guid 	   sosl_server_log.guid%TYPE;
168  	 l_sosl_identifier sosl_server_log.sosl_identifier%TYPE;
169  	 l_executor_id	   sosl_server_log.executor_id%TYPE;
170  	 l_ext_script_id   sosl_server_log.ext_script_id%TYPE;
171  	 l_run_id	   sosl_server_log.run_id%TYPE;
172    BEGIN
173  	 -- we leave info type and message splitting to be handled by table trigger, only check other parameters for type and length.
174  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'LOG_CATEGORY', p_log_category)
175  	 THEN
176  	   -- write extra log entry and cut original content to limit
177  	   log_event( 'p_log_category length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
178  		    , sosl_sys.FATAL_TYPE
179  		    , 'LOG USAGE ERROR'
180  		    , NULL, NULL, NULL, NULL, NULL, NULL
181  		    , (p_message || ' - ' || p_full_message)
182  		    )
183  	   ;
184  	   l_log_category := SUBSTR(p_log_category, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'LOG_CATEGORY'));
185  	 ELSE
186  	   l_log_category := NVL(p_log_category, 'not set');
187  	 END IF;
188  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'CALLER', p_caller)
189  	 THEN
190  	   -- write extra log entry and cut original content to limit
191  	   log_event( 'p_caller length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
192  		    , sosl_sys.FATAL_TYPE
193  		    , 'LOG USAGE ERROR'
194  		    , NULL, NULL, NULL, NULL, NULL, NULL
195  		    , (p_message || ' - ' || p_full_message)
196  		    )
197  	   ;
198  	   l_caller := SUBSTR(p_caller, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'CALLER'));
199  	 ELSE
200  	   l_caller := p_caller;
201  	 END IF;
202  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'GUID', p_guid)
203  	 THEN
204  	   -- write extra log entry and cut original content to limit
205  	   log_event( 'p_guid length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
206  		    , sosl_sys.FATAL_TYPE
207  		    , 'LOG USAGE ERROR'
208  		    , NULL, NULL, NULL, NULL, NULL, NULL
209  		    , (p_message || ' - ' || p_full_message)
210  		    )
211  	   ;
212  	   l_guid := SUBSTR(p_guid, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'GUID'));
213  	 ELSE
214  	   l_guid := p_guid;
215  	 END IF;
216  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'SOSL_IDENTIFIER', p_sosl_identifier)
217  	 THEN
218  	   -- write extra log entry and cut original content to limit
219  	   log_event( 'p_sosl_identifier length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
220  		    , sosl_sys.FATAL_TYPE
221  		    , 'LOG USAGE ERROR'
222  		    , NULL, NULL, NULL, NULL, NULL, NULL
223  		    , (p_message || ' - ' || p_full_message)
224  		    )
225  	   ;
226  	   l_sosl_identifier := SUBSTR(p_sosl_identifier, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'SOSL_IDENTIFIER'));
227  	 ELSE
228  	   l_sosl_identifier := p_sosl_identifier;
229  	 END IF;
230  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'EXECUTOR_ID', p_executor_id)
231  	 THEN
232  	   -- write extra log entry and cut original content to limit
233  	   log_event( 'p_executor_id length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error. EXECUTOR_ID: ' || p_executor_id
234  		    , sosl_sys.FATAL_TYPE
235  		    , 'LOG USAGE ERROR'
236  		    , NULL, NULL, NULL, NULL, NULL, NULL
237  		    , (p_message || ' - ' || p_full_message)
238  		    )
239  	   ;
240  	   -- we can't shorten the number, leave it to oracle
241  	   l_executor_id := p_executor_id;
242  	 ELSE
243  	   l_executor_id := p_executor_id;
244  	 END IF;
245  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'EXT_SCRIPT_ID', p_ext_script_id)
246  	 THEN
247  	   -- write extra log entry and cut original content to limit
248  	   log_event( 'ext_script_id length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
249  		    , sosl_sys.FATAL_TYPE
250  		    , 'LOG USAGE ERROR'
251  		    , NULL, NULL, NULL, NULL, NULL, NULL
252  		    , (p_message || ' - ' || p_full_message)
253  		    )
254  	   ;
255  	   l_ext_script_id := SUBSTR(p_ext_script_id, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'EXT_SCRIPT_ID'));
256  	 ELSE
257  	   l_ext_script_id := p_ext_script_id;
258  	 END IF;
259  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'RUN_ID', p_run_id)
260  	 THEN
261  	   -- write extra log entry and cut original content to limit
262  	   log_event( 'p_run_id length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error. RUN_ID: ' || p_run_id
263  		    , sosl_sys.FATAL_TYPE
264  		    , 'LOG USAGE ERROR'
265  		    , NULL, NULL, NULL, NULL, NULL, NULL
266  		    , (p_message || ' - ' || p_full_message)
267  		    )
268  	   ;
269  	   -- we can't shorten the number, leave it to oracle
270  	   l_run_id := p_run_id;
271  	 ELSE
272  	   l_run_id := p_run_id;
273  	 END IF;
274  	 -- try to write the given data to SOSL_SERVER_LOG
275  	 log_event(p_message, p_log_type, l_log_category, l_guid, l_sosl_identifier, l_executor_id, l_ext_script_id, l_caller, l_run_id, p_full_message);
276    EXCEPTION
277  	 WHEN OTHERS THEN
278  	   log_event( 'full log error: ' || TRIM(SUBSTR(SQLERRM, 1, 3900))
279  		    , sosl_sys.FATAL_TYPE
280  		    , 'FULL_LOG ERROR'
281  		    , NULL, NULL, NULL, NULL, NULL, NULL
282  		    , SQLERRM || ': ' || p_message
283  		    )
284  	   ;
285    END full_log;
286  
287    PROCEDURE cmd_log( p_message	     IN VARCHAR2
288  			, p_log_type	     IN VARCHAR2     DEFAULT sosl_sys.INFO_TYPE
289  			, p_caller	     IN VARCHAR2     DEFAULT NULL
290  			, p_guid	     IN VARCHAR2     DEFAULT NULL
291  			, p_sosl_identifier  IN VARCHAR2     DEFAULT NULL
292  			, p_executor_id      IN NUMBER	     DEFAULT NULL
293  			, p_ext_script_id    IN VARCHAR2     DEFAULT NULL
294  			, p_full_message     IN CLOB	     DEFAULT NULL
295  			)
296    IS
297    BEGIN
298  	 full_log( p_message => p_message
299  		 , p_log_type => p_log_type
300  		 , p_caller => p_caller
301  		 , p_guid => p_guid
302  		 , p_sosl_identifier => p_sosl_identifier
303  		 , p_executor_id => p_executor_id
304  		 , p_ext_script_id => p_ext_script_id
305  		 , p_full_message => p_full_message
306  		 )
307  	 ;
308    EXCEPTION
309  	 WHEN OTHERS THEN
310  	   log_event( 'CMD log error: ' || TRIM(SUBSTR(SQLERRM, 1, 3900))
311  		    , sosl_sys.FATAL_TYPE
312  		    , 'CMD_LOG ERROR'
313  		    , NULL, NULL, NULL, NULL, NULL, NULL
314  		    , SQLERRM || ': ' || p_message
315  		    )
316  	   ;
317    END cmd_log;
318  
319    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
320  			  , p_recipients  IN VARCHAR2
321  			  , p_subject	  IN VARCHAR2
322  			  , p_message	  IN VARCHAR2
323  			  )
324  	 RETURN NUMBER
325    IS
326  	 l_message	 VARCHAR2(32767);
327  	 l_category	 sosl_server_log.log_category%TYPE   := 'MAIL DUMMY';
328  	 l_caller	 sosl_server_log.caller%TYPE	     := 'sosl_log.dummy_mail';
329    BEGIN
330  	 l_message := sosl_sys.format_mail(p_sender, p_recipients, p_subject, p_message);
331  	 full_log( p_message => 'Fake mail with subject "' || p_subject || '" created in full_message. Check the results.'
332  		 , p_log_type => sosl_sys.INFO_TYPE
333  		 , p_log_category => l_category
334  		 , p_caller => l_caller
335  		 , p_full_message => l_message
336  		 )
337  	 ;
338  	 RETURN 0;
339    EXCEPTION
340  	 WHEN OTHERS THEN
341  	   -- log the error instead of RAISE
342  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl_log.dummy_mail function: ' || SQLERRM
343  			    , p_log_type => sosl_sys.FATAL_TYPE
344  			    , p_log_category => l_category
345  			    , p_caller => l_caller
346  			    )
347  	   ;
348  	   RETURN -1;
349    END dummy_mail;
350  
351  END;
352  /

Package body created.

SQL> -- queues
SQL> @@../sosl_ddl/queues/sosl_script_queue.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- creates a basic internal queue using AQ, has to be started separately
SQL> 
SQL> -- first create the payload type for queue only header, no member function
SQL> CREATE OR REPLACE TYPE sosl_payload
  2    AS OBJECT
  3  	 /* This type is used by the internal message queue of SOSL. It does not provide any member functions
  4  	 * only fields to fill. Object initialization basic example:
  5  	 * DECLARE
  6  	 *   -- to access the type from other schemas, do not forget to qualify it with the SOSL schema used
  7  	 *   l_sosl_payload SOSL.SOSL_PAYLOAD;
  8  	 * BEGIN
  9  	 *   l_sosl_payload := sosl_payload(1, 'My script ID', '../../mydir/scriptfile.sql');
 10  	 * END;
 11  	 */
 12  	 ( executor_id	  NUMBER(38, 0)  -- the executor_id from SOSL_EXECUTOR responsible for the script
 13  	 , ext_script_id  VARCHAR2(4000) -- the external script id managed by the executor
 14  	 , script_file	  VARCHAR2(4000) -- the script file name with full or relative path on the server where SOSL is running locally
 15  	 )
 16  ;
 17  /

Type created.

SQL> -- create and start the queue using explicite AQ defaults, so if defaults change behavior is still the same
SQL> BEGIN
  2    DBMS_AQADM.CREATE_QUEUE_TABLE( queue_table => 'SOSL_SCRIPT_QUEUE'
  3  				    , queue_payload_type => 'SOSL_PAYLOAD'
  4  				    , storage_clause => NULL
  5  				    , sort_list => NULL
  6  				    , multiple_consumers => NULL
  7  				    , message_grouping => DBMS_AQADM.NONE
  8  				    , comment => 'Queue table that holds the external script id and executor_id to be processed. Needed for parallel requests from different executors.'
  9  				    , auto_commit => NULL
 10  				    , primary_instance => 0
 11  				    , secondary_instance => 0
 12  				    , compatible => NULL
 13  				    , secure => FALSE
 14  				    , replication_mode => DBMS_AQADM.NONE
 15  				    );
 16    DBMS_AQADM.CREATE_QUEUE( queue_name => 'SOSL_SCRIPT_QUEUE'
 17  			      , queue_table => 'SOSL_SCRIPT_QUEUE'
 18  			      , queue_type => DBMS_AQADM.NORMAL_QUEUE
 19  			      , max_retries => 5
 20  			      , retry_delay => 0
 21  			      , retention_time => 0
 22  			      , dependency_tracking => FALSE
 23  			      , comment => 'Queue that holds the external script id and executor_id to be processed. Needed for parallel requests from different executors.'
 24  			      , auto_commit => TRUE
 25  			      );
 26    DBMS_AQADM.START_QUEUE('SOSL_SCRIPT_QUEUE', TRUE, TRUE);
 27  END;
 28  /

PL/SQL procedure successfully completed.

SQL> -- SOSL objects with possible references to sosl_log and sosl_sys
SQL> @@../sosl_ddl/tables/sosl_config.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_config
  2    ( config_name	     VARCHAR2(128)					       NOT NULL
  3    , config_value	     VARCHAR2(4000)					       NOT NULL
  4    , config_max_length   NUMBER	     DEFAULT -1 			       NOT NULL
  5    , config_type	     VARCHAR2(6)     DEFAULT 'CHAR'			       NOT NULL
  6    , created	     DATE	     DEFAULT SYSDATE			       NOT NULL
  7    , updated	     DATE	     DEFAULT SYSDATE			       NOT NULL
  8    , created_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
  9    , created_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
 11    , updated_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , config_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_config IS 'Holds the configuration used by SOSL. Will use the alias scfg.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_name IS 'The unique case sensitive name of the SOSL configuration object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_value IS 'The configuration value always as VARCHAR2. Type handling and conversion must be done by the caller.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_type IS 'Defines how the config value has to be interpreted. Currently supports CHAR and NUMBER.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_max_length IS 'Defines a maximum length for CHAR type config values if set to a number > 0. Default is -1, do not not check length.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_description IS 'Optional description of the SOSL config object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- primary key
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_pk
  3    PRIMARY KEY (config_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_type
  3    CHECK (config_type IN ('CHAR', 'NUMBER'))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_max_length
  3    CHECK (config_max_length = -1 OR config_max_length > 0)
  4  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_config_ins_upd_trg
  2    BEFORE INSERT OR UPDATE ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok    BOOLEAN;
  6    l_date  DATE;
  7  BEGIN
  8    -- remove any leading and trailing blanks from config_value
  9    :NEW.config_value   := TRIM(:NEW.config_value);
 10    IF UPDATING
 11    THEN
 12  	 :NEW.created	     := :OLD.created;
 13  	 :NEW.created_by     := :OLD.created_by;
 14  	 :NEW.created_by_os  := :OLD.created_by_os;
 15    ELSE
 16  	 :NEW.created	     := SYSDATE;
 17  	 :NEW.created_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 18  	 :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 19    END IF;
 20    :NEW.updated	   := SYSDATE;
 21    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 22    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 23    -- check max length if defined
 24    IF :NEW.config_type = 'CHAR'
 25    THEN
 26  	 IF :NEW.config_max_length > 0
 27  	 THEN
 28  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 29  	   THEN
 30  	     sosl_log.full_log( p_message => 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value)
 31  			      , p_log_type => sosl_sys.FATAL_TYPE
 32  			      , p_log_category => 'SOSL_CONFIG/sosl_config_ins_upd_trg'
 33  			      , p_caller => 'sosl_config_ins_upd_trg'
 34  			      )
 35  	     ;
 36  	     RAISE_APPLICATION_ERROR(-20000, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 37  	   END IF;
 38  	 END IF;
 39    END IF;
 40    -- check number type
 41    IF :NEW.config_type = 'NUMBER'
 42    THEN
 43  	 l_ok := TRUE;
 44  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 45  	 BEGIN
 46  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 47  	 EXCEPTION
 48  	   WHEN OTHERS THEN
 49  	     l_ok := FALSE;
 50  	 END;
 51  	 IF NOT l_ok
 52  	 THEN
 53  	     sosl_log.full_log( p_message => 'The given config_value "' || :NEW.config_value || '" could not be converted successfully to a number.'
 54  			      , p_log_type => sosl_sys.FATAL_TYPE
 55  			      , p_log_category => 'SOSL_CONFIG/sosl_config_ins_upd_trg'
 56  			      , p_caller => 'sosl_config_ins_upd_trg'
 57  			      )
 58  	     ;
 59  	   RAISE_APPLICATION_ERROR(-20001, 'The given config_value "' || :NEW.config_value || '" could not be converted successfully to a number.');
 60  	 END IF;
 61    END IF;
 62  END;
 63  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_config_del_trg
  2    BEFORE DELETE ON sosl_config
  3    FOR EACH ROW
  4  BEGIN
  5    -- protect system parameters from delete
  6    IF :OLD.config_name IN ( 'SOSL_PATH_CFG'
  7  			      , 'SOSL_PATH_TMP'
  8  			      , 'SOSL_PATH_LOG'
  9  			      , 'SOSL_START_LOG'
 10  			      , 'SOSL_BASE_LOG'
 11  			      , 'SOSL_EXT_LOG'
 12  			      , 'SOSL_EXT_TMP'
 13  			      , 'SOSL_EXT_LOCK'
 14  			      , 'SOSL_EXT_ERROR'
 15  			      , 'SOSL_MAX_PARALLEL'
 16  			      , 'SOSL_RUNMODE'
 17  			      , 'SOSL_DEFAULT_WAIT'
 18  			      , 'SOSL_NOJOB_WAIT'
 19  			      , 'SOSL_PAUSE_WAIT'
 20  			      )
 21    THEN
 22  	 RAISE_APPLICATION_ERROR(-20002, 'The given system config_name "' || :OLD.config_name || '" cannot be deleted.');
 23    END IF;
 24  END;
 25  /

Trigger created.

SQL> -- load default values that can be configured in the database
SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_PATH_CFG', '..\..\sosl_cfg\', 'Relative path with delimiter at path end to configuration files the SOSL server uses. Set by SOSL server. As configuration files contain credentials and secrets the path should be in a safe space with controlled user rights.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_TMP', '..\..\sosl_tmp\', 239, 'Relative path with delimiter at path end to temporary files the SOSL server uses. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_LOG', '..\..\sosl_log\', 239, 'Relative path with delimiter at path end to log files the SOSL server creates. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_START_LOG', 'sosl_server', 'Log filename for start and end of SOSL server CMD. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_BASE_LOG', 'sosl_job_', 'Base log filename for single job runs. Will be extended by GUID. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOG', 'log', 'Log file extension to use. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_TMP', 'tmp', 'Log file extension for temporary logs to use. On error those file extension will be renamed to SOSL_EXT_ERROR extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOCK', 'lock', 'Default process lock file extension. Lock files will always get deleted either on service start or after a run. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_ERROR', 'err', 'Default process error file extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAX_PARALLEL', '8', 'NUMBER', 'The maximum of parallel started scripts. Read by the SOSL server. After this amount if scripts is started, next scripts are only loaded, if the run count is below this value.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_RUNMODE', 'RUN', 'CHAR', 'Determines if the server should RUN, WAIT or STOP. Read by the SOSL server. RUN will cause the SOSL server, if started to run as long as it does not get a STOP signal from the database. Set it to STOP to stop the SOSL server. Set to WAIT if the server should not call any script apart the check for the run mode. Can be locally overwritten.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_DEFAULT_WAIT', '1', 'NUMBER', 'Determines the normal sleep time in seconds the sosl server has between calls if scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_NOJOB_WAIT', '120', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if no scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_PAUSE_WAIT', '3600', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if run mode is set to wait.')
  5  ;

1 row created.

SQL> COMMIT;

Commit complete.

SQL> @@../sosl_ddl/tables/sosl_executor.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE TABLE sosl_executor
  2    ( executor_id	       NUMBER(38, 0)   GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , executor_name	       VARCHAR2(256)						 NOT NULL
  4    , db_user	       VARCHAR2(128)						 NOT NULL
  5    , function_owner        VARCHAR2(128)						 NOT NULL
  6    , fn_has_scripts        VARCHAR2(520)						 NOT NULL
  7    , fn_get_next_script    VARCHAR2(520)						 NOT NULL
  8    , fn_set_script_status  VARCHAR2(520)						 NOT NULL
  9    , cfg_file	       VARCHAR2(4000)						 NOT NULL
 10    , use_mail	       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 11    , mail_sender	       VARCHAR2(1024)  DEFAULT 'n/a'				 NOT NULL
 12    , mail_recipients       VARCHAR2(1024)  DEFAULT 'n/a'				 NOT NULL
 13    , fn_send_db_mail       VARCHAR2(520)   DEFAULT 'sosl_log.dummy_mail'		 NOT NULL
 14    , executor_active       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 15    , executor_reviewed     NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 16    , created	       DATE	       DEFAULT SYSDATE				 NOT NULL
 17    , updated	       DATE	       DEFAULT SYSDATE				 NOT NULL
 18    , created_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 19    , created_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 20    , updated_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 21    , updated_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 22    , script_schema	       VARCHAR2(128)   DEFAULT NULL
 23    , executor_description  VARCHAR2(4000)
 24    )
 25  ;

Table created.

SQL> COMMENT ON TABLE sosl_executor IS 'Defines the executors registered with SOSL. To improve security you may activate AUDIT on this table. Will use the alias sexe.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_id IS 'The generated unique id that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_name IS 'The unique name that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.db_user IS 'The login name of the database user must match cfg_file login and be USER after login. No mixed case support, converted to upper case. Must exist and have the necessary rights to execute the queued scripts. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.function_owner IS 'The owner user name of the API functions, refers to the schema where the functions are defined. No mixed case support, converted to upper case. Can differ from the database user that executes SOSL. All API functions must have the same owner for one executor. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_has_scripts IS 'The name of the function to use by HAS_SCRIPTS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the amount of waiting scripts as NUMBER or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_get_next_script IS 'The name of the function to use by GET_NEXT_SCRIPT wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the script id, executor id and script file name as type SOSL_PAYLOAD. It should manage the given script id to ensure that scripts are not run twice.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_set_script_status IS 'The name of the function to use by SET_SCRIPT_STATUS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameters P_REFERENCE IN SOSL_PAYLOAD, P_STATUS IN VARCHAR2 and return 0 or -1 on errors. P_REFERENCE is an object retrieved from GET_NEXT_ID. P_STATUS will always start with the following key words: PREPARING, ENQUEUED, RUNNING, SUCCESS, ERROR. It may contain additional informations in case of errors separated by at least one space char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_send_db_mail IS 'The name of the function to use by SEND_DB_MAIL wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameters P_SENDER IN VARCHAR2, P_RECIPIENTS IN VARCHAR2, P_SUBJECT IN VARCHAR2, P_MESSAGE IN VARCHAR2 and return 0 or -1 on errors. P_SENDER is the email address of the sender. P_RECIPIENTS contains the email addresses of the recipients, delimited by semicolon ";". P_SUBJECT is the email subject to use. P_MESSAGE contains the email message. The default logs to SOSL_SERVER_LOG instead of sending a mail. Can be used to test mail formatting.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.cfg_file IS 'The filename with absolute or relative path to the login config file for this executor. File and path must exist on the CMD server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_active IS 'Defines if the executor is active. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_reviewed IS 'Defines if the executor is reviewed, accepted and ready to be used. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.script_schema IS 'The (optional) schema the script should run in. If set will cause an ALTER SESSION SET CURRENT_SCHEMA before executing the script otherwise db user schema is used. DB user must have rights for this schema if set. If acting on own schema or scripts do ALTER SESSION by themselves, you should leave it NULL.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_description IS 'Optional executor description.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_pk
  3    PRIMARY KEY (executor_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- unique constraint
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_uk
  3    UNIQUE (executor_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- check constraints
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_use_mail
  3    CHECK (use_mail IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_active
  3    CHECK (executor_active IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_reviewed
  3    CHECK (executor_reviewed IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_executor_ins_trg
  2    BEFORE INSERT ON sosl_executor
  3    FOR EACH ROW
  4  DECLARE
  5    l_caller    VARCHAR2(256) := 'sosl_executor_ins_trg';
  6    l_category  VARCHAR2(256) := 'SOSL_EXECUTOR';
  7  BEGIN
  8    :NEW.created	       := SYSDATE;
  9    :NEW.created_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.created_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 11    :NEW.updated	       := SYSDATE;
 12    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 13    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 14    :NEW.executor_active    := 0;
 15    :NEW.executor_reviewed  := 0;
 16    -- transform users and functions to UPPERCASE, no support currently for special mix-case.
 17    :NEW.function_owner	 := UPPER(:NEW.function_owner);
 18    :NEW.db_user		 := UPPER(:NEW.db_user);
 19    :NEW.fn_has_scripts	 := UPPER(:NEW.fn_has_scripts);
 20    :NEW.fn_get_next_script	 := UPPER(:NEW.fn_get_next_script);
 21    :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 22    :NEW.fn_send_db_mail	 := UPPER(:NEW.fn_send_db_mail);
 23    -- check user
 24    IF NOT sosl_sys.has_db_user(:NEW.db_user)
 25    THEN
 26  	 sosl_log.full_log( p_message => 'The given database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 27  			  , p_log_type => sosl_sys.FATAL_TYPE
 28  			  , p_log_category => l_category
 29  			  , p_caller => l_caller
 30  			  )
 31  	 ;
 32  	 RAISE_APPLICATION_ERROR(-20003, 'The given database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 33    END IF;
 34    IF NOT sosl_sys.has_db_user(:NEW.function_owner)
 35    THEN
 36  	 sosl_log.full_log( p_message => 'The given function owner database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 37  			  , p_log_type => sosl_sys.FATAL_TYPE
 38  			  , p_log_category => l_category
 39  			  , p_caller => l_caller
 40  			  )
 41  	 ;
 42  	 RAISE_APPLICATION_ERROR(-20003, 'The given function owner database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 43    END IF;
 44    -- check configured functions
 45    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 46    THEN
 47  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_has_scripts || ' for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 48  			  , p_log_type => sosl_sys.FATAL_TYPE
 49  			  , p_log_category => l_category
 50  			  , p_caller => l_caller
 51  			  , p_full_message => 'Call sosl_sys.has_function(' || :NEW.function_owner || ',' || :NEW.fn_has_scripts || ')'
 52  			  )
 53  	 ;
 54  	 RAISE_APPLICATION_ERROR(-20004, 'The given function ' || :NEW.fn_has_scripts || ' for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 55    END IF;
 56    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'OBJECT')
 57    THEN
 58  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_next_script || ' for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to SOSL.'
 59  			  , p_log_type => sosl_sys.FATAL_TYPE
 60  			  , p_log_category => l_category
 61  			  , p_caller => l_caller
 62  			  )
 63  	 ;
 64  	 RAISE_APPLICATION_ERROR(-20005, 'The given function ' || :NEW.fn_get_next_script || ' for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to SOSL.');
 65    END IF;
 66    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
 67    THEN
 68  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_set_script_status || ' for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 69  			  , p_log_type => sosl_sys.FATAL_TYPE
 70  			  , p_log_category => l_category
 71  			  , p_caller => l_caller
 72  			  )
 73  	 ;
 74  	 RAISE_APPLICATION_ERROR(-20008, 'The given function ' || :NEW.fn_set_script_status || ' for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 75    END IF;
 76    IF     :NEW.use_mail = 1
 77  	  AND NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
 78    THEN
 79  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_send_db_mail || ' for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 80  			  , p_log_type => sosl_sys.FATAL_TYPE
 81  			  , p_log_category => l_category
 82  			  , p_caller => l_caller
 83  			  )
 84  	 ;
 85  	 RAISE_APPLICATION_ERROR(-20009, 'The given function ' || :NEW.fn_send_db_mail || ' for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 86    END IF;
 87    -- log the insert
 88    sosl_log.full_log( p_message => 'A new executor has been defined for DB user: ' || :NEW.db_user || ' with function owner: ' || :NEW.function_owner || ' created by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 89  			, p_log_type => sosl_sys.INFO_TYPE
 90  			, p_log_category => l_category
 91  			, p_caller => l_caller
 92  			)
 93    ;
 94  EXCEPTION
 95    WHEN OTHERS THEN
 96  	 -- catch and log all undefined exceptions
 97  	 IF SQLCODE NOT IN (-20003, -20004, -20005, -20006, -20007, -20008, -20009)
 98  	 THEN
 99  	   sosl_log.full_log( p_message => 'Unhandled exception in trigger sosl_executor_ins_trg: ' || SQLERRM
100  			    , p_log_type => sosl_sys.FATAL_TYPE
101  			    , p_log_category => l_category
102  			    , p_caller => l_caller
103  			    )
104  	   ;
105  	 END IF;
106  	 -- raise all errors
107  	 RAISE;
108  END;
109  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_executor_upd_trg
  2    BEFORE UPDATE ON sosl_executor
  3    FOR EACH ROW
  4  DECLARE
  5    l_change_record VARCHAR2(32767);
  6    l_caller        VARCHAR2(256) := 'sosl_executor_upd_trg';
  7    l_category      VARCHAR2(256) := 'SOSL_EXECUTOR';
  8  BEGIN
  9    l_change_record := 'Changes by OS user ' || SYS_CONTEXT('USERENV', 'OS_USER') || ': ';
 10    :NEW.updated	       := SYSDATE;
 11    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 12    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 13    -- no overwrite for this values
 14    IF :NEW.created != :OLD.created
 15    THEN
 16  	 l_change_record := l_change_record || 'Prohibited change of create date to: "' || TO_CHAR(:NEW.created, 'YYYY-MM-DD HH24:MI:SS') || '" ';
 17  	 :NEW.created		 := :OLD.created;
 18    END IF;
 19    :NEW.created_by	       := :OLD.created_by;
 20    :NEW.created_by_os      := :OLD.created_by_os;
 21    IF UPPER(:NEW.function_owner) != :OLD.function_owner
 22    THEN
 23  	 l_change_record := l_change_record || 'Prohibited change of function owner to: "' || :NEW.function_owner || '" ';
 24  	 :NEW.function_owner := :OLD.function_owner;
 25    END IF;
 26    IF UPPER(:NEW.db_user) != :OLD.db_user
 27    THEN
 28  	 l_change_record := l_change_record || 'Prohibited change of db user to: "' || :NEW.db_user || '" ';
 29  	 :NEW.db_user := :OLD.db_user;
 30    END IF;
 31    -- prepare possibly modified values
 32    IF :NEW.executor_active != :OLD.executor_active
 33    THEN
 34  	 l_change_record := l_change_record || 'Modified EXECUTOR_ACTIVE: "' || sosl_sys.yes_no(:NEW.executor_active) || '" ';
 35    END IF;
 36    IF :NEW.executor_reviewed != :OLD.executor_reviewed
 37    THEN
 38  	 l_change_record := l_change_record || 'Modified EXECUTOR_REVIEWED: "' || sosl_sys.yes_no(:NEW.executor_reviewed) || '" ';
 39    END IF;
 40    IF UPPER(:NEW.fn_has_scripts) != :OLD.fn_has_scripts
 41    THEN
 42  	 :NEW.fn_has_scripts := UPPER(:NEW.fn_has_scripts);
 43  	 l_change_record := l_change_record || 'Modified fn_has_scripts: "' || :NEW.fn_has_scripts || '" ';
 44    END IF;
 45    IF UPPER(:NEW.fn_get_next_script) != :OLD.fn_get_next_script
 46    THEN
 47  	 :NEW.fn_get_next_script := UPPER(:NEW.fn_get_next_script);
 48  	 l_change_record     := l_change_record || 'Modified fn_get_next_script: "' || :NEW.fn_get_next_script || '" ';
 49    END IF;
 50    IF UPPER(:NEW.fn_set_script_status) != :OLD.fn_set_script_status
 51    THEN
 52  	 :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 53  	 l_change_record       := l_change_record || 'Modified fn_set_script_status: "' || :NEW.fn_set_script_status || '" ';
 54    END IF;
 55    IF UPPER(:NEW.fn_send_db_mail) != :OLD.fn_send_db_mail
 56    THEN
 57  	 :NEW.fn_send_db_mail := UPPER(:NEW.fn_send_db_mail);
 58  	 l_change_record       := l_change_record || 'Modified FN_SEND_DB_MAIL: "' || :NEW.fn_send_db_mail || '" ';
 59    END IF;
 60    -- do all checks again including user
 61    -- check user
 62    IF NOT sosl_sys.has_db_user(:NEW.db_user)
 63    THEN
 64  	 sosl_log.full_log( p_message => 'The given database user is not longer visible for SOSL in ALL_USERS. Executor deactivated. Either the user does not exist or SOSL has no right to see this user.'
 65  			  , p_log_type => sosl_sys.FATAL_TYPE
 66  			  , p_log_category => l_category
 67  			  , p_caller => l_caller
 68  			  )
 69  	 ;
 70  	 :NEW.executor_active := 0;
 71    END IF;
 72    IF NOT sosl_sys.has_db_user(:NEW.function_owner)
 73    THEN
 74  	 sosl_log.full_log( p_message => 'The given function owner database user is not longer visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 75  			  , p_log_type => sosl_sys.FATAL_TYPE
 76  			  , p_log_category => l_category
 77  			  , p_caller => l_caller
 78  			  )
 79  	 ;
 80  	 :NEW.executor_active := 0;
 81    END IF;
 82    -- check configured functions
 83    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 84    THEN
 85  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_has_scripts || ' for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 86  			  , p_log_type => sosl_sys.FATAL_TYPE
 87  			  , p_log_category => l_category
 88  			  , p_caller => l_caller
 89  			  )
 90  	 ;
 91  	 RAISE_APPLICATION_ERROR(-20004, 'The given function ' || :NEW.fn_has_scripts || ' for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 92    END IF;
 93    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'SOSL_PAYLOAD')
 94    THEN
 95  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_get_next_script || ' for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype SOSL_PAYLOAD or is not granted with EXECUTE rights to SOSL.'
 96  			  , p_log_type => sosl_sys.FATAL_TYPE
 97  			  , p_log_category => l_category
 98  			  , p_caller => l_caller
 99  			  )
100  	 ;
101  	 RAISE_APPLICATION_ERROR(-20005, 'The given function ' || :NEW.fn_get_next_script || ' for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype SOSL_PAYLOAD or is not granted with EXECUTE rights to SOSL.');
102    END IF;
103    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
104    THEN
105  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_set_script_status || ' for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
106  			  , p_log_type => sosl_sys.FATAL_TYPE
107  			  , p_log_category => l_category
108  			  , p_caller => l_caller
109  			  )
110  	 ;
111  	 RAISE_APPLICATION_ERROR(-20008, 'The given function ' || :NEW.fn_set_script_status || ' for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
112    END IF;
113    IF     :NEW.use_mail = 1
114  	  AND NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
115    THEN
116  	 sosl_log.full_log( p_message => 'The given function ' || :NEW.fn_send_db_mail || ' for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
117  			  , p_log_type => sosl_sys.FATAL_TYPE
118  			  , p_log_category => l_category
119  			  , p_caller => l_caller
120  			  )
121  	 ;
122  	 RAISE_APPLICATION_ERROR(-20009, 'The given function ' || :NEW.fn_send_db_mail || ' for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
123    END IF;
124    -- log the insert
125    sosl_log.full_log( p_message => 'The configuration for executor ID: ' || :OLD.executor_id || ' has been updated by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER') || ' see full_message for details.'
126  			, p_log_type => sosl_sys.INFO_TYPE
127  			, p_log_category => l_category
128  			, p_caller => l_caller
129  			, p_full_message => TO_CLOB(l_change_record)
130  			)
131    ;
132  EXCEPTION
133    WHEN OTHERS THEN
134  	 -- catch and log all undefined exceptions
135  	 IF SQLCODE NOT IN (-20004, -20005, -20006, -20007, -20008, -20009)
136  	 THEN
137  	   sosl_log.full_log( p_message => 'Unhandled exception in trigger sosl_executor_upd_trg: ' || SQLERRM
138  			    , p_log_type => sosl_sys.FATAL_TYPE
139  			    , p_log_category => l_category
140  			    , p_caller => l_caller
141  			    )
142  	   ;
143  	 END IF;
144  	 -- raise all errors
145  	 RAISE;
146  END;
147  /

Trigger created.

SQL> -- internal objects using the API
SQL> @@../sosl_ddl/tables/sosl_script.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_script
  2    ( script_id	     NUMBER(38, 0)  GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , script_name	     VARCHAR2(2000)					      NOT NULL
  4    , script_order	     NUMBER(38, 0)  DEFAULT 1				      NOT NULL
  5    , created	     DATE	    DEFAULT SYSDATE			      NOT NULL
  6    , updated	     DATE	    DEFAULT SYSDATE			      NOT NULL
  7    , created_by	     VARCHAR2(256)  DEFAULT USER			      NOT NULL
  8    , created_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
  9    , updated_by	     VARCHAR2(256)  DEFAULT USER			      NOT NULL
 10    , updated_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 11    , executor_id	     NUMBER(38, 0)
 12    , script_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_script IS 'Holds the script file names that should be executed by SOSL. Will use the alias scrt.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_id IS 'The generated unique id of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.executor_id IS 'The related executor id of the script file. If defined, must match an existing executor. If not defined, script is ignored.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_name IS 'The name of the script file including full or relative path. Use relative path (relative to batch_base_path or repository location) to ensure running scripts from different machines.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_order IS 'The order in which the script file should be executed. Same number means in parallel. Higher order numbers wait for scripts with lower order numbers to complete.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_description IS 'Optional description of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_script
  2    ADD CONSTRAINT sosl_script_pk
  3    PRIMARY KEY (script_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- foreign key
SQL> ALTER TABLE sosl_script
  2    ADD CONSTRAINT sosl_script_fk
  3    FOREIGN KEY (executor_id)
  4    REFERENCES sosl_executor (executor_id)
  5    ON DELETE SET NULL
  6    ENABLE
  7  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_script_ins_trg
  2    BEFORE INSERT ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := SYSDATE;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_script_upd_trg
  2    BEFORE UPDATE ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    :NEW.updated	   := SYSDATE;
 10    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12  END;
 13  /

Trigger created.

SQL> -- packages depending on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_api.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- main API package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl_api
  2  AS
  3    /**
  4    * This package contains the main functions and procedures used in the API of the Simple Oracle Script Loader.
  5    * It is not allowed to use this package for function assignments in SOSL_EXECUTOR.
  6    */
  7  
  8    /* FUNCTION SOSL_API.HAS_SCRIPTS
  9    * This function will be used by the wrapper function HAS_SCRIPTS.
 10    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
 11    * return a number greater 0 as well as messages waiting in the queue to be processed. Errors will get logged.
 12    *
 13    * @return The amount of scripts waiting for all valid executor has_ids functions and waiting queue messages or -1 on unhandled exceptions or if all functions have errors.
 14    */
 15    FUNCTION has_scripts
 16  	 RETURN NUMBER
 17    ;
 18  
 19    /* FUNCTION SOSL_API.HAS_SCRIPTS
 20    * Gets any waiting scripts for a defined active and reviewed executor has_scripts function or for a given queue table name.
 21    * Will return 0 if the executor/queue does not exist or is not active and reviewed. Will return -1 on exceptions caused by this
 22    * function or the defined function. Errors will get logged.
 23    *
 24    * @param p_identifier The executor id or queue table name to get waiting script count.
 25    *
 26    * @return The amount of scripts waiting for processing or -1 on errors.
 27    */
 28    FUNCTION has_scripts(p_identifier IN NUMBER)
 29  	 RETURN NUMBER
 30    ;
 31    FUNCTION has_scripts(p_identifier IN VARCHAR2)
 32  	 RETURN NUMBER
 33    ;
 34  
 35    /* FUNCTION SOSL_API.HAS_SCRIPTS_FOR_FN
 36    * Checks only by function, to avoid duplicate counts, if different executors share the same function and are both active.
 37    *
 38    * @param p_fn_has_scripts The defined function call for HAS_SCRIPTS.
 39    *
 40    * @return The amount of scripts waiting for processing or -1 on errors.
 41    */
 42    FUNCTION has_scripts_for_fn(p_fn_has_scripts IN VARCHAR2)
 43  	 RETURN NUMBER
 44    ;
 45  
 46    /* FUNCTION SOSL_API.GET_NEXT_SCRIPT
 47    * This function will be used by the wrapper function GET_NEXT_SCRIPT.
 48    * It collects all scripts to execute, queues them in SOSL_SCRIPT_QUEUE and then fetches the first script in the
 49    * message queue as next script to execute. If no scripts are available or on errors, the function will return NULL.
 50    * Errors will be logged.
 51    *
 52    * @return The next script as SOSL_PAYLOAD type, containing the external script id, the executor id and the script filename including relative or full path.
 53    */
 54    FUNCTION get_next_script
 55  	 RETURN SOSL_PAYLOAD
 56    ;
 57  
 58  
 59    /** Function SOSL_API.SET_CONFIG
 60    * Sets an existing configuration value for a given configuration name.
 61    *
 62    * @return Exit code, either 0 = successful or -1 on error.
 63    */
 64    FUNCTION set_config( p_config_name  IN VARCHAR2
 65  			  , p_config_value IN VARCHAR2
 66  			  )
 67  	 RETURN NUMBER
 68    ;
 69  
 70    /** Function SOSL_API.GET_CONFIG
 71    * Gets an existing configuration value for a given and existing case sensitive configuration name.
 72    *
 73    * @return The configured value as VARCHAR2 or -1 string on error.
 74    */
 75    FUNCTION get_config(p_config_name IN VARCHAR2)
 76  	 RETURN VARCHAR2
 77    ;
 78  
 79  
 80    /** Function SOSL_API.BASE_PATH
 81    * Returns the base path to use for the given run id. Used to switch the run base path for scripts
 82    * running from a different directory.
 83    *
 84    * @return The configured full base path or a simple point for current directory if nothing is configured.
 85    */
 86    FUNCTION base_path(p_run_id IN NUMBER)
 87  	 RETURN VARCHAR2
 88    ;
 89  
 90    /** Function SOSL_API.CFG_PATH
 91    * Returns the relative configuration path to use for the given run id. A sosl_login.cfg file is expected
 92    * at the given location.
 93    *
 94    * @return The configured relative configuration path or the configured default set by the sosl server.
 95    */
 96    FUNCTION cfg_path(p_run_id IN NUMBER)
 97  	 RETURN VARCHAR2
 98    ;
 99  
100    /** Function SOSL_API.TMP_PATH
101    * Returns the relative temporary path to use for the given run id.
102    *
103    * @return The configured relative temporary path or the configured default set by the sosl server.
104    */
105    FUNCTION tmp_path(p_run_id IN NUMBER)
106  	 RETURN VARCHAR2
107    ;
108  
109    /** Function SOSL_API.LOG_PATH
110    * Returns the relative log path to use for the given run id.
111    *
112    * @return The configured relative log path or the configured default set by the sosl server.
113    */
114    FUNCTION log_path(p_run_id IN NUMBER)
115  	 RETURN VARCHAR2
116    ;
117  
118  END;
119  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_api.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE PACKAGE BODY sosl_api
  2  AS
  3    -- for description see header file
  4    FUNCTION has_scripts
  5  	 RETURN NUMBER
  6    IS
  7  	 l_return      NUMBER;
  8  	 l_success_cnt NUMBER;
  9  	 l_cnt_valid   NUMBER;
 10  	 l_tmp_cnt     NUMBER;
 11  	 l_queue_table VARCHAR2(128)			 := 'SOSL_SCRIPT_QUEUE';
 12  	 l_category    sosl_server_log.log_category%TYPE := 'HAS_SCRIPTS';
 13  	 l_caller      sosl_server_log.caller%TYPE	 := 'sosl_api.has_scripts queue and executor';
 14  	 CURSOR cur_executors
 15  	 IS
 16  	   SELECT UPPER(fn_has_scripts) AS fn_has_scripts
 17  	     FROM sosl_executor
 18  	    WHERE executor_active	= 1
 19  	      AND executor_reviewed	= 1
 20  	    GROUP BY UPPER(fn_has_scripts)
 21  	 ;
 22    BEGIN
 23  	 l_return      := -1;
 24  	 l_success_cnt := 0;
 25  	 sosl_log.full_log( p_message => 'sosl_api.has_scripts called'
 26  			  , p_log_type => sosl_sys.INFO_TYPE
 27  			  , p_log_category => l_category
 28  			  , p_caller => l_caller
 29  			  )
 30  	 ;
 31  	 SELECT COUNT(*) INTO l_cnt_valid FROM sosl_executor WHERE executor_active = 1 AND executor_reviewed = 1;
 32  	 IF l_cnt_valid > 0
 33  	 THEN
 34  	   l_return := 0;
 35  	   -- loop through unique defined functions
 36  	   FOR rec IN cur_executors
 37  	   LOOP
 38  	     l_tmp_cnt := sosl_api.has_scripts_for_fn(rec.fn_has_scripts);
 39  	     IF l_tmp_cnt > 0
 40  	     THEN
 41  	       l_success_cnt := l_success_cnt +1;
 42  	       l_return      := l_return + l_tmp_cnt;
 43  	     END IF;
 44  	   END LOOP;
 45  	   -- now check queue for waiting message, overrule failed functions calls if messages waiting
 46  	   l_tmp_cnt := sosl_api.has_scripts(l_queue_table);
 47  	   IF l_tmp_cnt > 0
 48  	   THEN
 49  	     l_success_cnt := l_success_cnt +1;
 50  	     l_return	   := l_return + l_tmp_cnt;
 51  	   END IF;
 52  	   -- if not at least one successful executed
 53  	   IF l_success_cnt <= 0
 54  	   THEN
 55  	     sosl_log.full_log( p_message => 'sosl_api.has_scripts did not find any valid executor has_scripts functions and messages in the queue. Return 0 scripts waiting.'
 56  			      , p_log_type => sosl_sys.ERROR_TYPE
 57  			      , p_log_category => l_category
 58  			      , p_caller => l_caller
 59  			      )
 60  	     ;
 61  	     l_return := 0;
 62  	   END IF;
 63  	 ELSE
 64  	   -- log no valid executors
 65  	   sosl_log.full_log( p_message => 'sosl_api.has_scripts called without valid executors defined. Return 0 scripts waiting.'
 66  			    , p_log_type => sosl_sys.WARNING_TYPE
 67  			    , p_log_category => l_category
 68  			    , p_caller => l_caller
 69  			    )
 70  	   ;
 71  	   l_return := 0;
 72  	 END IF;
 73  	 RETURN l_return;
 74    EXCEPTION
 75  	 WHEN OTHERS THEN
 76  	   -- log the error instead of RAISE
 77  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl_api.has_scripts function: ' || SQLERRM
 78  			    , p_log_type => sosl_sys.FATAL_TYPE
 79  			    , p_log_category => l_category
 80  			    , p_caller => l_caller
 81  			    )
 82  	   ;
 83  	   RETURN -1;
 84    END has_scripts;
 85  
 86    FUNCTION has_scripts(p_identifier IN NUMBER)
 87  	 RETURN NUMBER
 88    IS
 89  	 l_has_executor  NUMBER;
 90  	 l_return	 NUMBER;
 91  	 l_fn_call	 sosl_executor.fn_has_scripts%TYPE;
 92  	 l_category	 sosl_server_log.log_category%TYPE   := 'HAS_SCRIPTS';
 93  	 l_caller	 sosl_server_log.caller%TYPE	     := 'sosl_api.has_scripts executor';
 94    BEGIN
 95  	 l_return := -1;
 96  	 sosl_log.full_log( p_message => 'sosl_api.has_scripts executer check p_identifier: ' || p_identifier
 97  			  , p_log_type => sosl_sys.INFO_TYPE
 98  			  , p_log_category => l_category
 99  			  , p_caller => l_caller
100  			  )
101  	 ;
102  	 SELECT COUNT(*)
103  	   INTO l_has_executor
104  	   FROM sosl_executor
105  	  WHERE executor_active   = 1
106  	    AND executor_reviewed = 1
107  	 ;
108  	 IF l_has_executor = 0
109  	 THEN
110  	   sosl_log.full_log( p_message => 'The given executor id does not exist or is not active and reviewed: "' || p_identifier || '". Return 0 scripts waiting.'
111  			    , p_log_type => sosl_sys.ERROR_TYPE
112  			    , p_log_category => l_category
113  			    , p_caller => l_caller
114  			    )
115  	   ;
116  	   l_return := 0;
117  	 ELSE
118  	   SELECT fn_has_scripts INTO l_fn_call FROM sosl_executor WHERE executor_id = p_identifier;
119  	   l_return := sosl_api.has_scripts_for_fn(l_fn_call);
120  	 END IF;
121  	 RETURN l_return;
122    EXCEPTION
123  	 WHEN OTHERS THEN
124  	   -- log the error instead of RAISE
125  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl_api.has_scripts for executor function: ' || SQLERRM
126  			    , p_log_type => sosl_sys.FATAL_TYPE
127  			    , p_log_category => l_category
128  			    , p_caller => l_caller
129  			    )
130  	   ;
131  	   RETURN -1;
132    END has_scripts;
133  
134    FUNCTION has_scripts(p_identifier IN VARCHAR2)
135  	 RETURN NUMBER
136    IS
137  	 l_has_queue   NUMBER;
138  	 l_return      NUMBER;
139  	 l_category    sosl_server_log.log_category%TYPE := 'HAS_SCRIPTS';
140  	 l_caller      sosl_server_log.caller%TYPE	 := 'sosl_api.has_scripts queue';
141    BEGIN
142  	 l_return := -1;
143  	 sosl_log.full_log( p_message => 'sosl_api.has_scripts queue check p_identifier: ' || p_identifier
144  			  , p_log_type => sosl_sys.INFO_TYPE
145  			  , p_log_category => l_category
146  			  , p_caller => l_caller
147  			  )
148  	 ;
149  	 SELECT COUNT(*)
150  	   INTO l_has_queue
151  	   FROM user_objects
152  	  WHERE object_name = UPPER(p_identifier)
153  	    AND object_type = 'TABLE'
154  	 ;
155  	 IF l_has_queue = 0
156  	 THEN
157  	   sosl_log.full_log( p_message => 'The given queue table name does not exist in the current user schema: "' || UPPER(p_identifier) || '". Return 0 scripts waiting.'
158  			    , p_log_type => sosl_sys.ERROR_TYPE
159  			    , p_log_category => l_category
160  			    , p_caller => l_caller
161  			    )
162  	   ;
163  	   l_return := 0;
164  	 ELSE
165  	   BEGIN
166  	     EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_identifier INTO l_return;
167  	   EXCEPTION
168  	     WHEN OTHERS THEN
169  	       sosl_log.full_log( p_message => 'Unhandled exception in sosl_api.has_scripts for queue function checking queue table: ' || SQLERRM
170  				, p_log_type => sosl_sys.FATAL_TYPE
171  				, p_log_category => l_category
172  				, p_caller => l_caller
173  				)
174  	       ;
175  	       l_return := -1;
176  	   END;
177  	 END IF;
178  	 RETURN l_return;
179    EXCEPTION
180  	 WHEN OTHERS THEN
181  	   -- log the error instead of RAISE
182  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl_api.has_scripts for queue function: ' || SQLERRM
183  			    , p_log_type => sosl_sys.FATAL_TYPE
184  			    , p_log_category => l_category
185  			    , p_caller => l_caller
186  			    )
187  	   ;
188  	   RETURN -1;
189    END has_scripts;
190  
191    FUNCTION has_scripts_for_fn(p_fn_has_scripts IN VARCHAR2)
192  	 RETURN NUMBER
193    IS
194  	 l_has_function  NUMBER;
195  	 l_return	 NUMBER;
196  	 l_fn_valid	 BOOLEAN;
197  	 l_fn_call	 sosl_executor.fn_has_scripts%TYPE;
198  	 l_category	 sosl_server_log.log_category%TYPE   := 'HAS_SCRIPTS';
199  	 l_caller	 sosl_server_log.caller%TYPE	     := 'sosl_api.has_scripts_for_fn';
200  	 CURSOR cur_fn_owner(cp_fn_name IN VARCHAR2)
201  	 IS
202  	   SELECT function_owner
203  	     FROM sosl_executor
204  	    WHERE UPPER(fn_has_scripts) = UPPER(cp_fn_name)
205  	      AND executor_active	= 1
206  	      AND executor_reviewed	= 1
207  	    GROUP BY function_owner
208  	 ;
209    BEGIN
210  	 l_return  := -1;
211  	 sosl_log.full_log( p_message => 'sosl_api.has_scripts_for_fn defined function check p_fn_has_scripts: ' || p_fn_has_scripts
212  			  , p_log_type => sosl_sys.INFO_TYPE
213  			  , p_log_category => l_category
214  			  , p_caller => l_caller
215  			  )
216  	 ;
217  	 SELECT COUNT(*)
218  	   INTO l_has_function
219  	   FROM sosl_executor
220  	  WHERE UPPER(fn_has_scripts) = UPPER(p_fn_has_scripts)
221  	    AND executor_active       = 1
222  	    AND executor_reviewed     = 1
223  	 ;
224  	 IF l_has_function = 0
225  	 THEN
226  	   sosl_log.full_log( p_message => 'The given function name does not have an active and reviewed executor: "' || UPPER(p_fn_has_scripts) || '". Return 0 scripts waiting.'
227  			    , p_log_type => sosl_sys.ERROR_TYPE
228  			    , p_log_category => l_category
229  			    , p_caller => l_caller
230  			    )
231  	   ;
232  	   l_return := 0;
233  	 ELSE
234  	   -- check function owner, to verify function exists
235  	   l_fn_valid := FALSE;
236  	   FOR rec IN cur_fn_owner(p_fn_has_scripts)
237  	   LOOP
238  	     IF sosl_sys.has_function(rec.function_owner, UPPER(p_fn_has_scripts), 'NUMBER')
239  	     THEN
240  	       l_fn_valid := TRUE;
241  	       EXIT;
242  	     END IF;
243  	   END LOOP;
244  	   IF l_fn_valid
245  	   THEN
246  	     BEGIN
247  	       EXECUTE IMMEDIATE p_fn_has_scripts INTO l_return;
248  	     EXCEPTION
249  	       WHEN OTHERS THEN
250  		 sosl_log.full_log( p_message => 'Unhandled exception in sosl_api.has_scripts_for_fn for calling defined function: ' || p_fn_has_scripts || ' Error: ' || SQLERRM
251  				  , p_log_type => sosl_sys.FATAL_TYPE
252  				  , p_log_category => l_category
253  				  , p_caller => l_caller
254  				  )
255  		 ;
256  		 l_return := -1;
257  	     END;
258  	   ELSE
259  	     sosl_log.full_log( p_message => 'The given function ' || p_fn_has_scripts || ' is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL. Return 0 scripts waiting.'
260  			      , p_log_type => sosl_sys.ERROR_TYPE
261  			      , p_log_category => l_category
262  			      , p_caller => l_caller
263  			      )
264  	     ;
265  	     l_return := 0;
266  	   END IF;
267  	 END IF;
268  	 RETURN l_return;
269    EXCEPTION
270  	 WHEN OTHERS THEN
271  	   -- log the error instead of RAISE
272  	   sosl_log.full_log( p_message => 'Unhandled exception in sosl_api.has_scripts_for_fn function: ' || SQLERRM
273  			    , p_log_type => sosl_sys.FATAL_TYPE
274  			    , p_log_category => l_category
275  			    , p_caller => l_caller
276  			    )
277  	   ;
278  	   RETURN -1;
279    END has_scripts_for_fn;
280  
281    FUNCTION get_next_script
282  	 RETURN SOSL_PAYLOAD
283    IS
284    BEGIN
285  	 RETURN NULL;
286    END get_next_script;
287  
288    FUNCTION set_config( p_config_name  IN VARCHAR2
289  			  , p_config_value IN VARCHAR2
290  			  )
291  	 RETURN NUMBER
292    IS
293    BEGIN
294  	 RETURN NULL;
295    END set_config;
296  
297    FUNCTION get_config(p_config_name IN VARCHAR2)
298  	 RETURN VARCHAR2
299    IS
300    BEGIN
301  	 RETURN NULL;
302    END get_config;
303  
304    FUNCTION base_path(p_run_id IN NUMBER)
305  	 RETURN VARCHAR2
306    IS
307    BEGIN
308  	 RETURN NULL;
309    END base_path;
310  
311    FUNCTION cfg_path(p_run_id IN NUMBER)
312  	 RETURN VARCHAR2
313    IS
314    BEGIN
315  	 RETURN NULL;
316    END cfg_path;
317  
318    FUNCTION tmp_path(p_run_id IN NUMBER)
319  	 RETURN VARCHAR2
320    IS
321    BEGIN
322  	 RETURN NULL;
323    END tmp_path;
324  
325    FUNCTION log_path(p_run_id IN NUMBER)
326  	 RETURN VARCHAR2
327    IS
328    BEGIN
329  	 RETURN NULL;
330    END log_path;
331  
332  END;
333  /

Package body created.

SQL> @@../sosl_ddl/packages/sosl.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- main package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl
  2  AS
  3    /**
  4    * This package contains the internal interface to SOSL used by the Simple Oracle Script Loader.
  5    * Can be seen as tutorial and implementation hint for own interfaces.
  6    */
  7  
  8    /** Function SOSL.HAS_SCRIPTS
  9    * Determines if script ids are available to be executed. To be defined in SOSL_EXECUTOR.
 10    *
 11    * @return The number of script ids waiting for execution.
 12    */
 13    FUNCTION has_scripts
 14  	 RETURN NUMBER
 15    ;
 16  
 17    /** Function SOSL.GET_NEXT_SCRIPT
 18    * Returns the next script id to execute. To be defined in SOSL_EXECUTOR.
 19    *
 20    * @return The id of the next script to execute.
 21    */
 22    FUNCTION get_next_script
 23  	 RETURN SOSL_PAYLOAD
 24    ;
 25  
 26    /** Function SOSL.SET_SCRIPT_STATUS
 27    * Sets the status of a script. To be defined in SOSL_EXECUTOR.
 28    *
 29    * @param p_reference The reference to the script to update as SOSL_PAYLOAD containing executor_id, ext_script_id and script_file.
 30    * @param p_status The status for the script to set. Status: 0 WAITING, 1 PREPARING, 2 ENQUEUED, 3 RUNNING, 4 SUCCESS, 5 ERROR.
 31    * @param p_status_msg An optional message related to current status change, like error messages. SOSL will provide the identifier of SOSLERRORLOG in case of errors.
 32    *
 33    * @return 0 on success, -1 on errors.
 34    */
 35    FUNCTION set_script_status( p_reference	 IN SOSL_PAYLOAD
 36  				 , p_status	 IN NUMBER
 37  				 , p_status_msg  IN VARCHAR2 DEFAULT NULL
 38  				 )
 39  	 RETURN NUMBER
 40    ;
 41  
 42  END;
 43  /

Package created.

SQL> @@../sosl_ddl/packages/sosl.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE PACKAGE BODY sosl
  2  AS
  3    -- see package header for documentation
  4    FUNCTION has_scripts
  5  	 RETURN NUMBER
  6    IS
  7    BEGIN
  8  	 RETURN -1;
  9    END has_scripts;
 10  
 11    FUNCTION get_next_script
 12  	 RETURN SOSL_PAYLOAD
 13    IS
 14    BEGIN
 15  	 RETURN NULL;
 16    END get_next_script;
 17  
 18    FUNCTION set_script_status( p_reference	 IN SOSL_PAYLOAD
 19  				 , p_status	 IN NUMBER
 20  				 , p_status_msg  IN VARCHAR2 DEFAULT NULL
 21  				 )
 22  	 RETURN NUMBER
 23    IS
 24    BEGIN
 25  	 RETURN -1;
 26    END set_script_status;
 27  
 28  END;
 29  /

Package body created.

SQL> -- wrapper functions
SQL> @@../sosl_ddl/functions/has_scripts.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE FUNCTION has_scripts
  2    RETURN NUMBER
  3  IS
  4    /* Wrapper function for defined executor has_scripts functions.
  5    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
  6    * return a number greater 0. Will log all functions in error.
  7    *
  8    * @return The amount of scripts waiting for all valid executor has_scripts functions or -1 if all functions have errors.
  9    */
 10    l_return    NUMBER;
 11    l_category  sosl_server_log.log_category%TYPE := 'HAS_SCRIPTS';
 12    l_caller    sosl_server_log.caller%TYPE	     := 'has_scripts wrapper';
 13  BEGIN
 14    l_return := sosl_api.has_scripts;
 15    RETURN l_return;
 16  EXCEPTION
 17    WHEN OTHERS THEN
 18  	 -- log the error instead of RAISE
 19  	 sosl_log.full_log( p_message => 'Unhandled exception in HAS_SCRIPTS wrapper function: ' || SQLERRM
 20  			  , p_log_type => sosl_sys.FATAL_TYPE
 21  			  , p_log_category => l_category
 22  			  , p_caller => l_caller
 23  			  )
 24  	 ;
 25  	 RETURN -1;
 26  END;
 27  /

Function created.

SQL> -- ==============INSTALL done==============
SQL> @@../sosl_sql/util/log_silent.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> SET ECHO OFF
SUCCESS - no errors found during setup          0
