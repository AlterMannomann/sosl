SQL> @@../sosl_ddl/tables/soslerrorlog.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE TABLE soslerrorlog
  2    ( username    VARCHAR2(256)
  3    , timestamp   TIMESTAMP
  4  	 -- older versions than Oracle 23 use VARCHAR2(1024)
  5    , script      CLOB	   -- VARCHAR2(1024)
  6    , identifier  VARCHAR2(256)
  7    , message     CLOB
  8    , statement   CLOB
  9    )
 10  ;

Table created.

SQL> COMMENT ON TABLE soslerrorlog IS 'Userdefined table for SQLPlus error logging';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.username IS 'Oracle account name';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.timestamp IS 'Time when the error occurred';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.script IS 'Name of the originating script if applicable';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.identifier IS 'User defined identifier string';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.message IS 'ORA, PLA or SP2 error message. No feed back messages are included. For example, "PL/SQL Block Created" is not recorded.';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.statement IS 'The statement causing the error';

Comment created.

SQL> -- package with no dependency on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_sys.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Basic sys util package not using data objects of the Simple Oracle Script Loader, no dependencies.
SQL> CREATE OR REPLACE PACKAGE sosl_sys
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader that have no dependencies on any SOSL object.
  5    * As there are no dependencies, exceptions must be catched or handled by the caller. No logging for this functions and procedures.
  6    */
  7  
  8    /*====================================== start package constants used by SOSL ======================================*/
  9    -- define log_type constants used in SOSL_SERVER_LOG
 10    ERROR_TYPE     CONSTANT CHAR(5) := 'ERROR';
 11    WARNING_TYPE   CONSTANT CHAR(7) := 'WARNING';
 12    FATAL_TYPE     CONSTANT CHAR(5) := 'FATAL';
 13    INFO_TYPE      CONSTANT CHAR(4) := 'INFO';
 14    SUCCESS_TYPE   CONSTANT CHAR(7) := 'SUCCESS';
 15    -- Generic n/a type. Should be different from table defaults like 'not set' as table triggers interpret their DDL default value as fallback
 16    -- to set default values using package variables, which is not supported in table DDL by Oracle using DEFAULT. Packages may use variables
 17    -- from other packages in DEFAULT declarations.
 18    NA_TYPE	      CONSTANT CHAR(3) := 'n/a';
 19    /*====================================== end package constants used by SOSL ======================================*/
 20  
 21    /*====================================== start internal functions made visible for testing ======================================*/
 22    /* PROCEDURE SPLIT_FUNCTION_NAME
 23    * Splits the given function name into its parts. Supposed delimiter is the point ".".
 24    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 25    * @param p_package OUT parameter, contains the package name if any or NULL.
 26    * @param p_function OUT parameter, contains the pure function name.
 27    */
 28    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
 29  				    , p_package       OUT VARCHAR2
 30  				    , p_function      OUT VARCHAR2
 31  				    )
 32    ;
 33    /*====================================== end internal functions made visible for testing ======================================*/
 34  
 35    /* FUNCTION HAS_DB_USER
 36    * Checks if a given user is visible for SOSL by checking ALL_USERS. Users must be visible to SOSL to be able to dynamically
 37    * grant the necessary rights on the API for script execution.
 38    *
 39    * @param p_username The database user name to check.
 40    *
 41    * @return TRUE if the user is visible in ALL_USERS to SOSL, otherwise FALSE.
 42    */
 43    FUNCTION has_db_user(p_username IN VARCHAR2)
 44  	 RETURN BOOLEAN
 45    ;
 46  
 47    /* FUNCTION HAS_FUNCTION
 48    * Checks if a given function or package function name is visible for SOSL by checking ALL_ATTRIBUTES.
 49    *
 50    * @param p_owner The owner of the function or package function name to check.
 51    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 52    * @param p_datatype The return datatype of the function expected, e.g. a valid Oracle datatype like NUMBER or VARCHAR2.
 53    *
 54    * @return TRUE if the function is visible in ALL_ATTRIBUTES to SOSL and has the required return datatype, otherwise FALSE.
 55    */
 56    FUNCTION has_function( p_owner	       IN VARCHAR2
 57  			    , p_function_name  IN VARCHAR2
 58  			    , p_datatype       IN VARCHAR2
 59  			    )
 60  	 RETURN BOOLEAN
 61    ;
 62  
 63    /* FUNCTION LOG_TYPE_VALID
 64    * Central function to check the log type. Currently supports INFO, WARNING, ERROR, FATAL, SUCCESS. If log types should get expanded
 65    * adjust this function first and probably the default value for SOSL_SERVER_LOG.
 66    *
 67    * @param p_log_type The log type to check. Case insensitive.
 68    *
 69    *@return TRUE if the given log type is supported. FALSE if not. Exceptions and errors will lead also to FALSE.
 70    */
 71    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 72  	 RETURN BOOLEAN
 73  	 DETERMINISTIC
 74  	 PARALLEL_ENABLE
 75    ;
 76  
 77    /* FUNCTION GET_VALID_LOG_TYPE
 78    * Verifies an given log type, returns either the given log type as upper case or the defined error default.
 79    *
 80    * @param p_log_type The log type to verify and return. Case insensitive.
 81    * @param p_error_default The alternative log type to return, if the log type is invalid. Must be a valid log type and not INFO or SUCCESS. If invalid, FATAL is returned.
 82    *
 83    * @return The valid log type as upper case on success. The valid error default if log type not supported. FATAL if the error default is invalid.
 84    */
 85    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 86  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_sys.ERROR_TYPE
 87  				  )
 88  	 RETURN VARCHAR2
 89  	 DETERMINISTIC
 90  	 PARALLEL_ENABLE
 91    ;
 92  
 93    /*FUNCTION GET_COL_LENGTH
 94    * Returns the column length for a given table and column or -1 if table or column does not exist from USER_TAB_COLUMNS using
 95    * DATA_LENGTH. DATA_LENGTH is misleading if not a char type or CLOB, as CLOB types report 4000 which is definitely wrong.
 96    * The only types handled are NUMBER and CLOB. All other types return the DATA_LENGTH.
 97    *
 98    * Length for numbers is calculated by adding precision and scale.
 99    *
100    * CLOB will return the PLSQL equation of a VARCHAR2/CLOB, which is 32767 and still wrong, but useful to see if a PLSQL can handle
101    * the CLOB. Be careful with CLOB handling. If source is not a table column, PLSQL most likely limits it to 32767 cutting longer content.
102    *
103    * Objects not in the current schema will not be considered and return -1 AS USER_TAB_COLUMN is used.
104    *
105    * No handling for date and timestamp values, as their char representation has too much dependencies on NLS and formatting to get a
106    * reliable length.
107    *
108    * Byte and char semantic is not considered only the effective chars that can be stored in CHAR or VARCHAR2 as defined by DATA_LENGTH.
109    *
110    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
111    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
112    *
113    * @return The calculated length of the column. Fix PLSQL limit 32767 for CLOB types. DATA_LENGTH for data and timestamp types.
114    */
115    FUNCTION get_col_length( p_table  IN VARCHAR2
116  			      , p_column IN VARCHAR2
117  			      )
118  	 RETURN INTEGER
119    ;
120  
121    /* FUNCTION GET_COL_TYPE
122    * Returns the type of a column from USER_TAB_COLUMNS as defined in DATA_TYPE or NA_TYPE if table or column doesn't exist.
123    * Objects not in the current schema will not be considered and return NA_TYPE.
124    *
125    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
126    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
127    *
128    * @return The type of the column as defined in DATA_TYPE or sosl_sys.NA_TYPE on errors or not found columns and tables.
129    */
130    FUNCTION get_col_type( p_table  IN VARCHAR2
131  			    , p_column IN VARCHAR2
132  			    )
133  	 RETURN VARCHAR2
134    ;
135  
136    /* FUNCTION DISTRIBUTE
137    * This functions distributes char data between a VARCHAR2 and a CLOB variable by the following rules:
138    * p_string empty or NULL: Fill p_string to p_max_string_length - p_split_end length.
139    * p_string length > p_max_string_length: Cut p_string to p_max_string_length, including p_split_end appended.
140    *	  p_clob NOT EMPTY: add split_start, rest of p_string before p_clob content.
141    *	  p_clob EMPTY: add split_start and rest of p_string.
142    * p_string length > 0 and < p_max_string_length: no change of p_string and p_clob.
143    * p_string and p_clob empty or NULL: leave unchanged, return FALSE otherwise always TRUE.
144    * In case of exceptions will try to write SQLERRM to p_string as CLOBs tend to be more error prone.
145    *
146    * @param p_string The string to distribute or check. In PLSQL strings can get 32767 chars long, whereas table columns are limited currently to 4000.
147    * @param p_clob The CLOB to distribute or check. Uses NOCOPY to guarantee that CLOB full length is used as given.
148    * @param p_max_string_length The maximum length p_string should have. If this size is exeeded the string gets distribute between p_string and p_clob.
149    * @param p_split_end The split end characters to indicate that the string is continued in p_clob.
150    * @param p_split_start The split start characters for the continuing string in the CLOB.
151    * @param p_delimiter The delimiter between rest of string in CLOB and original CLOB content, if both have content and string must be splitted.
152    *
153    * @return FALSE if p_string and p_clob are empty/NULL or an exception had occurred, otherwise TRUE.
154    */
155    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
156  			  , p_clob		IN OUT NOCOPY  CLOB
157  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
158  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
159  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
160  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
161  			  )
162  	 RETURN BOOLEAN
163    ;
164  
165    /* FUNCTION CHECK_COL
166    * This function can check NUMBER and VARCHAR2/CHAR columns for length and type. Passing a number for a char column type will result
167    * in FALSE. Providing a P_VALUE with a length longer than the length calculated, will result in FALSE. It will not consider
168    * implicite Oracle conversions. Expects type like defined.
169    *
170    * Number length is calculated by TO_CHAR string representation removing all delimiters and counting only numbers 0-9.
171    * Passing a VARCHAR2 value is valid for CHAR and VARCHAR2 column types.
172    *
173    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
174    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
175    * @param p_value The value for the table column to check against column definition.
176    *
177    * @return TRUE if value and column match in type and length, otherwise FALSE.
178    */
179    FUNCTION check_col( p_table  IN VARCHAR2
180  			 , p_column IN VARCHAR2
181  			 , p_value  IN VARCHAR2
182  			 )
183  	 RETURN BOOLEAN
184    ;
185    FUNCTION check_col( p_table  IN VARCHAR2
186  			 , p_column IN VARCHAR2
187  			 , p_value  IN NUMBER
188  			 )
189  	 RETURN BOOLEAN
190    ;
191  
192  END;
193  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_sys.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE PACKAGE BODY sosl_sys
  2  AS
  3    -- for description see header file
  4    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
  5  				    , p_package       OUT VARCHAR2
  6  				    , p_function      OUT VARCHAR2
  7  				    )
  8    IS
  9    BEGIN
 10  	 IF INSTR(p_function_name, '.') > 0
 11  	 THEN
 12  	   p_package   := TRIM(SUBSTR(p_function_name, 1, INSTR(p_function_name, '.') -1));
 13  	   p_function  := TRIM(SUBSTR(p_function_name, INSTR(p_function_name, '.') +1, INSTR(p_function_name, '.', 1, 2) - INSTR(p_function_name, '.') -1));
 14  	 ELSE
 15  	   p_package   := NULL;
 16  	   p_function  := TRIM(p_function_name);
 17  	 END IF;
 18    END split_function_name;
 19  
 20    FUNCTION has_db_user(p_username IN VARCHAR2)
 21  	 RETURN BOOLEAN
 22    IS
 23  	 l_has_user  NUMBER;
 24  	 l_return    BOOLEAN;
 25    BEGIN
 26  	 l_return := FALSE;
 27  	 SELECT COUNT(*) INTO l_has_user FROM all_users WHERE username = p_username;
 28  	 IF l_has_user != 0
 29  	 THEN
 30  	   l_return := TRUE;
 31  	 END IF;
 32  	 RETURN l_return;
 33    END has_db_user;
 34  
 35    FUNCTION has_function( p_owner	       IN VARCHAR2
 36  			    , p_function_name  IN VARCHAR2
 37  			    , p_datatype       IN VARCHAR2
 38  			    )
 39  	 RETURN BOOLEAN
 40    IS
 41  	 l_has_function  NUMBER;
 42  	 l_package	 VARCHAR2(128);
 43  	 l_function	 VARCHAR2(128);
 44  	 l_return	 BOOLEAN;
 45    BEGIN
 46  	 l_return := FALSE;
 47  	 sosl_sys.split_function_name(p_function_name, l_package, l_function);
 48  	 SELECT COUNT(*)
 49  	   INTO l_has_function
 50  	   FROM all_arguments
 51  	  WHERE position		   = 0				     -- only functions
 52  	    AND argument_name		   IS NULL			     -- only functions
 53  	    AND data_type		   = p_datatype
 54  	    AND owner			   = p_owner
 55  	    AND NVL(package_name, 'N/A')   = NVL(UPPER(l_package), 'N/A')    -- may not contain a package name
 56  	    AND object_name		   = UPPER(l_function)
 57  	 ;
 58  	 IF l_has_function != 0
 59  	 THEN
 60  	   l_return := TRUE;
 61  	 END IF;
 62  	 RETURN l_return;
 63    END has_function;
 64  
 65    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 66  	 RETURN BOOLEAN
 67  	 DETERMINISTIC
 68  	 PARALLEL_ENABLE
 69    IS
 70  	 l_return  BOOLEAN;
 71    BEGIN
 72  	 l_return := FALSE;
 73  	 IF UPPER(p_log_type) IN ( sosl_sys.INFO_TYPE
 74  				 , sosl_sys.WARNING_TYPE
 75  				 , sosl_sys.ERROR_TYPE
 76  				 , sosl_sys.FATAL_TYPE
 77  				 , sosl_sys.SUCCESS_TYPE
 78  				 )
 79  	 THEN
 80  	   l_return := TRUE;
 81  	 END IF;
 82  	 RETURN l_return;
 83    EXCEPTION
 84  	 WHEN OTHERS THEN
 85  	   RETURN FALSE;
 86    END log_type_valid;
 87  
 88    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 89  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_sys.ERROR_TYPE
 90  				  )
 91  	 RETURN VARCHAR2
 92  	 DETERMINISTIC
 93  	 PARALLEL_ENABLE
 94    IS
 95  	 l_return  VARCHAR2(30);
 96    BEGIN
 97  	 l_return := sosl_sys.FATAL_TYPE;
 98  	 IF log_type_valid(p_log_type)
 99  	 THEN
100  	   l_return := UPPER(p_log_type);
101  	 ELSE
102  	   IF	   log_type_valid(p_error_default)
103  	      AND  UPPER(p_error_default) NOT IN ( sosl_sys.INFO_TYPE
104  						 , sosl_sys.SUCCESS_TYPE
105  						 )
106  	   THEN
107  	     l_return := UPPER(p_error_default);
108  	   END IF;
109  	 END IF;
110  	 RETURN l_return;
111    EXCEPTION
112  	 WHEN OTHERS THEN
113  	   RETURN sosl_sys.FATAL_TYPE;
114    END get_valid_log_type;
115  
116    FUNCTION get_col_length( p_table  IN VARCHAR2
117  			      , p_column IN VARCHAR2
118  			      )
119  	 RETURN INTEGER
120    IS
121  	 l_return	   INTEGER;
122  	 l_has_column	   INTEGER;
123  	 l_data_type	   user_tab_columns.data_type%TYPE;
124  	 l_data_length	   user_tab_columns.data_length%TYPE;
125  	 l_data_precision  user_tab_columns.data_precision%TYPE;
126  	 l_data_scale	   user_tab_columns.data_scale%TYPE;
127    BEGIN
128  	 l_return := -1;
129  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
130  	 IF l_has_column = 1
131  	 THEN
132  	   -- column match calculate length
133  	   SELECT data_type
134  		, data_length
135  		, data_precision
136  		, data_scale
137  	     INTO l_data_type
138  		, l_data_length
139  		, l_data_precision
140  		, l_data_scale
141  	     FROM user_tab_columns
142  	    WHERE table_name  = UPPER(p_table)
143  	      AND column_name = UPPER(p_column)
144  	   ;
145  	   IF l_data_type = 'NUMBER'
146  	   THEN
147  	     IF l_data_scale != 0
148  	     THEN
149  	       -- consider delimiter
150  	       l_return := l_data_precision + l_data_scale;
151  	     ELSE
152  	       l_return := l_data_precision;
153  	     END IF;
154  	   ELSIF l_data_type = 'CLOB'
155  	   THEN
156  	     l_return := 32767;
157  	   ELSE
158  	     l_return := l_data_length;
159  	   END IF;
160  	 END IF;
161  	 RETURN l_return;
162    EXCEPTION
163  	 WHEN OTHERS THEN
164  	   RETURN -1;
165    END get_col_length;
166  
167    FUNCTION get_col_type( p_table  IN VARCHAR2
168  			    , p_column IN VARCHAR2
169  			    )
170  	 RETURN VARCHAR2
171    IS
172  	 l_return      VARCHAR2(128);
173  	 l_has_column  INTEGER;
174  	 l_data_type   user_tab_columns.data_type%TYPE;
175    BEGIN
176  	 l_return := sosl_sys.NA_TYPE;
177  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
178  	 IF l_has_column = 1
179  	 THEN
180  	   -- column match get data type
181  	   SELECT data_type
182  	     INTO l_return
183  	     FROM user_tab_columns
184  	    WHERE table_name  = UPPER(p_table)
185  	      AND column_name = UPPER(p_column)
186  	   ;
187  	 END IF;
188  	 RETURN l_return;
189    EXCEPTION
190  	 WHEN OTHERS THEN
191  	   RETURN sosl_sys.NA_TYPE;
192    END get_col_type;
193  
194    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
195  			  , p_clob		IN OUT NOCOPY  CLOB
196  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
197  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
198  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
199  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
200  			  )
201  	 RETURN BOOLEAN
202    IS
203  	 l_string  VARCHAR2(32767);
204    BEGIN
205  	 IF	(p_string IS NULL OR NVL(LENGTH(TRIM(p_string)), 0) = 0)
206  	    AND (p_clob   IS NULL OR NVL(LENGTH(TRIM(p_clob)), 0) = 0)
207  	 THEN
208  	   RETURN FALSE;
209  	 END IF;
210  	 IF	p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
211  	    AND p_clob	 IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
212  	 THEN
213  	   IF LENGTH(p_string) > p_max_string_length
214  	   THEN
215  	     -- need to split
216  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1)) || p_delimiter;
217  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
218  	     p_clob   := l_string || p_clob;
219  	   END IF;
220  	   RETURN TRUE;
221  	 END IF;
222  	 IF p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
223  	 THEN
224  	   IF LENGTH(p_string) > p_max_string_length
225  	   THEN
226  	     -- need to split
227  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1));
228  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
229  	     p_clob   := TO_CLOB(l_string);
230  	   ELSE
231  	     p_clob := TO_CLOB(l_string);
232  	   END IF;
233  	   RETURN TRUE;
234  	 END IF;
235  	 IF p_clob IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
236  	 THEN
237  	   IF LENGTH(p_clob) > p_max_string_length
238  	   THEN
239  	     p_string := TO_CHAR(SUBSTR(p_clob, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end);
240  	   ELSE
241  	     p_string := TO_CHAR(p_clob);
242  	   END IF;
243  	   RETURN TRUE;
244  	 END IF;
245  	 -- should not reach this point
246  	 p_string := 'ERROR sosl_sys.distribute: INCOMPLETE LOGIC';
247  	 RETURN FALSE;
248    EXCEPTION
249  	 WHEN OTHERS THEN
250  	   p_string := TRIM(SUBSTR(SQLERRM, 1, 4000));
251  	   RETURN FALSE;
252    END distribute;
253  
254    FUNCTION check_col( p_table  IN VARCHAR2
255  			 , p_column IN VARCHAR2
256  			 , p_value  IN VARCHAR2
257  			 )
258  	 RETURN BOOLEAN
259    IS
260  	 l_return  BOOLEAN;
261    BEGIN
262  	 l_return := FALSE;
263  	 IF sosl_sys.get_col_type(p_table, p_column) IN ('VARCHAR2', 'CHAR')
264  	 THEN
265  	   IF NVL(LENGTH(p_value), 0) <= sosl_sys.get_col_length(p_table, p_column)
266  	   THEN
267  	     l_return := TRUE;
268  	   END IF;
269  	 END IF;
270  	 RETURN l_return;
271    END check_col; -- VARCHAR2 variant
272  
273    FUNCTION check_col( p_table  IN VARCHAR2
274  			 , p_column IN VARCHAR2
275  			 , p_value  IN NUMBER
276  			 )
277  	 RETURN BOOLEAN
278    IS
279  	 l_return  BOOLEAN;
280  	 l_number  VARCHAR2(128);
281    BEGIN
282  	 l_return := FALSE;
283  	 IF sosl_sys.get_col_type(p_table, p_column) = 'NUMBER'
284  	 THEN
285  	   l_number := REGEXP_REPLACE(TO_CHAR(p_value), '[^0-9]', '');
286  	   IF NVL(LENGTH(l_number), 0) <= sosl_sys.get_col_length(p_table, p_column)
287  	   THEN
288  	     l_return := TRUE;
289  	   END IF;
290  	 END IF;
291  	 RETURN l_return;
292    END check_col; -- NUMBER variant
293  
294  END;
295  /

Package body created.

SQL> -- logging table
SQL> @@../sosl_ddl/tables/sosl_server_log.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_server_log
  2    ( exec_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP 		     NOT NULL
  3  	 -- due to Oracle limitations we must use trigger not a package variable, trigger takes care to assign a default INFO log type if getting 'not set'
  4    , log_type	   VARCHAR2(30)    DEFAULT 'not set'			     NOT NULL
  5    , log_category	   VARCHAR2(256)   DEFAULT 'not set'			     NOT NULL
  6    , message	   VARCHAR2(4000)					     NOT NULL
  7    , run_id 	   NUMBER(38, 0)
  8    , executor_id	   NUMBER(38, 0)
  9    , guid		   VARCHAR2(64)
 10    , sosl_identifier   VARCHAR2(256)
 11    , caller 	   VARCHAR2(256)
 12    , ext_script_id	   VARCHAR2(4000)
 13    , script_file	   VARCHAR2(4000)
 14    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 15    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 16    , full_message	   CLOB
 17    )
 18    -- monthly partitions
 19    PARTITION BY RANGE (exec_timestamp)
 20    INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
 21    (PARTITION P_OLD
 22  	   VALUES LESS THAN (TO_TIMESTAMP('01-01-2024','DD-MM-YYYY'))
 23    )
 24  ;

Table created.

SQL> COMMENT ON TABLE sosl_server_log IS 'Holds the log events of the SOSL server CMD and interaction with the database as well as database events. Update is not allowed. Will use the alias slog.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.exec_timestamp IS 'The timestamp of the event. Automatically set by trigger, no set allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_type IS 'The logging type, supports currently INFO, WARNING, ERROR, FATAL, SUCCESS. Mandatory. Defined in package SOSL_SYS.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_category IS 'The log writer may provide an short log category description.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.message IS 'The shortend log message. Mandatory. If only a CLOB is passed, the short message is build from the CLOB. Categories too long will be cutted.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.full_message IS 'The full log message. For messages longer than 4000 bytes or char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.guid IS 'The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.sosl_identifier IS 'The exact identifier for SOSLERRORLOG if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.run_id IS 'The associated run id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.executor_id IS 'The associated executor id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.ext_script_id IS 'The (external) script id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.caller IS 'Caller identification if available, to distinguish database processes from SOSL CMD server processes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by IS 'The logged in DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- no primary key, only index
SQL> CREATE INDEX sosl_server_log_idx
  2    ON sosl_server_log (exec_timestamp, log_type, log_category)
  3  ;

Index created.

SQL> -- no constraints, as Oracle does not allow package functions in CHECK conditions
SQL> 
SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_server_log_ins_trg
  2    BEFORE INSERT ON sosl_server_log
  3    FOR EACH ROW
  4  DECLARE
  5    l_split BOOLEAN;
  6  BEGIN
  7    -- first set default value if not set, as Oracle does not support default values from package variables
  8    IF :NEW.log_type = 'not set'
  9    THEN
 10  	 :NEW.log_type := sosl_sys.INFO_TYPE;
 11    END IF;
 12    -- instead of check constraint to get package support
 13    IF NOT sosl_sys.log_type_valid(:NEW.log_type)
 14    THEN
 15  	 -- do not block logging, log the error instead, move message to full message
 16  	 :NEW.full_message := :NEW.message || :NEW.full_message;
 17  	 :NEW.message	   := 'Invalid log type. Not supported by package SOSL_SYS. Given log type: ' || :NEW.log_type;
 18  	 :NEW.log_type	   := sosl_sys.FATAL_TYPE;
 19    ELSE
 20  	 :NEW.log_type := sosl_sys.get_valid_log_type(:NEW.log_type);
 21    END IF;
 22    :NEW.exec_timestamp := SYSTIMESTAMP;
 23    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 24    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 25    -- split messages
 26    IF NOT sosl_sys.distribute(:NEW.message, :NEW.full_message, 4000)
 27    THEN
 28  	 -- do not block logging, log the error instead, if :NEW.message contains error information leave it there
 29  	 IF :NEW.message IS NULL AND :NEW.full_message IS NULL
 30  	 THEN
 31  	   :NEW.message := 'Full message must be given, if message is NULL or vice versa.';
 32  	 END IF;
 33  	 :NEW.log_type := sosl_sys.FATAL_TYPE;
 34    END IF;
 35  END;
 36  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_upd_trg
  2    BEFORE UPDATE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20005, 'No updates allowed on a log table.');
  6  END;
  7  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_del_trg
  2    BEFORE DELETE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20006, 'Delete records from a log table is not allowed. This is an admin job which needs sufficient rights.');
  6  END;
  7  /

Trigger created.

SQL> -- logging package
SQL> @@../sosl_ddl/packages/sosl_log.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Basic logging package, dependencies only to sosl_server_log.
SQL> CREATE OR REPLACE PACKAGE sosl_log
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader for managing logging.
  5    * Apart from sosl_server_log table, there are no dependencies, severe exceptions must be catched or handled by the caller.
  6    * The interface has as well functions and procedures. Functions inform about success or error, whereas procedure exceptions
  7    * must be handled by the caller.
  8    *
  9    * CURRENT ORACLE error: NOCOPY for IN parameters creates compile errors, whereas documentation allows IN NOCOPY var. Any
 10    * CLOB handling errors are possibly caused by the inability to provide a CLOB as reference.
 11    */
 12  
 13    /*====================================== start internal functions made visible for testing ======================================*/
 14    /* PROCEDURE LOG_FALLBACK
 15    * This procedure tries some fallback actions, if logging raised an exception. It will not throw an exception. It will try to log the error in
 16    * SOSL_SERVER_LOG, SOSLERRORLOG, SPERRORLOG or, if everything fails output the error via DBMS_OUTPUT. As we can't determine if the message contains
 17    * an illegal character forcing the exception, the caller should transfer SQLERRM and verify the transmitted content before passing it to this procedure
 18    * or avoid transmitting parameters which should cause errors. If error could be logged to one of the tables, it can be found in this tables with
 19    * identifier SOSL_LOG. It will not prevent the exception, only try to log it somewhere, where it could be found without needing to analyze the db server
 20    * logs. Everything runs as autonomous transaction. DO NOT USE THIS PROCEDURE. It is internal for this package.
 21    *
 22    * @param p_script The package function or procedure causing the error, e.g. SOSL_LOG.LOG_EVENT.
 23    * @param p_identifier The identifier for this error. Saved in SOSL_IDENTIFIER in SOSL_SERVER_LOG or IDENTIFIER in the error log tables.
 24    * @param p_message The message to save. Reduce it to SQLERRM if possible.
 25    */
 26    PROCEDURE log_fallback( p_script      IN VARCHAR2
 27  			     , p_identifier  IN VARCHAR2
 28  			     , p_message     IN VARCHAR2
 29  			     )
 30    ;
 31    /* PROCEDURE LOG_EVENT
 32    * Writes a log entry as autonomous transaction. This is the internal base procedure, exposed for testing.
 33    * If on errors writing log entries is not possible the procedure hands the exception to the caller. This is the pure insert without
 34    * any checks. It takes the values as given and table may trigger exceptions. DO NOT USE THIS PROCEDURE. It is internal for this package.
 35    *
 36    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 37    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Must be valid.
 38    * @param p_log_category An optional logging category.
 39    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 40    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 41    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 42    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 43    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 44    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 45    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 46    */
 47    PROCEDURE log_event( p_message	       IN VARCHAR2
 48  			  , p_log_type	       IN VARCHAR2
 49  			  , p_log_category     IN VARCHAR2
 50  			  , p_guid	       IN VARCHAR2
 51  			  , p_sosl_identifier  IN VARCHAR2
 52  			  , p_executor_id      IN NUMBER
 53  			  , p_ext_script_id    IN VARCHAR2
 54  			  , p_caller	       IN VARCHAR2
 55  			  , p_run_id	       IN NUMBER
 56  			  , p_full_message     IN CLOB
 57  			  )
 58    ;
 59  /*====================================== end internal functions made visible for testing ======================================*/
 60  
 61    /* PROCEDURE FULL_LOG
 62    * Procedure with all parameters for logging. Will check parameters before logging. You should at least set also p_log_category
 63    * and p_caller, to be able to assign the log entry to a specific event and object. On parameter errors a separate log entry is
 64    * created. Intention is to write a log in any case and not throw any exception. This still may happen on main system malfunctions
 65    * but is limited to this events.
 66    *
 67    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 68    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Will be set to ERROR if not valid.
 69    * @param p_log_category An optional logging category.
 70    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 71    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 72    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 73    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 74    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 75    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 76    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 77    */
 78    PROCEDURE full_log( p_message	      IN VARCHAR2
 79  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_sys.INFO_TYPE
 80  			 , p_log_category     IN VARCHAR2    DEFAULT NULL
 81  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
 82  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
 83  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
 84  			 , p_executor_id      IN NUMBER      DEFAULT NULL
 85  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
 86  			 , p_run_id	      IN NUMBER      DEFAULT NULL
 87  			 , p_full_message     IN CLOB	     DEFAULT NULL
 88  			 )
 89    ;
 90  
 91    PROCEDURE cmd_log( p_message	     IN VARCHAR2
 92  			, p_log_type	     IN VARCHAR2     DEFAULT sosl_sys.INFO_TYPE
 93  			, p_caller	     IN VARCHAR2     DEFAULT NULL
 94  			, p_guid	     IN VARCHAR2     DEFAULT NULL
 95  			, p_sosl_identifier  IN VARCHAR2     DEFAULT NULL
 96  			, p_executor_id      IN NUMBER	     DEFAULT NULL
 97  			, p_ext_script_id    IN VARCHAR2     DEFAULT NULL
 98  			, p_full_message     IN CLOB	     DEFAULT NULL
 99  			)
100    ;
101  
102  END;
103  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_log.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE OR REPLACE PACKAGE BODY sosl_log
  2  AS
  3    -- for description see header file
  4    PROCEDURE log_fallback( p_script      IN VARCHAR2
  5  			     , p_identifier  IN VARCHAR2
  6  			     , p_message     IN VARCHAR2
  7  			     )
  8    IS
  9  	 PRAGMA AUTONOMOUS_TRANSACTION;
 10  	 l_saved BOOLEAN;
 11    BEGIN
 12  	 l_saved := FALSE;
 13  	 -- try to save information in tables probably available
 14  	 BEGIN
 15  	   INSERT INTO sosl_server_log
 16  	     ( message
 17  	     , log_type
 18  	     , log_category
 19  	     , sosl_identifier
 20  	     , caller
 21  	     )
 22  	     VALUES
 23  	       ( p_message
 24  	       , sosl_sys.FATAL_TYPE
 25  	       , 'SOSL_LOG internal error'
 26  	       , p_identifier
 27  	       , p_script
 28  	       )
 29  	   ;
 30  	   COMMIT;
 31  	   l_saved := TRUE;
 32  	 EXCEPTION
 33  	   WHEN OTHERS THEN
 34  	     l_saved := FALSE;
 35  	 END;
 36  	 IF NOT l_saved
 37  	 THEN
 38  	   BEGIN
 39  	     INSERT INTO soslerrorlog
 40  	       ( message
 41  	       , identifier
 42  	       , script
 43  	       , username
 44  	       , timestamp
 45  	       )
 46  	       VALUES
 47  		 ( p_message
 48  		 , p_identifier
 49  		 , p_script
 50  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 51  		 , SYSTIMESTAMP
 52  		 )
 53  	     ;
 54  	     COMMIT;
 55  	     l_saved := TRUE;
 56  	   EXCEPTION
 57  	     WHEN OTHERS THEN
 58  	       l_saved := FALSE;
 59  	   END;
 60  	 END IF;
 61  	 IF NOT l_saved
 62  	 THEN
 63  	   BEGIN
 64  	     INSERT INTO sperrorlog
 65  	       ( message
 66  	       , identifier
 67  	       , script
 68  	       , username
 69  	       , timestamp
 70  	       )
 71  	       VALUES
 72  		 ( p_message
 73  		 , p_identifier
 74  		 , p_script
 75  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 76  		 , SYSTIMESTAMP
 77  		 )
 78  	     ;
 79  	     COMMIT;
 80  	     l_saved := TRUE;
 81  	   EXCEPTION
 82  	     WHEN OTHERS THEN
 83  	       l_saved := FALSE;
 84  	   END;
 85  	 END IF;
 86  	 -- all inserts failed, use DBMS_OUTPUT
 87  	 IF NOT l_saved
 88  	 THEN
 89  	   BEGIN
 90  	     DBMS_OUTPUT.PUT_LINE('Fatal error in ' || p_script || ' error: ' || p_message);
 91  	   EXCEPTION
 92  	     WHEN OTHERS THEN
 93  	       NULL;
 94  	   END;
 95  	 END IF;
 96    EXCEPTION
 97  	 WHEN OTHERS THEN
 98  	   -- do exactly nothing to avoid an additional exception on database malfunction
 99  	   NULL;
100    END log_fallback;
101  
102    PROCEDURE log_event( p_message	       IN VARCHAR2
103  			  , p_log_type	       IN VARCHAR2
104  			  , p_log_category     IN VARCHAR2
105  			  , p_guid	       IN VARCHAR2
106  			  , p_sosl_identifier  IN VARCHAR2
107  			  , p_executor_id      IN NUMBER
108  			  , p_ext_script_id    IN VARCHAR2
109  			  , p_caller	       IN VARCHAR2
110  			  , p_run_id	       IN NUMBER
111  			  , p_full_message     IN CLOB
112  			  )
113    IS
114  	 PRAGMA AUTONOMOUS_TRANSACTION;
115    BEGIN
116  	 INSERT INTO sosl_server_log
117  	   ( message
118  	   , log_type
119  	   , log_category
120  	   , guid
121  	   , sosl_identifier
122  	   , executor_id
123  	   , ext_script_id
124  	   , caller
125  	   , run_id
126  	   , full_message
127  	   )
128  	   VALUES
129  	     ( p_message
130  	     , p_log_type
131  	     , p_log_category
132  	     , p_guid
133  	     , p_sosl_identifier
134  	     , p_executor_id
135  	     , p_ext_script_id
136  	     , p_caller
137  	     , p_run_id
138  	     , p_full_message
139  	     )
140  	 ;
141  	 COMMIT;
142    EXCEPTION
143  	 WHEN OTHERS THEN
144  	   -- use fallback
145  	   log_fallback('SOSL_LOG.LOG_EVENT', 'SOSL_LOG', SQLERRM);
146  	   -- try ROLLBACK
147  	   ROLLBACK;
148  	   -- and raise the error again now
149  	   RAISE;
150    END log_event;
151  
152    PROCEDURE full_log( p_message	      IN VARCHAR2
153  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_sys.INFO_TYPE
154  			 , p_log_category     IN VARCHAR2    DEFAULT NULL
155  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
156  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
157  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
158  			 , p_executor_id      IN NUMBER      DEFAULT NULL
159  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
160  			 , p_run_id	      IN NUMBER      DEFAULT NULL
161  			 , p_full_message     IN CLOB	     DEFAULT NULL
162  			 )
163    IS
164  	 -- set variables to current type
165  	 l_log_category    sosl_server_log.log_category%TYPE;
166  	 l_caller	   sosl_server_log.caller%TYPE;
167  	 l_guid 	   sosl_server_log.guid%TYPE;
168  	 l_sosl_identifier sosl_server_log.sosl_identifier%TYPE;
169  	 l_executor_id	   sosl_server_log.executor_id%TYPE;
170  	 l_ext_script_id   sosl_server_log.ext_script_id%TYPE;
171  	 l_run_id	   sosl_server_log.run_id%TYPE;
172    BEGIN
173  	 -- we leave info type and message splitting to be handled by table trigger, only check other parameters for type and length.
174  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'LOG_CATEGORY', p_log_category)
175  	 THEN
176  	   -- write extra log entry and cut original content to limit
177  	   log_event( p_message => 'p_log_category length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
178  		    , p_log_type => sosl_sys.FATAL_TYPE
179  		    , p_log_category => 'LOG USAGE ERROR'
180  		    , p_full_message => (p_message || ' - ' || p_full_message)
181  		    )
182  	   ;
183  	   l_log_category := SUBSTR(p_log_category, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'LOG_CATEGORY'));
184  	 ELSE
185  	   l_log_category := p_log_category;
186  	 END IF;
187  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'CALLER', p_caller)
188  	 THEN
189  	   -- write extra log entry and cut original content to limit
190  	   log_event( p_message => 'p_caller length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
191  		    , p_log_type => sosl_sys.FATAL_TYPE
192  		    , p_log_category => 'LOG USAGE ERROR'
193  		    , p_full_message => (p_message || ' - ' || p_full_message)
194  		    )
195  	   ;
196  	   l_caller := SUBSTR(p_caller, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'CALLER'));
197  	 ELSE
198  	   l_caller := p_caller;
199  	 END IF;
200  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'GUID', p_guid)
201  	 THEN
202  	   -- write extra log entry and cut original content to limit
203  	   log_event( p_message => 'p_guid length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
204  		    , p_log_type => sosl_sys.FATAL_TYPE
205  		    , p_log_category => 'LOG USAGE ERROR'
206  		    , p_full_message => (p_message || ' - ' || p_full_message)
207  		    )
208  	   ;
209  	   l_guid := SUBSTR(p_guid, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'GUID'));
210  	 ELSE
211  	   l_guid := p_guid;
212  	 END IF;
213  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'SOSL_IDENTIFIER', p_sosl_identifier)
214  	 THEN
215  	   -- write extra log entry and cut original content to limit
216  	   log_event( p_message => 'p_sosl_identifier length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
217  		    , p_log_type => sosl_sys.FATAL_TYPE
218  		    , p_log_category => 'LOG USAGE ERROR'
219  		    , p_full_message => (p_message || ' - ' || p_full_message)
220  		    )
221  	   ;
222  	   l_sosl_identifier := SUBSTR(p_sosl_identifier, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'SOSL_IDENTIFIER'));
223  	 ELSE
224  	   l_sosl_identifier := p_sosl_identifier;
225  	 END IF;
226  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'EXECUTOR_ID', p_executor_id)
227  	 THEN
228  	   -- write extra log entry and cut original content to limit
229  	   log_event( p_message => 'p_executor_id length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error. EXECUTOR_ID: ' || p_executor_id
230  		    , p_log_type => sosl_sys.FATAL_TYPE
231  		    , p_log_category => 'LOG USAGE ERROR'
232  		    , p_full_message => (p_message || ' - ' || p_full_message)
233  		    )
234  	   ;
235  	   -- we can't shorten the number, leave it to oracle
236  	   l_executor_id := p_executor_id;
237  	 ELSE
238  	   l_executor_id := p_executor_id;
239  	 END IF;
240  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'EXT_SCRIPT_ID', p_ext_script_id)
241  	 THEN
242  	   -- write extra log entry and cut original content to limit
243  	   log_event( p_message => 'ext_script_id length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error.'
244  		    , p_log_type => sosl_sys.FATAL_TYPE
245  		    , p_log_category => 'LOG USAGE ERROR'
246  		    , p_full_message => (p_message || ' - ' || p_full_message)
247  		    )
248  	   ;
249  	   l_ext_script_id := SUBSTR(p_ext_script_id, 1, sosl_sys.get_col_length('SOSL_SERVER_LOG', 'EXT_SCRIPT_ID'));
250  	 ELSE
251  	   l_ext_script_id := p_ext_script_id;
252  	 END IF;
253  	 IF NOT sosl_sys.check_col('SOSL_SERVER_LOG', 'RUN_ID', p_run_id)
254  	 THEN
255  	   -- write extra log entry and cut original content to limit
256  	   log_event( p_message => 'p_run_id length exceeds column length in SOSL_SERVER_LOG. See full message for message causing the error. RUN_ID: ' || p_run_id
257  		    , p_log_type => sosl_sys.FATAL_TYPE
258  		    , p_log_category => 'LOG USAGE ERROR'
259  		    , p_full_message => (p_message || ' - ' || p_full_message)
260  		    )
261  	   ;
262  	   -- we can't shorten the number, leave it to oracle
263  	   l_run_id := p_run_id;
264  	 ELSE
265  	   l_run_id := p_run_id;
266  	 END IF;
267  	 -- try to write the given data to SOSL_SERVER_LOG
268  	 log_event(p_message, p_log_type, l_log_category, l_guid, l_sosl_identifier, l_executor_id, l_ext_script_id, l_caller, l_run_id, p_full_message);
269    EXCEPTION
270  	 WHEN OTHERS THEN
271  	   log_event( p_message => 'full log error: ' || TRIM(SUBSTR(SQLERRM, 1, 3900))
272  		    , p_log_type => sosl_sys.FATAL_TYPE
273  		    , p_log_category => 'FULL_LOG ERROR'
274  		    , p_full_message => SQLERRM || ': ' || p_message
275  		    )
276  	   ;
277    END full_log;
278  
279    PROCEDURE cmd_log( p_message	     IN VARCHAR2
280  			, p_log_type	     IN VARCHAR2     DEFAULT sosl_sys.INFO_TYPE
281  			, p_caller	     IN VARCHAR2     DEFAULT NULL
282  			, p_guid	     IN VARCHAR2     DEFAULT NULL
283  			, p_sosl_identifier  IN VARCHAR2     DEFAULT NULL
284  			, p_executor_id      IN NUMBER	     DEFAULT NULL
285  			, p_ext_script_id    IN VARCHAR2     DEFAULT NULL
286  			, p_full_message     IN CLOB	     DEFAULT NULL
287  			)
288    IS
289    BEGIN
290  	 full_log( p_message => p_message
291  		 , p_log_type => p_log_type
292  		 , p_caller => p_caller
293  		 , p_guid => p_guid
294  		 , p_sosl_identifier => p_sosl_identifier
295  		 , p_executor_id => p_executor_id
296  		 , p_ext_script_id => p_ext_script_id
297  		 , p_full_message => p_full_message
298  		 )
299  	 ;
300    END cmd_log;
301  
302  END;
303  /

Warning: Package Body created with compilation errors.

SQL> 
SQL> -- SOSL objects with possible references to sosl_log and sosl_sys
SQL> @@../sosl_ddl/tables/sosl_config.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_config
  2    ( config_name	     VARCHAR2(128)					       NOT NULL
  3    , config_value	     VARCHAR2(4000)					       NOT NULL
  4    , config_max_length   NUMBER	     DEFAULT -1 			       NOT NULL
  5    , config_type	     VARCHAR2(6)     DEFAULT 'CHAR'			       NOT NULL
  6    , created	     DATE	     DEFAULT SYSDATE			       NOT NULL
  7    , updated	     DATE	     DEFAULT SYSDATE			       NOT NULL
  8    , created_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
  9    , created_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
 11    , updated_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , config_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_config IS 'Holds the configuration used by SOSL. Will use the alias scfg.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_name IS 'The unique case sensitive name of the SOSL configuration object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_value IS 'The configuration value always as VARCHAR2. Type handling and conversion must be done by the caller.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_type IS 'Defines how the config value has to be interpreted. Currently supports CHAR and NUMBER.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_max_length IS 'Defines a maximum length for CHAR type config values if set to a number > 0. Default is -1, do not not check length.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_description IS 'Optional description of the SOSL config object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- primary key
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_pk
  3    PRIMARY KEY (config_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_type
  3    CHECK (config_type IN ('CHAR', 'NUMBER'))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_max_length
  3    CHECK (config_max_length = -1 OR config_max_length > 0)
  4  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_config_ins_upd_trg
  2    BEFORE INSERT OR UPDATE ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok    BOOLEAN;
  6    l_date  DATE;
  7  BEGIN
  8    -- remove any leading and trailing blanks from config_value
  9    :NEW.config_value   := TRIM(:NEW.config_value);
 10    IF UPDATING
 11    THEN
 12  	 :NEW.created	     := :OLD.created;
 13  	 :NEW.created_by     := :OLD.created_by;
 14  	 :NEW.created_by_os  := :OLD.created_by_os;
 15    ELSE
 16  	 :NEW.created	     := SYSDATE;
 17  	 :NEW.created_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 18  	 :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 19    END IF;
 20    :NEW.updated	   := SYSDATE;
 21    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 22    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 23    -- check max length if defined
 24    IF :NEW.config_type = 'CHAR'
 25    THEN
 26  	 IF :NEW.config_max_length > 0
 27  	 THEN
 28  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 29  	   THEN
 30  	     RAISE_APPLICATION_ERROR(-20000, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 31  	   END IF;
 32  	 END IF;
 33    END IF;
 34    -- check number type
 35    IF :NEW.config_type = 'NUMBER'
 36    THEN
 37  	 l_ok := TRUE;
 38  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 39  	 BEGIN
 40  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 41  	 EXCEPTION
 42  	   WHEN OTHERS THEN
 43  	     l_ok := FALSE;
 44  	 END;
 45  	 IF NOT l_ok
 46  	 THEN
 47  	   RAISE_APPLICATION_ERROR(-20001, 'The given config_value "' || :NEW.config_value || '" could not be converted successfully to a number.');
 48  	 END IF;
 49    END IF;
 50  END;
 51  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_config_del_trg
  2    BEFORE DELETE ON sosl_config
  3    FOR EACH ROW
  4  BEGIN
  5    -- protect system parameters from delete
  6    IF :OLD.config_name IN ( 'SOSL_PATH_CFG'
  7  			      , 'SOSL_PATH_TMP'
  8  			      , 'SOSL_PATH_LOG'
  9  			      , 'SOSL_START_LOG'
 10  			      , 'SOSL_BASE_LOG'
 11  			      , 'SOSL_EXT_LOG'
 12  			      , 'SOSL_EXT_TMP'
 13  			      , 'SOSL_EXT_LOCK'
 14  			      , 'SOSL_EXT_ERROR'
 15  			      , 'SOSL_MAX_PARALLEL'
 16  			      , 'SOSL_RUNMODE'
 17  			      , 'SOSL_DEFAULT_WAIT'
 18  			      , 'SOSL_NOJOB_WAIT'
 19  			      , 'SOSL_PAUSE_WAIT'
 20  			      , 'SOSL_USE_MAIL'
 21  			      , 'SOSL_MAIL_SENDER'
 22  			      , 'SOSL_MAIL_RECIPIENT'
 23  			      , 'SOSL_MAIL_API'
 24  			      , 'SOSL_HAS_ID_API'
 25  			      )
 26    THEN
 27  	 RAISE_APPLICATION_ERROR(-20002, 'The given system config_name "' || :OLD.config_name || '" cannot be deleted.');
 28    END IF;
 29  END;
 30  /

Trigger created.

SQL> -- load default values that can be configured in the database
SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_PATH_CFG', '..\..\sosl_cfg\', 'Relative path with delimiter at path end to configuration files the SOSL server uses. Set by SOSL server. As configuration files contain credentials and secrets the path should be in a safe space with controlled user rights.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_TMP', '..\..\sosl_tmp\', 239, 'Relative path with delimiter at path end to temporary files the SOSL server uses. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_LOG', '..\..\sosl_log\', 239, 'Relative path with delimiter at path end to log files the SOSL server creates. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_START_LOG', 'sosl_server', 'Log filename for start and end of SOSL server CMD. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_BASE_LOG', 'sosl_job_', 'Base log filename for single job runs. Will be extended by GUID. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOG', 'log', 'Log file extension to use. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_TMP', 'tmp', 'Log file extension for temporary logs to use. On error those file extension will be renamed to SOSL_EXT_ERROR extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOCK', 'lock', 'Default process lock file extension. Lock files will always get deleted either on service start or after a run. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_ERROR', 'err', 'Default process error file extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAX_PARALLEL', '8', 'NUMBER', 'The maximum of parallel started scripts. Read by the SOSL server. After this amount if scripts is started, next scripts are only loaded, if the run count is below this value.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_RUNMODE', 'RUN', 'CHAR', 'Determines if the server should RUN, WAIT or STOP. Read by the SOSL server. RUN will cause the SOSL server, if started to run as long as it does not get a STOP signal from the database. Set it to STOP to stop the SOSL server. Set to WAIT if the server should not call any script apart the check for the run mode. Can be locally overwritten.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_DEFAULT_WAIT', '1', 'NUMBER', 'Determines the normal sleep time in seconds the sosl server has between calls if scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_NOJOB_WAIT', '120', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if no scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_PAUSE_WAIT', '3600', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if run mode is set to wait.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_USE_MAIL', 'NO', 'CHAR', 'Determines if sosl should use mail. Set to YES if you want to use mail.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAIL_SENDER', 'NOT_SET', 'CHAR', 'The default sender mail address for sending mails.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAIL_RECIPIENT', 'NOT_SET', 'CHAR', 'The default recipient mail address for sending mails.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAIL_API', 'sosl.send_mail', 'CHAR', 'The name of an existing function that should handle mail. The wrapper function SOSL_SENDMAIL is created dynamically. The function must have four parameters: mail_sender IN VARCHAR2, mail_recipients IN VARCHAR2, mail_subject IN VARCHAR2, mail_text IN VARCHAR2 and must return 0 for success or -1 on errors. It may include a schema, if not sosl schema. Can be a package or standalone function.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_HAS_ID_API', 'sosl.has_ids', 'CHAR', 'The name of an existing function that returns the amount of IDs waiting for processing. The wrapper function SOSL_HAS_IDS is created dynamically. The function expects no parameters and simply returns the amount of IDs waiting for processing. It may include a schema, if not sosl schema. Can be a package procedure or standalone procedure.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_GET_ID_API', 'sosl.get_next_id', 'CHAR', 'The name of an existing procedure that should handle mail. Must work for all plans as the wrapper function SOSL_SENDMAIL is created dynamically. The procedure must have four parameters: mail_sender IN VARCHAR2, mail_recipients IN VARCHAR2, mail_subject IN VARCHAR2, mail_text IN VARCHAR2. It may include a schema, if not sosl schema. Can be a package procedure or standalone procedure.')
  5  ;

1 row created.

SQL> COMMIT;

Commit complete.

SQL> @@../sosl_ddl/tables/sosl_executor.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> CREATE TABLE sosl_executor
  2    ( executor_id	       NUMBER(38, 0)   GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , db_user	       VARCHAR2(128)						 NOT NULL
  4    , function_owner        VARCHAR2(128)						 NOT NULL
  5    , fn_has_ids	       VARCHAR2(520)						 NOT NULL
  6    , fn_get_next_id        VARCHAR2(520)						 NOT NULL
  7    , fn_get_executor       VARCHAR2(520)						 NOT NULL
  8    , fn_get_script	       VARCHAR2(520)						 NOT NULL
  9    , fn_set_status	       VARCHAR2(520)						 NOT NULL
 10    , cfg_file	       VARCHAR2(4000)						 NOT NULL
 11    , executor_active       VARCHAR2(3)     DEFAULT 'NO'				 NOT NULL
 12    , executor_reviewed     VARCHAR2(3)     DEFAULT 'NO'				 NOT NULL
 13    , created	       DATE	       DEFAULT SYSDATE				 NOT NULL
 14    , updated	       DATE	       DEFAULT SYSDATE				 NOT NULL
 15    , created_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 16    , created_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , updated_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 18    , updated_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 19    , executor_description  VARCHAR2(4000)
 20    )
 21  ;

Table created.

SQL> COMMENT ON TABLE sosl_executor IS 'Defines the executors registered with SOSL. To improve security you may activate AUDIT on this table. Will use the alias sexe.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_id IS 'The generated unique id that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.db_user IS 'The login name of the database user must match cfg_file login and be USER after login. No mixed case support, converted to upper case. Must exist and have the necessary rights to execute the queued scripts.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.function_owner IS 'The owner user name of the API functions, refers to the schema where the functions are defined. No mixed case support, converted to upper case. Can differ from the database user that executes SOSL. All API functions must have the same owner for one executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_has_ids IS 'The name of the function to use by HAS_IDS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the amount of waiting script as NUMBER.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_get_next_id IS 'The name of the function to use by GET_NEXT_ID wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the script id as VARCHAR2. It should manage the given script id to ensure that scripts are not run twice.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_get_executor IS 'The name of the function to use by GET_EXECUTOR wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameter P_ID IN VARCHAR2 and return the executor id as NUMBER. P_ID is an script id retrieved from GET_NEXT_ID.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_get_script IS 'The name of the function to use by GET_SCRIPT wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameter P_ID IN VARCHAR2 and return the script name with full or relative path as VARCHAR2. The script must exist in the given path on the local server SOSL is running.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_set_status IS 'The name of the function to use by SET_STATUS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameters P_ID IN VARCHAR2, P_STATUS IN VARCHAR2 and return 0 or -1 on errors. P_ID is an script id retrieved from GET_NEXT_ID. P_STATUS will always start with the following key words: PREPARING, ENQUEUED, RUNNING, SUCCESS, ERROR. It may contain additional informations in case of errors separated by at least one space char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.cfg_file IS 'The filename with absolute or relative path to the login config file for this executor. File and path must exist on the CMD server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_active IS 'Defines if the executor is active. Accepts NO and YES. Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_reviewed IS 'Defines if the executor is reviewed, accepted and ready to be used. Accepts NO and YES. Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_description IS 'Optional executor description.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_pk
  3    PRIMARY KEY (executor_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- check constraints
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_active
  3    CHECK (UPPER(executor_active) IN ('YES', 'NO'))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_reviewed
  3    CHECK (UPPER(executor_reviewed) IN ('YES', 'NO'))
  4    ENABLE
  5  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_executor_ins_trg
  2    BEFORE INSERT ON sosl_executor
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	       := SYSDATE;
  6    :NEW.created_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  7    :NEW.created_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
  8    :NEW.updated	       := SYSDATE;
  9    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 11    :NEW.executor_active    := UPPER(:NEW.executor_active);
 12    :NEW.executor_reviewed  := UPPER(:NEW.executor_reviewed);
 13    -- transform users to UPPERCASE, no support currently for special mix-case.
 14    :NEW.function_owner     := UPPER(:NEW.function_owner);
 15    :NEW.db_user	       := UPPER(:NEW.db_user);
 16    :NEW.fn_has_ids	       := UPPER(:NEW.fn_has_ids);
 17    :NEW.fn_get_next_id     := UPPER(:NEW.fn_get_next_id);
 18    :NEW.fn_get_executor    := UPPER(:NEW.fn_get_executor);
 19    :NEW.fn_get_script      := UPPER(:NEW.fn_get_script);
 20    :NEW.fn_set_status      := UPPER(:NEW.fn_set_status);
 21    -- check user
 22    IF NOT sosl_sys.has_db_user(:NEW.db_user)
 23    THEN
 24  	 RAISE_APPLICATION_ERROR(-20003, 'The given database user is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 25    END IF;
 26    -- check configured functions
 27    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_has_ids, 'NUMBER')
 28    THEN
 29  	 RAISE_APPLICATION_ERROR(-20004, 'The given function ' || :NEW.fn_has_ids || ' for has_ids is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 30    END IF;
 31    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_next_id, 'VARCHAR2')
 32    THEN
 33  	 RAISE_APPLICATION_ERROR(-20005, 'The given function ' || :NEW.fn_get_next_id || ' for get_next_id is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.');
 34    END IF;
 35    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_executor, 'NUMBER')
 36    THEN
 37  	 RAISE_APPLICATION_ERROR(-20006, 'The given function ' || :NEW.fn_get_executor || ' for get_executor is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 38    END IF;
 39    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_get_script, 'VARCHAR2')
 40    THEN
 41  	 RAISE_APPLICATION_ERROR(-20007, 'The given function ' || :NEW.fn_get_script || ' for get_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype VARCHAR2 or is not granted with EXECUTE rights to SOSL.');
 42    END IF;
 43    IF NOT sosl_sys.has_function(:NEW.function_owner, :NEW.fn_set_status, 'NUMBER')
 44    THEN
 45  	 RAISE_APPLICATION_ERROR(-20008, 'The given function ' || :NEW.fn_set_status || ' for set_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has wrong return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 46    END IF;
 47  
 48  END;
 49  /

Trigger created.

SQL> -- internal objects using the API
SQL> @@../sosl_ddl/tables/sosl_script.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_script
  2    ( script_id	    NUMBER(38, 0)  GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , script_name	    VARCHAR2(2000)					     NOT NULL
  4    , script_schema	    VARCHAR2(256)  DEFAULT 'SOSL'			     NOT NULL
  5    , created	    DATE	   DEFAULT SYSDATE			     NOT NULL
  6    , updated	    DATE	   DEFAULT SYSDATE			     NOT NULL
  7    , created_by	    VARCHAR2(256)  DEFAULT USER 			     NOT NULL
  8    , created_by_os	    VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
  9    , updated_by	    VARCHAR2(256)  DEFAULT USER 			     NOT NULL
 10    , updated_by_os	    VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 11    , script_description VARCHAR2(4000)
 12    )
 13  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_script IS 'Holds the script file names that should be executed by SOSL. Will use the alias scrt.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_id IS 'The generated unique id of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_name IS 'The name of the script file including full or relative path. Use relative path (relative to batch_base_path or repository location) to ensure running scripts from different machines.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_schema IS 'The schema the script should run in. Will cause an ALTER SESSION SET CURRENT_SCHEMA before executing the script.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_description IS 'Optional description of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_script
  2    ADD CONSTRAINT sosl_script_pk
  3    PRIMARY KEY (script_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_script_ins_trg
  2    BEFORE INSERT ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := SYSDATE;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_script_upd_trg
  2    BEFORE UPDATE ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    :NEW.updated	   := SYSDATE;
 10    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12  END;
 13  /

Trigger created.

SQL> -- ==============INSTALL done==============
SQL> @@../sosl_sql/util/log_silent.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> SET ECHO OFF
ERROR - script has errors                      -1
Warning: Package Body created with compilation errors.
