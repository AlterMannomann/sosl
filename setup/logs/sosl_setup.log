SQL> -- roles
SQL> @@../sosl_ddl/roles/create_roles.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- create sosl roles
SQL> CREATE ROLE sosl_admin;

Role created.

SQL> CREATE ROLE sosl_executor;

Role created.

SQL> CREATE ROLE sosl_reviewer;

Role created.

SQL> CREATE ROLE sosl_user;

Role created.

SQL> CREATE ROLE sosl_guest;

Role created.

SQL> -- hierarchical grants
SQL> GRANT sosl_guest TO sosl_user;

Grant succeeded.

SQL> GRANT sosl_user TO sosl_reviewer;

Grant succeeded.

SQL> GRANT sosl_reviewer TO sosl_executor;

Grant succeeded.

SQL> GRANT sosl_executor TO sosl_admin;

Grant succeeded.

SQL> -- types
SQL> @@../sosl_ddl/types/sosl_payload.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- basic api exchange type, only header, no member function
SQL> CREATE OR REPLACE TYPE sosl_payload
  2    AS OBJECT
  3  	 /* This type is used to exchange information on executor, external script id and the script filename including
  4  	 * relative or full path which must exist on the server SOSL is running.
  5  	 * It does not provide any member functions only fields to fill. Object initialization basic example:
  6  	 * DECLARE
  7  	 *   -- to access the type from other schemas, do not forget to qualify it with the SOSL schema used
  8  	 *   l_sosl_payload SOSL.SOSL_PAYLOAD;
  9  	 * BEGIN
 10  	 *   l_sosl_payload := sosl_payload(1, 'My script ID', '../../mydir/scriptfile.sql');
 11  	 * END;
 12  	 */
 13  	 ( executor_id	  NUMBER(38, 0)  -- the executor_id from SOSL_EXECUTOR responsible for the script
 14  	 , ext_script_id  VARCHAR2(4000) -- the external script id managed by the executor
 15  	 , script_file	  VARCHAR2(4000) -- the script file name with full or relative path on the server where SOSL is running locally
 16  	 )
 17  ;
 18  /

Type created.

SQL> -- SQLPlus error logging table
SQL> @@../sosl_ddl/tables/soslerrorlog.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, equals SPERRORLOG
SQL> CREATE TABLE soslerrorlog
  2    ( username    VARCHAR2(256)
  3    , timestamp   TIMESTAMP
  4  	 -- older versions than Oracle 23 use VARCHAR2(1024)
  5    , script      CLOB	   -- VARCHAR2(1024)
  6    , identifier  VARCHAR2(256)
  7    , message     CLOB
  8    , statement   CLOB
  9    )
 10  ;

Table created.

SQL> COMMENT ON TABLE soslerrorlog IS 'Userdefined table for SQLPlus error logging';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.username IS 'Oracle account name';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.timestamp IS 'Time when the error occurred';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.script IS 'Name of the originating script if applicable';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.identifier IS 'User defined identifier string';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.message IS 'ORA, PLA or SP2 error message. No feed back messages are included. For example, "PL/SQL Block Created" is not recorded.';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.statement IS 'The statement causing the error';

Comment created.

SQL> -- Grants, inherited by others, no guest and user access on tables
SQL> GRANT SELECT ON soslerrorlog TO sosl_reviewer;

Grant succeeded.

SQL> -- logging table
SQL> @@../sosl_ddl/tables/sosl_server_log.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_server_log
  2    ( exec_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP 		     NOT NULL
  3  	 -- due to Oracle limitations we must use trigger not a package variable, trigger takes care
  4  	 -- to assign a default INFO log type if getting sosl_sys.NA_TYPE
  5    , log_type	   VARCHAR2(30)    DEFAULT 'n/a'			     NOT NULL
  6    , log_category	   VARCHAR2(256)   DEFAULT 'n/a'			     NOT NULL
  7    , message	   VARCHAR2(4000)					     NOT NULL
  8    , run_id 	   NUMBER(38, 0)
  9    , executor_id	   NUMBER(38, 0)
 10    , guid		   VARCHAR2(64)
 11    , sosl_identifier   VARCHAR2(256)
 12    , caller 	   VARCHAR2(256)
 13    , ext_script_id	   VARCHAR2(4000)
 14    , script_file	   VARCHAR2(4000)
 15    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 16    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , full_message	   CLOB
 18    )
 19    -- monthly partitions
 20    PARTITION BY RANGE (exec_timestamp)
 21    INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
 22    (PARTITION P_OLD
 23  	   VALUES LESS THAN (TO_TIMESTAMP('01-01-2024','DD-MM-YYYY'))
 24    )
 25  ;

Table created.

SQL> COMMENT ON TABLE sosl_server_log IS 'Holds the log events of the SOSL server CMD and interaction with the database as well as database events. Update is not allowed. Will use the alias slog.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.exec_timestamp IS 'The timestamp of the event. Automatically set by trigger, no set allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_type IS 'The logging type, supports currently INFO, WARNING, ERROR, FATAL, SUCCESS. Mandatory. Defined in package SOSL_SYS.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_category IS 'The log writer may provide an short log category description.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.message IS 'The shortend log message. Mandatory. If only a CLOB is passed, the short message is build from the CLOB. Categories too long will be cutted.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.full_message IS 'The full log message. For messages longer than 4000 bytes or char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.guid IS 'The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.sosl_identifier IS 'The exact identifier for SOSLERRORLOG if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.run_id IS 'The associated run id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.executor_id IS 'The associated executor id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.script_file IS 'The script filename as delivered, including relative or absolute path.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.ext_script_id IS 'The (external) script id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.caller IS 'Caller identification if available, to distinguish database processes from SOSL CMD server processes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by IS 'The logged in DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- no primary key, only index
SQL> CREATE INDEX sosl_server_log_idx
  2    ON sosl_server_log (exec_timestamp, log_type, log_category)
  3  ;

Index created.

SQL> -- no constraints, as Oracle does not allow package functions in CHECK conditions
SQL> 
SQL> -- Grants, inherited by others, no guest and user access on tables
SQL> GRANT SELECT ON sosl_server_log TO sosl_reviewer;

Grant succeeded.

SQL> -- SOSL objects basic objects
SQL> @@../sosl_ddl/tables/sosl_config.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_config
  2    ( config_name	     VARCHAR2(128)					       NOT NULL
  3    , config_value	     VARCHAR2(4000)					       NOT NULL
  4    , config_max_length   NUMBER	     DEFAULT -1 			       NOT NULL
  5    , config_type	     VARCHAR2(6)     DEFAULT 'CHAR'			       NOT NULL
  6    , created	     DATE	     DEFAULT SYSDATE			       NOT NULL
  7    , updated	     DATE	     DEFAULT SYSDATE			       NOT NULL
  8    , created_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
  9    , created_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
 11    , updated_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , config_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_config IS 'Holds the configuration used by SOSL. Will use the alias scfg.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_name IS 'The unique case sensitive name of the SOSL configuration object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_value IS 'The configuration value always as VARCHAR2. Type handling and conversion must be done by the caller.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_type IS 'Defines how the config value has to be interpreted. Currently supports CHAR and NUMBER.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_max_length IS 'Defines a maximum length for CHAR type config values if set to a number > 0. Default is -1, do not not check length.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_description IS 'Optional description of the SOSL config object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- primary key
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_pk
  3    PRIMARY KEY (config_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_type
  3    CHECK (config_type IN ('CHAR', 'NUMBER'))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_max_length
  3    CHECK (config_max_length = -1 OR config_max_length > 0)
  4  ;

Table altered.

SQL> -- Grants, inherited by others, no guest and user access on tables
SQL> GRANT SELECT ON sosl_config TO sosl_reviewer;

Grant succeeded.

SQL> GRANT UPDATE ON sosl_config TO sosl_admin;

Grant succeeded.

SQL> @@../sosl_ddl/tables/sosl_executor.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_executor
  2    ( executor_id	       NUMBER(38, 0)   GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , executor_name	       VARCHAR2(256)						 NOT NULL
  4    , db_user	       VARCHAR2(128)						 NOT NULL
  5    , function_owner        VARCHAR2(128)						 NOT NULL
  6    , fn_has_scripts        VARCHAR2(520)						 NOT NULL
  7    , fn_get_next_script    VARCHAR2(520)						 NOT NULL
  8    , fn_set_script_status  VARCHAR2(520)						 NOT NULL
  9    , cfg_file	       VARCHAR2(4000)						 NOT NULL
 10    , use_mail	       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 11    , fn_send_db_mail       VARCHAR2(520)   DEFAULT 'sosl_log.dummy_mail'		 NOT NULL
 12    , executor_active       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 13    , executor_reviewed     NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 14    , created	       DATE	       DEFAULT SYSDATE				 NOT NULL
 15    , updated	       DATE	       DEFAULT SYSDATE				 NOT NULL
 16    , created_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 17    , created_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 18    , updated_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 19    , updated_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 20    , script_schema	       VARCHAR2(128)   DEFAULT NULL
 21    , executor_description  VARCHAR2(4000)
 22    )
 23  ;

Table created.

SQL> COMMENT ON TABLE sosl_executor IS 'Defines the executors registered with SOSL. To improve security you may activate AUDIT on this table. Will use the alias sexe.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_id IS 'The generated unique id that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_name IS 'The unique name that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.db_user IS 'The login name of the database user must match cfg_file login and be USER after login. No mixed case support, converted to upper case. Must exist and have the necessary rights to execute the queued scripts. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.function_owner IS 'The owner user name of the API functions, refers to the schema where the functions are defined. No mixed case support, converted to upper case. Can differ from the database user that executes SOSL. All API functions must have the same owner for one executor. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_has_scripts IS 'The name of the interface function to use by HAS_SCRIPTS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the amount of waiting scripts as NUMBER or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_get_next_script IS 'The name of the interface function to use by GET_NEXT_SCRIPT wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall not require parameters and return the script id, executor id and script file name as type SOSL_PAYLOAD. It should manage the given script id to ensure that scripts are not run twice.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_set_script_status IS 'The name of the interface function to use by SET_SCRIPT_STATUS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameters P_RUN_ID IN NUMBER, P_STATUS IN NUMBER and return 0 or -1 on errors. Details can be fetched from SOSL_RUN_QUEUE. P_STATUS reflects the intended state as defined in SOSL_CONSTANTS RUN% constants. The effective state may differ from the intended state if transition has failed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.fn_send_db_mail IS 'The name of the interface function to use by SEND_DB_MAIL wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to SOSL. It shall require the parameters P_RUN_ID IN NUMBER, P_STATUS IN NUMBER and return 0 or -1 on errors. P_STATUS reflects the intended state as defined in SOSL_CONSTANTS RUN% constants. The effective state may differ from the intended state if transition has failed. Message building and sending is up to the defined function. If mail is activated this function is called on every state change.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.cfg_file IS 'The filename with absolute or relative path to the login config file for this executor. File and path must exist on the CMD server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.use_mail IS 'Defines if mail should be provided by SOSL. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). You may also integrate mail behind the SOSL scenes by integrating it into your interface functions.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_active IS 'Defines if the executor is active. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_reviewed IS 'Defines if the executor is reviewed, accepted and ready to be used. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.script_schema IS 'The (optional) schema the script should run in. If set will cause an ALTER SESSION SET CURRENT_SCHEMA before executing the script otherwise db user schema is used. DB user must have rights for this schema if set. If acting on own schema or scripts do ALTER SESSION by themselves, you should leave it NULL.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor.executor_description IS 'Optional executor description.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_pk
  3    PRIMARY KEY (executor_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- unique constraint
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_uk
  3    UNIQUE (executor_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- check constraints
SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_use_mail
  3    CHECK (use_mail IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_active
  3    CHECK (executor_active IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor
  2    ADD CONSTRAINT sosl_executor_chk_reviewed
  3    CHECK (executor_reviewed IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> GRANT SELECT ON sosl_executor TO sosl_reviewer;

Grant succeeded.

SQL> GRANT UPDATE ON sosl_executor TO sosl_reviewer;

Grant succeeded.

SQL> GRANT INSERT ON sosl_executor TO sosl_executor;

Grant succeeded.

SQL> GRANT DELETE ON sosl_executor TO sosl_admin;

Grant succeeded.

SQL> @@../sosl_ddl/tables/sosl_run_queue.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE TABLE sosl_run_queue
  2    ( run_id 	 NUMBER(38, 0)	 GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , run_state	 NUMBER(1, 0)	 DEFAULT 0				   NOT NULL
  4    , executor_id	 NUMBER(38, 0)						   NOT NULL
  5    , ext_script_id	 VARCHAR2(4000) 					   NOT NULL
  6    , script_file	 VARCHAR2(4000) 					   NOT NULL
  7    , created	 TIMESTAMP						   NOT NULL
  8    , waiting	 TIMESTAMP
  9    , enqueued	 TIMESTAMP
 10    , started	 TIMESTAMP
 11    , running	 TIMESTAMP
 12    , finished	 TIMESTAMP
 13    , created_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 14    , created_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 15    , waiting_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 16    , waiting_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , enqueued_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 18    , enqueued_by_os  VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 19    , started_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 20    , started_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 21    , running_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 22    , running_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 23    , finished_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 24    , finished_by_os  VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 25    )
 26  ;

Table created.

SQL> COMMENT ON TABLE sosl_run_queue IS 'This table hold old and new runs of batch plans and the execution run state of each script. Granularity is single script. This is not a message queue. Will use the alias srqu.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.run_id IS 'Generated unique id for a batch run script.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.run_state IS 'Holds the run state: 0 Waiting, 1 Enqueued, 2 Started, 3 Running, 4 Finished, -1 Error. To rerun a job, set run_state to 1. Will not be accepted if executor is not active and reviewed. Script dependencies are not checked. Can only be 0 or -1 on insert, managed by trigger';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.executor_id IS 'The valid executor id as returned from API (NUMBER). No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.ext_script_id IS 'The (external) identifier for the current script as returned from API (VARCHAR2). No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.script_file IS 'The script file name including (relative) path from API (VARCHAR2). No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.created IS 'The date of record creation. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.waiting IS 'The last date of setting the script run state to waiting (0). On insert this is the default managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.enqueued IS 'The last date of setting the script run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.started IS 'The last date of setting the script run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.running IS 'The last date of setting the script run state to running (3).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.finished IS 'The last date of setting the script run state to finished or error (4, -1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.waiting_by IS 'Last DB user who set the record run state to waiting (0), managed by default and inser trigger, updates allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.waiting_by_os IS 'Last OS user who set the record run state to waiting (0), managed by default and insert trigger, updates allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.enqueued_by IS 'Last DB user who tried to set the record run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.enqueued_by_os IS 'Last OS user who tried to set the record run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.started_by IS 'Last DB user who tried to set the record run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.started_by_os IS 'Last OS user who tried to set the record run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.running_by IS 'Last DB user who tried to set the record run state to running (3).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.running_by_os IS 'Last OS user who tried to set the record run state to running (3)';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.finished_by IS 'Last DB user who tried to set the record run state to finished (4) or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.finished_by_os IS 'Last OS user who tried to set the record run state to finished (4) or -1 on errors.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_run_queue
  2    ADD CONSTRAINT sosl_run_queue_pk
  3    PRIMARY KEY (run_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_run_queue
  2    ADD CONSTRAINT sosl_run_queue_chk_run_state
  3    CHECK (run_state IN (-1, 0, 1, 2, 3, 4))
  4  ;

Table altered.

SQL> -- foreign keys on all ids referenced, will set record to NULL on DELETE
SQL> ALTER TABLE sosl_run_queue
  2    ADD CONSTRAINT sosl_run_queue_executor_id_fk
  3    FOREIGN KEY (executor_id)
  4    REFERENCES sosl_executor (executor_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> -- internal interface objects using the API
SQL> @@../sosl_ddl/tables/sosl_if_script.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_if_script
  2    ( script_id	     NUMBER(38, 0)  GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , script_name	     VARCHAR2(2000)					      NOT NULL
  4    , run_state	     NUMBER(1, 0)   DEFAULT 0				      NOT NULL
  5    , run_group	     VARCHAR2(30)   DEFAULT 'DEFAULT'			      NOT NULL
  6    , run_order	     NUMBER(38, 0)  DEFAULT 1				      NOT NULL
  7    , created	     DATE	    DEFAULT SYSDATE			      NOT NULL
  8    , updated	     DATE	    DEFAULT SYSDATE			      NOT NULL
  9    , created_by	     VARCHAR2(256)  DEFAULT USER			      NOT NULL
 10    , created_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 11    , updated_by	     VARCHAR2(256)  DEFAULT USER
 12    , updated_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 13    , executor_id	     NUMBER(38, 0)
 14    , script_description  VARCHAR2(4000)
 15    )
 16  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_if_script IS 'Internal interface table that holds the script file names that should be executed by SOSL. Used for tests and simple batch script setups. No logic control in triggers apart from insert and update dates and users. Will use the alias scrt.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_id IS 'The generated unique id of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.executor_id IS 'The optional related executor id of the script file. If defined, must match an existing executor. If not defined, script is ignored.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_name IS 'The name of the script file including full or relative path. Use relative path (relative to batch_base_path or repository location) to ensure running scripts from different machines.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.run_order IS 'The order in which the script file should be executed. Same number means in parallel. Higher order numbers wait for scripts with lower order numbers to complete. Must be greater than 0.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.run_state IS 'Holds the run state: 0 Waiting, 1 Enqueued, 2 Started, 3 Running, 4 Finished, -1 Error. To rerun a job, set run_state to 1. Will not be accepted if executor is not active and reviewed. Script dependencies are not checked. Can only be 0 or -1 on insert, managed by trigger';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.run_group IS 'A minimalistic group ID provided as is. Mixed case delivers mixed results. Up to installer to manage specific groups. Allows grouping of scripts.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_description IS 'Optional description of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_pk
  3    PRIMARY KEY (script_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_chk_run_state
  3    CHECK (run_state IN (-1, 0, 1, 2, 3, 4))
  4  ;

Table altered.

SQL> -- foreign key
SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_fk
  3    FOREIGN KEY (executor_id)
  4    REFERENCES sosl_executor (executor_id)
  5    ON DELETE SET NULL
  6    ENABLE
  7  ;

Table altered.

SQL> -- package with no dependency on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_constants.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic package for constants used by the Simple Oracle Script Loader, no dependencies.
SQL> CREATE OR REPLACE PACKAGE sosl_constants
  2  AS
  3    /**
  4    * This package contains SOSL constant declarations and functions for retrieving the constant with pure SQL.
  5    * As there are no dependencies, exceptions must be catched or handled by the caller. No logging for this functions.
  6    */
  7  
  8    /*====================================== start package constants used by SOSL ======================================*/
  9    -- define log_type constants used in SOSL_SERVER_LOG
 10    LOG_ERROR_TYPE	     CONSTANT CHAR(5)  := 'ERROR';
 11    LOG_WARNING_TYPE      CONSTANT CHAR(7)  := 'WARNING';
 12    LOG_FATAL_TYPE	     CONSTANT CHAR(5)  := 'FATAL';
 13    LOG_INFO_TYPE	     CONSTANT CHAR(4)  := 'INFO';
 14    LOG_SUCCESS_TYPE      CONSTANT CHAR(7)  := 'SUCCESS';
 15    -- Generic n/a type. Should be different from table defaults like 'not set' as table triggers interpret their DDL default value as fallback
 16    -- to set default values using package variables, which is not supported in table DDL by Oracle using DEFAULT. Packages may use variables
 17    -- from other packages in DEFAULT declarations.
 18    GEN_NA_TYPE	     CONSTANT CHAR(3)  := 'n/a';
 19    GEN_NA_DATE_TYPE      CONSTANT DATE     := TO_DATE('01.01.1900', 'DD.MM.YYYY');
 20    GEN_NA_TIMESTAMP_TYPE CONSTANT DATE     := TO_TIMESTAMP('01.01.1900', 'DD.MM.YYYY');
 21    GEN_DATE_FORMAT	     CONSTANT CHAR(21) := 'YYYY-MM-DD HH24:MI:SS';
 22    GEN_TIMESTAMP_FORMAT  CONSTANT CHAR(21) := 'YYYY-MM-DD HH24:MI:SS.FF';
 23    GEN_NULL_TEXT	     CONSTANT CHAR(4)  := 'NULL';
 24    -- numerical equations to TRUE/YES and FALSE/NO
 25    NUM_YES		     CONSTANT INTEGER  := 1;
 26    NUM_NO		     CONSTANT INTEGER  := 0;
 27    -- default error numeric expression, that is returned by functions to indicate an error had occured
 28    NUM_ERROR	     CONSTANT INTEGER  := -1;
 29    -- default success numeric expression, that is returned by functions to indicate processing was successful
 30    NUM_SUCCESS	     CONSTANT INTEGER  := 0;
 31    -- Run states
 32    RUN_STATE_WAITING     CONSTANT INTEGER  := 0;
 33    RUN_STATE_ENQUEUED    CONSTANT INTEGER  := 1;
 34    RUN_STATE_STARTED     CONSTANT INTEGER  := 2;
 35    RUN_STATE_RUNNING     CONSTANT INTEGER  := 3;
 36    RUN_STATE_FINISHED    CONSTANT INTEGER  := 4;
 37    RUN_STATE_ERROR	     CONSTANT INTEGER  := -1;
 38    /*====================================== end package constants used by SOSL ======================================*/
 39    -- All get_ functions only return the defined constant, no extra code. Constant name prefixed with GET_.
 40    FUNCTION get_log_error_type
 41  	 RETURN VARCHAR2
 42  	 DETERMINISTIC
 43  	 PARALLEL_ENABLE
 44    ;
 45    FUNCTION get_log_warning_type
 46  	 RETURN VARCHAR2
 47  	 DETERMINISTIC
 48  	 PARALLEL_ENABLE
 49    ;
 50    FUNCTION get_log_fatal_type
 51  	 RETURN VARCHAR2
 52  	 DETERMINISTIC
 53  	 PARALLEL_ENABLE
 54    ;
 55    FUNCTION get_log_info_type
 56  	 RETURN VARCHAR2
 57  	 DETERMINISTIC
 58  	 PARALLEL_ENABLE
 59    ;
 60    FUNCTION get_log_success_type
 61  	 RETURN VARCHAR2
 62  	 DETERMINISTIC
 63  	 PARALLEL_ENABLE
 64    ;
 65    FUNCTION get_gen_na_type
 66  	 RETURN VARCHAR2
 67  	 DETERMINISTIC
 68  	 PARALLEL_ENABLE
 69    ;
 70    FUNCTION get_gen_na_date_type
 71  	 RETURN DATE
 72  	 DETERMINISTIC
 73  	 PARALLEL_ENABLE
 74    ;
 75    FUNCTION get_gen_na_timestamp_type
 76  	 RETURN DATE
 77  	 DETERMINISTIC
 78  	 PARALLEL_ENABLE
 79    ;
 80    FUNCTION get_gen_date_format
 81  	 RETURN VARCHAR2
 82  	 DETERMINISTIC
 83  	 PARALLEL_ENABLE
 84    ;
 85    FUNCTION get_gen_timestamp_format
 86  	 RETURN VARCHAR2
 87  	 DETERMINISTIC
 88  	 PARALLEL_ENABLE
 89    ;
 90    FUNCTION get_gen_null_text
 91  	 RETURN VARCHAR2
 92  	 DETERMINISTIC
 93  	 PARALLEL_ENABLE
 94    ;
 95    FUNCTION get_num_yes
 96  	 RETURN NUMBER
 97  	 DETERMINISTIC
 98  	 PARALLEL_ENABLE
 99    ;
100    FUNCTION get_num_no
101  	 RETURN NUMBER
102  	 DETERMINISTIC
103  	 PARALLEL_ENABLE
104    ;
105    FUNCTION get_num_error
106  	 RETURN NUMBER
107  	 DETERMINISTIC
108  	 PARALLEL_ENABLE
109    ;
110    FUNCTION get_num_success
111  	 RETURN NUMBER
112  	 DETERMINISTIC
113  	 PARALLEL_ENABLE
114    ;
115    FUNCTION get_run_state_waiting
116  	 RETURN NUMBER
117  	 DETERMINISTIC
118  	 PARALLEL_ENABLE
119    ;
120    FUNCTION get_run_state_enqueued
121  	 RETURN NUMBER
122  	 DETERMINISTIC
123  	 PARALLEL_ENABLE
124    ;
125    FUNCTION get_run_state_started
126  	 RETURN NUMBER
127  	 DETERMINISTIC
128  	 PARALLEL_ENABLE
129    ;
130    FUNCTION get_run_state_running
131  	 RETURN NUMBER
132  	 DETERMINISTIC
133  	 PARALLEL_ENABLE
134    ;
135    FUNCTION get_run_state_finished
136  	 RETURN NUMBER
137  	 DETERMINISTIC
138  	 PARALLEL_ENABLE
139    ;
140    FUNCTION get_run_state_error
141  	 RETURN NUMBER
142  	 DETERMINISTIC
143  	 PARALLEL_ENABLE
144    ;
145  
146  END;
147  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_constants.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_constants
  2  AS
  3    -- for description see header file
  4    FUNCTION get_log_error_type
  5  	 RETURN VARCHAR2
  6  	 DETERMINISTIC
  7  	 PARALLEL_ENABLE
  8    IS
  9    BEGIN
 10  	 RETURN sosl_constants.LOG_ERROR_TYPE;
 11    END get_log_error_type;
 12  
 13    FUNCTION get_log_warning_type
 14  	 RETURN VARCHAR2
 15  	 DETERMINISTIC
 16  	 PARALLEL_ENABLE
 17    IS
 18    BEGIN
 19  	 RETURN sosl_constants.LOG_WARNING_TYPE;
 20    END get_log_warning_type;
 21  
 22    FUNCTION get_log_fatal_type
 23  	 RETURN VARCHAR2
 24  	 DETERMINISTIC
 25  	 PARALLEL_ENABLE
 26    IS
 27    BEGIN
 28  	 RETURN sosl_constants.LOG_FATAL_TYPE;
 29    END get_log_fatal_type;
 30  
 31    FUNCTION get_log_info_type
 32  	 RETURN VARCHAR2
 33  	 DETERMINISTIC
 34  	 PARALLEL_ENABLE
 35    IS
 36    BEGIN
 37  	 RETURN sosl_constants.LOG_INFO_TYPE;
 38    END get_log_info_type;
 39  
 40    FUNCTION get_log_success_type
 41  	 RETURN VARCHAR2
 42  	 DETERMINISTIC
 43  	 PARALLEL_ENABLE
 44    IS
 45    BEGIN
 46  	 RETURN sosl_constants.LOG_SUCCESS_TYPE;
 47    END get_log_success_type;
 48  
 49    FUNCTION get_gen_na_type
 50  	 RETURN VARCHAR2
 51  	 DETERMINISTIC
 52  	 PARALLEL_ENABLE
 53    IS
 54    BEGIN
 55  	 RETURN sosl_constants.GEN_NA_TYPE;
 56    END get_gen_na_type;
 57  
 58    FUNCTION get_gen_na_date_type
 59  	 RETURN DATE
 60  	 DETERMINISTIC
 61  	 PARALLEL_ENABLE
 62    IS
 63    BEGIN
 64  	 RETURN sosl_constants.GEN_NA_DATE_TYPE;
 65    END get_gen_na_date_type;
 66  
 67    FUNCTION get_gen_na_timestamp_type
 68  	 RETURN DATE
 69  	 DETERMINISTIC
 70  	 PARALLEL_ENABLE
 71    IS
 72    BEGIN
 73  	 RETURN sosl_constants.GEN_NA_TIMESTAMP_TYPE;
 74    END get_gen_na_timestamp_type;
 75  
 76    FUNCTION get_gen_date_format
 77  	 RETURN VARCHAR2
 78  	 DETERMINISTIC
 79  	 PARALLEL_ENABLE
 80    IS
 81    BEGIN
 82  	 RETURN sosl_constants.GEN_DATE_FORMAT;
 83    END get_gen_date_format;
 84  
 85    FUNCTION get_gen_timestamp_format
 86  	 RETURN VARCHAR2
 87  	 DETERMINISTIC
 88  	 PARALLEL_ENABLE
 89    IS
 90    BEGIN
 91  	 RETURN sosl_constants.GEN_TIMESTAMP_FORMAT;
 92    END get_gen_timestamp_format;
 93  
 94    FUNCTION get_gen_null_text
 95  	 RETURN VARCHAR2
 96  	 DETERMINISTIC
 97  	 PARALLEL_ENABLE
 98    IS
 99    BEGIN
100  	 RETURN sosl_constants.GEN_NULL_TEXT;
101    END get_gen_null_text;
102  
103    FUNCTION get_num_yes
104  	 RETURN NUMBER
105  	 DETERMINISTIC
106  	 PARALLEL_ENABLE
107    IS
108    BEGIN
109  	 RETURN sosl_constants.NUM_YES;
110    END get_num_yes;
111  
112    FUNCTION get_num_no
113  	 RETURN NUMBER
114  	 DETERMINISTIC
115  	 PARALLEL_ENABLE
116    IS
117    BEGIN
118  	 RETURN sosl_constants.NUM_NO;
119    END get_num_no;
120  
121    FUNCTION get_num_error
122  	 RETURN NUMBER
123  	 DETERMINISTIC
124  	 PARALLEL_ENABLE
125    IS
126    BEGIN
127  	 RETURN sosl_constants.NUM_ERROR;
128    END get_num_error;
129  
130    FUNCTION get_num_success
131  	 RETURN NUMBER
132  	 DETERMINISTIC
133  	 PARALLEL_ENABLE
134    IS
135    BEGIN
136  	 RETURN sosl_constants.NUM_SUCCESS;
137    END get_num_success;
138  
139    FUNCTION get_run_state_waiting
140  	 RETURN NUMBER
141  	 DETERMINISTIC
142  	 PARALLEL_ENABLE
143    IS
144    BEGIN
145  	 RETURN sosl_constants.RUN_STATE_WAITING;
146    END get_run_state_waiting;
147  
148    FUNCTION get_run_state_enqueued
149  	 RETURN NUMBER
150  	 DETERMINISTIC
151  	 PARALLEL_ENABLE
152    IS
153    BEGIN
154  	 RETURN sosl_constants.RUN_STATE_ENQUEUED;
155    END get_run_state_enqueued;
156  
157    FUNCTION get_run_state_started
158  	 RETURN NUMBER
159  	 DETERMINISTIC
160  	 PARALLEL_ENABLE
161    IS
162    BEGIN
163  	 RETURN sosl_constants.RUN_STATE_STARTED;
164    END get_run_state_started;
165  
166    FUNCTION get_run_state_running
167  	 RETURN NUMBER
168  	 DETERMINISTIC
169  	 PARALLEL_ENABLE
170    IS
171    BEGIN
172  	 RETURN sosl_constants.RUN_STATE_RUNNING;
173    END get_run_state_running;
174  
175    FUNCTION get_run_state_finished
176  	 RETURN NUMBER
177  	 DETERMINISTIC
178  	 PARALLEL_ENABLE
179    IS
180    BEGIN
181  	 RETURN sosl_constants.RUN_STATE_FINISHED;
182    END get_run_state_finished;
183  
184    FUNCTION get_run_state_error
185  	 RETURN NUMBER
186  	 DETERMINISTIC
187  	 PARALLEL_ENABLE
188    IS
189    BEGIN
190  	 RETURN sosl_constants.RUN_STATE_ERROR;
191    END get_run_state_error;
192  
193  END;
194  /

Package body created.

SQL> -- logging package
SQL> @@../sosl_ddl/packages/sosl_log.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic logging package, dependencies only to sosl_server_log and sosl_sys.
SQL> CREATE OR REPLACE PACKAGE sosl_log
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader for managing logging.
  5    * The interface has as well functions and procedures. Functions inform about success or error, whereas severe procedure exceptions
  6    * must be handled by the caller. The intention is to log as much information as possible before running into an exception
  7    * that can't be handled any longer.
  8    *
  9    * CURRENT ORACLE error: NOCOPY for IN parameters creates compile errors, whereas documentation allows IN NOCOPY var. Any
 10    * CLOB handling errors are possibly caused by the inability to provide a CLOB as reference.
 11    */
 12  
 13    /*====================================== start internal functions made visible for testing ======================================*/
 14    /* PROCEDURE SOSL_LOG.LOG_FALLBACK
 15    * This procedure tries some fallback actions, if logging raised an exception. It will not throw an extra exception. Intended to be
 16    * used during exception handling before raising the error.
 17    * It will try to log the error in one of this tables: SOSL_SERVER_LOG, SOSLERRORLOG, SPERRORLOG or, if everything fails output the error
 18    * via DBMS_OUTPUT.
 19    *
 20    * As we can't determine if the message contains an illegal character forcing the exception, the caller should transfer SQLERRM and
 21    * verify the transmitted content before passing it to this procedure or avoid transmitting parameters which should cause errors.
 22    *
 23    * If error could be logged it matches as follows:
 24    * SOSL_SERVER_LOG(caller, sosl_identifier, message) VALUES (p_script, p_identifier, p_message)
 25    * SOSLERRORLOG, SPERRORLOG(script, identifier, message) VALUES (p_script, p_identifier, p_message)
 26    * It will not prevent the exception, only try to log it somewhere, where it could be found without needing to analyze the db server
 27    * logs. Everything runs as autonomous transaction.
 28    *
 29    * DO NOT USE THIS PROCEDURE. It is internal for this package and only visible for testing.
 30    *
 31    * @param p_script The package function or procedure causing the error, e.g. sosl_log.log_event.
 32    * @param p_identifier The identifier for this error. Saved in SOSL_IDENTIFIER in SOSL_SERVER_LOG or IDENTIFIER in the error log tables.
 33    * @param p_message The message to save. Reduce it to SQLERRM if possible.
 34    */
 35    PROCEDURE log_fallback( p_script      IN VARCHAR2
 36  			     , p_identifier  IN VARCHAR2
 37  			     , p_message     IN VARCHAR2
 38  			     )
 39    ;
 40    /* PROCEDURE SOSL_LOG.LOG_EVENT
 41    * Writes a log entry as autonomous transaction. This is the internal base procedure, exposed for testing.
 42    * If on errors writing log entries is not possible the procedure hands the exception to the caller. This is the pure insert without
 43    * any checks. It takes the values as given and table may trigger exceptions. DO NOT USE THIS PROCEDURE. It is internal for this package.
 44    *
 45    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 46    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Must be valid.
 47    * @param p_log_category An optional logging category.
 48    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 49    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 50    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 51    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 52    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 53    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 54    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 55    */
 56    PROCEDURE log_event( p_message	       IN VARCHAR2
 57  			  , p_log_type	       IN VARCHAR2
 58  			  , p_log_category     IN VARCHAR2
 59  			  , p_guid	       IN VARCHAR2
 60  			  , p_sosl_identifier  IN VARCHAR2
 61  			  , p_executor_id      IN NUMBER
 62  			  , p_ext_script_id    IN VARCHAR2
 63  			  , p_caller	       IN VARCHAR2
 64  			  , p_run_id	       IN NUMBER
 65  			  , p_full_message     IN CLOB
 66  			  )
 67    ;
 68  /*====================================== end internal functions made visible for testing ======================================*/
 69  
 70    /* FUNCTION SOSL_LOG.LOG_TYPE_VALID
 71    * Central function to check the log type. Supports the log types defined in SOSL_CONSTANTS. If log types should get expanded
 72    * adjust constants, this function, the table constraint on log_type and probably the default value for SOSL_SERVER_LOG in
 73    * table definition and trigger.
 74    *
 75    * @param p_log_type The log type to check. Case insensitive.
 76    *
 77    *@return TRUE if the given log type is supported. FALSE if not. Exceptions and errors will lead also to FALSE.
 78    */
 79    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 80  	 RETURN BOOLEAN
 81  	 DETERMINISTIC
 82  	 PARALLEL_ENABLE
 83    ;
 84  
 85    /* FUNCTION SOSL_LOG.GET_VALID_LOG_TYPE
 86    * Verifies an given log type, returns either the given log type as upper case or the defined error default.
 87    *
 88    * @param p_log_type The log type to verify and return. Case insensitive.
 89    * @param p_error_default The alternative log type to return, if the log type is invalid. Must be a valid log type and not INFO or SUCCESS. If invalid, FATAL is returned.
 90    *
 91    * @return The valid log type as upper case on success. The valid error default if log type not supported. FATAL if the error default is invalid.
 92    */
 93    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 94  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_constants.LOG_ERROR_TYPE
 95  				  )
 96  	 RETURN VARCHAR2
 97  	 DETERMINISTIC
 98  	 PARALLEL_ENABLE
 99    ;
100  
101    /* FUNCTION SOSL_LOG.DISTRIBUTE
102    * This functions distributes char data between a VARCHAR2 and a CLOB variable by the following rules:
103    * p_string empty or NULL: Fill p_string to p_max_string_length - p_split_end length.
104    * p_string length > p_max_string_length: Cut p_string to p_max_string_length, including p_split_end appended.
105    *	  p_clob NOT EMPTY: add split_start, rest of p_string before p_clob content.
106    *	  p_clob EMPTY: add split_start and rest of p_string.
107    * p_string length > 0 and < p_max_string_length: no change of p_string and p_clob.
108    * p_string and p_clob empty or NULL: leave unchanged, return FALSE otherwise always TRUE.
109    * In case of exceptions will try to write SQLERRM to p_string as CLOBs tend to be more error prone.
110    * Mainly used by SOSL_SERVER_LOG.
111    *
112    * @param p_string The string to distribute or check. In PLSQL strings can get 32767 chars long, whereas table columns are limited currently to 4000.
113    * @param p_clob The CLOB to distribute or check. Uses NOCOPY to guarantee that CLOB full length is used as given.
114    * @param p_max_string_length The maximum length p_string should have. If this size is exeeded the string gets distribute between p_string and p_clob.
115    * @param p_split_end The split end characters to indicate that the string is continued in p_clob.
116    * @param p_split_start The split start characters for the continuing string in the CLOB.
117    * @param p_delimiter The delimiter between rest of string in CLOB and original CLOB content, if both have content and string must be splitted.
118    *
119    * @return FALSE if p_string and p_clob are empty/NULL or an exception had occurred, otherwise TRUE.
120    */
121    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
122  			  , p_clob		IN OUT NOCOPY  CLOB
123  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
124  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
125  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
126  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
127  			  )
128  	 RETURN BOOLEAN
129    ;
130  
131    /* PROCEDURE SOSL_LOG.FULL_LOG
132    * Procedure with all parameters for logging. Will check parameters before logging. You should at least set also p_log_category
133    * and p_caller, to be able to assign the log entry to a specific event and object. On parameter errors a separate log entry is
134    * created. Intention is to write a log in any case and not throw any exception. This still may happen on main system malfunctions
135    * but is limited to this events.
136    * To keep things as fast as possible, column length checks are hardcoded, no extra round trip to USER_TAB_COLUMNS. If table definition
137    * changes, this package has to be adjusted.
138    *
139    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
140    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Will be set to ERROR if not valid.
141    * @param p_log_category An optional logging category.
142    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
143    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
144    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
145    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
146    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
147    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
148    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
149    */
150    PROCEDURE full_log( p_message	      IN VARCHAR2
151  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_constants.LOG_INFO_TYPE
152  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
153  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
154  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
155  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
156  			 , p_executor_id      IN NUMBER      DEFAULT NULL
157  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
158  			 , p_run_id	      IN NUMBER      DEFAULT NULL
159  			 , p_full_message     IN CLOB	     DEFAULT NULL
160  			 )
161    ;
162  
163    /* PROCEDURE SOSL_LOG.EXCEPTION_LOG
164    * Prepared and standardize logging for unhandled exceptions with reduced parameters. This procedure will not deal with extra exceptions.
165    * It will try to log the exception and then return to the caller without raising any new exceptions or logging them. It is designed
166    * for relative stability in case of exceptions. Will do a simple NVL check on parameters, nothing more before formatting and submitting
167    * the log entry. Will set log type to SOSL_CONSTANTS.LOG_FATAL_TYPE.
168    *
169    * @param p_caller The full name of function, procedure or package that has caused the unhandled exception. Case sensitive.
170    * @param p_category The log category for the function, procedure or package. Case sensitive.
171    * @param p_sqlerrmsg The full error message, usually SQLERRM. Limited to VARCHAR2 limit 32767 chars.
172    */
173    PROCEDURE exception_log( p_caller     IN VARCHAR2
174  			      , p_category   IN VARCHAR2
175  			      , p_sqlerrmsg  IN VARCHAR2
176  			      )
177    ;
178  
179    /* PROCEDURE SOSL_LOG.MINIMAL_ERROR_LOG
180    * Prepared and standardize logging for errors with reduced parameters. Will do a simple NVL check on parameters, nothing more
181    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
182    * Will set log type to SOSL_CONSTANTS.LOG_ERROR_TYPE.
183    *
184    * @param p_caller The full name of function, procedure or package that has caused the error. Case sensitive.
185    * @param p_category The log category for the function, procedure or package. Case sensitive.
186    * @param p_short_msg The short error message, preferably smaller than 4000 chars. Will be formatted using p_caller.
187    * @param p_full_msg The complete error message, with details on the error. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
188    */
189    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
190  				  , p_category	 IN VARCHAR2
191  				  , p_short_msg  IN VARCHAR2
192  				  , p_full_msg	 IN CLOB     DEFAULT NULL
193  				  )
194    ;
195    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
196  				  , p_category	 IN VARCHAR2
197  				  , p_short_msg  IN VARCHAR2
198  				  , p_full_msg	 IN VARCHAR2
199  				  )
200    ;
201  
202    /* PROCEDURE SOSL_LOG.MINIMAL_ERROR_LOG
203    * Prepared and standardize logging for information with reduced parameters. Will do a simple NVL check on parameters, nothing more
204    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
205    * Will set log type to SOSL_CONSTANTS.LOG_INFO_TYPE.
206    *
207    * @param p_caller The full name of function, procedure or package that should be logged. Case sensitive.
208    * @param p_category The log category for the function, procedure or package. Case sensitive.
209    * @param p_short_msg The short info message, preferably smaller than 4000 chars. Will be formatted using p_caller.
210    * @param p_full_msg The complete info message, with details. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
211    */
212    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
213  				 , p_category	IN VARCHAR2
214  				 , p_short_msg	IN VARCHAR2
215  				 , p_full_msg	IN CLOB      DEFAULT NULL
216  				 )
217    ;
218    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
219  				 , p_category	IN VARCHAR2
220  				 , p_short_msg	IN VARCHAR2
221  				 , p_full_msg	IN VARCHAR2
222  				 )
223    ;
224  
225    /* PROCEDURE SOSL_LOG.MINIMAL_WARNING_LOG
226    * Prepared and standardize logging for warning with reduced parameters. Will do a simple NVL check on parameters, nothing more
227    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
228    * Will set log type to SOSL_CONSTANTS.LOG_WARNING_TYPE.
229    *
230    * @param p_caller The full name of function, procedure or package that should be logged. Case sensitive.
231    * @param p_category The log category for the function, procedure or package. Case sensitive.
232    * @param p_short_msg The short warning message, preferably smaller than 4000 chars. Will be formatted using p_caller.
233    * @param p_full_msg The complete warning message, with details. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
234    */
235    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
236  				    , p_category   IN VARCHAR2
237  				    , p_short_msg  IN VARCHAR2
238  				    , p_full_msg   IN CLOB     DEFAULT NULL
239  				    )
240    ;
241    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
242  				    , p_category   IN VARCHAR2
243  				    , p_short_msg  IN VARCHAR2
244  				    , p_full_msg   IN VARCHAR2
245  				    )
246    ;
247  
248    /* PROCEDURE SOSL_LOG.LOG_COLUMN_CHANGE
249    * Checks old and new values of a given column for differences and logs the difference. The log type will be WARNING if
250    * forbidden is TRUE, otherwise INFO. Supported types: VARCHAR2, NUMBER, DATE and TIMESTAMP
251    *
252    * @param p_old_value The old column value.
253    * @param p_new_value The new column value.
254    * @param p_column_name The name of the table and column, e.g. table.column that is checked for changes. No checks, apart from NULL, only log info. Used as log category.
255    * @param p_caller The name of the procedure, package, trigger or function that is calling this procedure. No checks, apart from NULL, only log info.
256    * @param p_forbidden Influences the log type, if TRUE the log type is WARNING else the log type is INFO.
257    */
258    PROCEDURE log_column_change( p_old_value     IN VARCHAR2
259  				  , p_new_value     IN VARCHAR2
260  				  , p_column_name   IN VARCHAR2
261  				  , p_caller	    IN VARCHAR2
262  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
263  				  )
264    ;
265    PROCEDURE log_column_change( p_old_value     IN NUMBER
266  				  , p_new_value     IN NUMBER
267  				  , p_column_name   IN VARCHAR2
268  				  , p_caller	    IN VARCHAR2
269  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
270  				  )
271    ;
272    PROCEDURE log_column_change( p_old_value     IN DATE
273  				  , p_new_value     IN DATE
274  				  , p_column_name   IN VARCHAR2
275  				  , p_caller	    IN VARCHAR2
276  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
277  				  )
278    ;
279    PROCEDURE log_column_change( p_old_value     IN TIMESTAMP
280  				  , p_new_value     IN TIMESTAMP
281  				  , p_column_name   IN VARCHAR2
282  				  , p_caller	    IN VARCHAR2
283  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
284  				  )
285    ;
286  
287  END;
288  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_log.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_log
  2  AS
  3    -- for description see header file
  4    PROCEDURE log_fallback( p_script      IN VARCHAR2
  5  			     , p_identifier  IN VARCHAR2
  6  			     , p_message     IN VARCHAR2
  7  			     )
  8    IS
  9  	 PRAGMA AUTONOMOUS_TRANSACTION;
 10  	 l_saved BOOLEAN;
 11    BEGIN
 12  	 l_saved := FALSE;
 13  	 -- try to save information in tables probably available
 14  	 BEGIN
 15  	   INSERT INTO sosl_server_log
 16  	     ( message
 17  	     , log_type
 18  	     , log_category
 19  	     , sosl_identifier
 20  	     , caller
 21  	     )
 22  	     VALUES
 23  	       ( p_message
 24  	       , sosl_constants.LOG_FATAL_TYPE
 25  	       , 'SOSL_LOG internal error'
 26  	       , p_identifier
 27  	       , p_script
 28  	       )
 29  	   ;
 30  	   COMMIT;
 31  	   l_saved := TRUE;
 32  	 EXCEPTION
 33  	   WHEN OTHERS THEN
 34  	     l_saved := FALSE;
 35  	 END;
 36  	 IF NOT l_saved
 37  	 THEN
 38  	   BEGIN
 39  	     INSERT INTO soslerrorlog
 40  	       ( message
 41  	       , identifier
 42  	       , script
 43  	       , username
 44  	       , timestamp
 45  	       )
 46  	       VALUES
 47  		 ( p_message
 48  		 , p_identifier
 49  		 , p_script
 50  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 51  		 , SYSTIMESTAMP
 52  		 )
 53  	     ;
 54  	     COMMIT;
 55  	     l_saved := TRUE;
 56  	   EXCEPTION
 57  	     WHEN OTHERS THEN
 58  	       l_saved := FALSE;
 59  	   END;
 60  	 END IF;
 61  	 IF NOT l_saved
 62  	 THEN
 63  	   BEGIN
 64  	     INSERT INTO sperrorlog
 65  	       ( message
 66  	       , identifier
 67  	       , script
 68  	       , username
 69  	       , timestamp
 70  	       )
 71  	       VALUES
 72  		 ( p_message
 73  		 , p_identifier
 74  		 , p_script
 75  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 76  		 , SYSTIMESTAMP
 77  		 )
 78  	     ;
 79  	     COMMIT;
 80  	     l_saved := TRUE;
 81  	   EXCEPTION
 82  	     WHEN OTHERS THEN
 83  	       l_saved := FALSE;
 84  	   END;
 85  	 END IF;
 86  	 -- all inserts failed, use DBMS_OUTPUT
 87  	 IF NOT l_saved
 88  	 THEN
 89  	   DBMS_OUTPUT.PUT_LINE('SOSL_LOG.LOG_FALLBACK could not save error. Fatal error in ' || p_script || ' error: ' || p_message);
 90  	 END IF;
 91    EXCEPTION
 92  	 WHEN OTHERS THEN
 93  	   -- fallback failed, let caller handle and raise the error, do nothing therefore.
 94  	   NULL;
 95    END log_fallback;
 96  
 97    PROCEDURE log_event( p_message	       IN VARCHAR2
 98  			  , p_log_type	       IN VARCHAR2
 99  			  , p_log_category     IN VARCHAR2
100  			  , p_guid	       IN VARCHAR2
101  			  , p_sosl_identifier  IN VARCHAR2
102  			  , p_executor_id      IN NUMBER
103  			  , p_ext_script_id    IN VARCHAR2
104  			  , p_caller	       IN VARCHAR2
105  			  , p_run_id	       IN NUMBER
106  			  , p_full_message     IN CLOB
107  			  )
108    IS
109  	 PRAGMA AUTONOMOUS_TRANSACTION;
110    BEGIN
111  	 INSERT INTO sosl_server_log
112  	   ( message
113  	   , log_type
114  	   , log_category
115  	   , guid
116  	   , sosl_identifier
117  	   , executor_id
118  	   , ext_script_id
119  	   , caller
120  	   , run_id
121  	   , full_message
122  	   )
123  	   VALUES
124  	     ( p_message
125  	     , p_log_type
126  	     , p_log_category
127  	     , p_guid
128  	     , p_sosl_identifier
129  	     , p_executor_id
130  	     , p_ext_script_id
131  	     , p_caller
132  	     , p_run_id
133  	     , p_full_message
134  	     )
135  	 ;
136  	 COMMIT;
137    EXCEPTION
138  	 WHEN OTHERS THEN
139  	   -- try fallback
140  	   log_fallback('sosl_log.log_event', 'SOSL_LOG', SQLERRM);
141  	   -- try ROLLBACK
142  	   ROLLBACK;
143  	   -- and raise the error again now
144  	   RAISE;
145    END log_event;
146  
147    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
148  	 RETURN BOOLEAN
149  	 DETERMINISTIC
150  	 PARALLEL_ENABLE
151    IS
152  	 l_return	     BOOLEAN;
153  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
154  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_type_valid';
155    BEGIN
156  	 l_return := FALSE;
157  	 IF UPPER(p_log_type) IN ( sosl_constants.LOG_INFO_TYPE
158  				 , sosl_constants.LOG_WARNING_TYPE
159  				 , sosl_constants.LOG_ERROR_TYPE
160  				 , sosl_constants.LOG_FATAL_TYPE
161  				 , sosl_constants.LOG_SUCCESS_TYPE
162  				 )
163  	 THEN
164  	   l_return := TRUE;
165  	 END IF;
166  	 RETURN l_return;
167    EXCEPTION
168  	 WHEN OTHERS THEN
169  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
170  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
171  		    , p_log_category => l_self_log_category
172  		    , p_guid => NULL
173  		    , p_sosl_identifier => NULL
174  		    , p_executor_id => NULL
175  		    , p_ext_script_id => NULL
176  		    , p_caller => l_self_caller
177  		    , p_run_id => NULL
178  		      -- full details
179  		    , p_full_message => SQLERRM
180  		    )
181  	   ;
182  	   RETURN FALSE;
183    END log_type_valid;
184  
185    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
186  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_constants.LOG_ERROR_TYPE
187  				  )
188  	 RETURN VARCHAR2
189  	 DETERMINISTIC
190  	 PARALLEL_ENABLE
191    IS
192  	 l_return	     VARCHAR2(30);
193  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
194  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.get_valid_log_type';
195    BEGIN
196  	 l_return := sosl_constants.LOG_FATAL_TYPE;
197  	 IF log_type_valid(p_log_type)
198  	 THEN
199  	   l_return := UPPER(p_log_type);
200  	 ELSE
201  	   IF	   log_type_valid(p_error_default)
202  	      AND  UPPER(p_error_default) NOT IN ( sosl_constants.LOG_INFO_TYPE
203  						 , sosl_constants.LOG_SUCCESS_TYPE
204  						 )
205  	   THEN
206  	     l_return := UPPER(p_error_default);
207  	   END IF;
208  	 END IF;
209  	 RETURN l_return;
210    EXCEPTION
211  	 WHEN OTHERS THEN
212  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
213  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
214  		    , p_log_category => l_self_log_category
215  		    , p_guid => NULL
216  		    , p_sosl_identifier => NULL
217  		    , p_executor_id => NULL
218  		    , p_ext_script_id => NULL
219  		    , p_caller => l_self_caller
220  		    , p_run_id => NULL
221  		      -- full details
222  		    , p_full_message => SQLERRM
223  		    )
224  	   ;
225  	   RETURN sosl_constants.LOG_FATAL_TYPE;
226    END get_valid_log_type;
227  
228    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
229  			  , p_clob		IN OUT NOCOPY  CLOB
230  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
231  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
232  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
233  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
234  			  )
235  	 RETURN BOOLEAN
236    IS
237  	 l_string	     VARCHAR2(32767);
238  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
239  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.distribute';
240    BEGIN
241  	 IF	(p_string IS NULL OR NVL(LENGTH(TRIM(p_string)), 0) = 0)
242  	    AND (p_clob   IS NULL OR NVL(LENGTH(TRIM(p_clob)), 0) = 0)
243  	 THEN
244  	   RETURN FALSE;
245  	 END IF;
246  	 IF	p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
247  	    AND p_clob	 IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
248  	 THEN
249  	   IF LENGTH(p_string) > p_max_string_length
250  	   THEN
251  	     -- need to split
252  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1)) || p_delimiter;
253  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
254  	     p_clob   := l_string || p_clob;
255  	   END IF;
256  	   RETURN TRUE;
257  	 END IF;
258  	 IF p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
259  	 THEN
260  	   IF LENGTH(p_string) > p_max_string_length
261  	   THEN
262  	     -- need to split
263  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1));
264  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
265  	     p_clob   := TO_CLOB(l_string);
266  	   ELSE
267  	     p_clob := TO_CLOB(l_string);
268  	   END IF;
269  	   RETURN TRUE;
270  	 END IF;
271  	 IF p_clob IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
272  	 THEN
273  	   IF LENGTH(p_clob) > p_max_string_length
274  	   THEN
275  	     p_string := TO_CHAR(SUBSTR(p_clob, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end);
276  	   ELSE
277  	     p_string := TO_CHAR(p_clob);
278  	   END IF;
279  	   RETURN TRUE;
280  	 END IF;
281  	 -- should not reach this point
282  	 log_event( p_message => l_self_caller || ': Logic incomplete. Procedure should exit before and not reach end of procedure'
283  		  , p_log_type => sosl_constants.LOG_FATAL_TYPE
284  		  , p_log_category => l_self_log_category
285  		  , p_guid => NULL
286  		  , p_sosl_identifier => NULL
287  		  , p_executor_id => NULL
288  		  , p_ext_script_id => NULL
289  		  , p_caller => l_self_caller
290  		  , p_run_id => NULL
291  		    -- full details
292  		  , p_full_message => SQLERRM
293  		  )
294  	 ;
295  	 RETURN FALSE;
296    EXCEPTION
297  	 WHEN OTHERS THEN
298  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
299  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
300  		    , p_log_category => l_self_log_category
301  		    , p_guid => NULL
302  		    , p_sosl_identifier => NULL
303  		    , p_executor_id => NULL
304  		    , p_ext_script_id => NULL
305  		    , p_caller => l_self_caller
306  		    , p_run_id => NULL
307  		      -- full details
308  		    , p_full_message => SQLERRM
309  		    )
310  	   ;
311  	   RETURN FALSE;
312    END distribute;
313  
314    PROCEDURE full_log( p_message	      IN VARCHAR2
315  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_constants.LOG_INFO_TYPE
316  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
317  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
318  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
319  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
320  			 , p_executor_id      IN NUMBER      DEFAULT NULL
321  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
322  			 , p_run_id	      IN NUMBER      DEFAULT NULL
323  			 , p_full_message     IN CLOB	     DEFAULT NULL
324  			 )
325    IS
326  	 -- set variables to current type
327  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
328  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.full_log';
329  	 l_log_category      sosl_server_log.log_category%TYPE;
330  	 l_caller	     sosl_server_log.caller%TYPE;
331  	 l_guid 	     sosl_server_log.guid%TYPE;
332  	 l_sosl_identifier   sosl_server_log.sosl_identifier%TYPE;
333  	 l_executor_id	     sosl_server_log.executor_id%TYPE;
334  	 l_ext_script_id     sosl_server_log.ext_script_id%TYPE;
335  	 l_run_id	     sosl_server_log.run_id%TYPE;
336  	 l_col_length	     INTEGER;
337    BEGIN
338  	 -- basic column checks message splitting is left to table triggers
339  	 -- LOG_CATEGORY
340  	 IF NVL(LENGTH(TRIM(p_log_category)), 0) > 256
341  	 THEN
342  	   -- write extra log entry and cut original content to limit
343  	   log_event( p_message => l_self_caller || ': p_log_category length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
344  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
345  		    , p_log_category => l_self_log_category
346  		    , p_guid => NULL
347  		    , p_sosl_identifier => NULL
348  		    , p_executor_id => NULL
349  		    , p_ext_script_id => NULL
350  		    , p_caller => l_self_caller
351  		    , p_run_id => NULL
352  		      -- details and original message
353  		    , p_full_message => ('LOG_CATEGORY: ' || TRIM(p_log_category) || ' length: ' || LENGTH(TRIM(p_log_category)) || ' msg: ' || p_message || ' - ' || p_full_message)
354  		    )
355  	   ;
356  	   l_log_category := SUBSTR(TRIM(p_log_category), 1, 256);
357  	 ELSE
358  	   l_log_category := NVL(TRIM(p_log_category), sosl_constants.GEN_NA_TYPE);
359  	 END IF;
360  	 -- CALLER
361  	 IF NVL(LENGTH(TRIM(p_caller)), 0) > 256
362  	 THEN
363  	   -- write extra log entry and cut original content to limit
364  	   log_event( p_message => l_self_caller || ': p_caller length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
365  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
366  		    , p_log_category => l_self_log_category
367  		    , p_guid => NULL
368  		    , p_sosl_identifier => NULL
369  		    , p_executor_id => NULL
370  		    , p_ext_script_id => NULL
371  		    , p_caller => l_self_caller
372  		    , p_run_id => NULL
373  		      -- details and original message
374  		    , p_full_message => ('CALLER: ' || TRIM(p_caller) || ' length: ' || LENGTH(TRIM(p_caller)) || ' msg: ' || p_message || ' - ' || p_full_message)
375  		    )
376  	   ;
377  	   l_caller := SUBSTR(TRIM(p_caller), 1, 256);
378  	 ELSE
379  	   l_caller := TRIM(p_caller);
380  	 END IF;
381  	 -- GUID
382  	 IF NVL(LENGTH(TRIM(p_guid)), 0) > 64
383  	 THEN
384  	   -- write extra log entry and cut original content to limit
385  	   log_event( p_message => l_self_caller || ': p_guid length exceeds column length (64) in SOSL_SERVER_LOG. See full message for message causing the error.'
386  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
387  		    , p_log_category => l_self_log_category
388  		    , p_guid => NULL
389  		    , p_sosl_identifier => NULL
390  		    , p_executor_id => NULL
391  		    , p_ext_script_id => NULL
392  		    , p_caller => l_self_caller
393  		    , p_run_id => NULL
394  		      -- details and original message
395  		    , p_full_message => ('GUID: ' || TRIM(p_guid) || ' length: ' || LENGTH(TRIM(p_guid)) || ' msg: ' || p_message || ' - ' || p_full_message)
396  		    )
397  	   ;
398  	   l_guid := SUBSTR(TRIM(p_guid), 1, 64);
399  	 ELSE
400  	   l_guid := TRIM(p_guid);
401  	 END IF;
402  	 -- SOSL_IDENTIFIER
403  	 IF NVL(LENGTH(TRIM(p_sosl_identifier)), 0) > 256
404  	 THEN
405  	   -- write extra log entry and cut original content to limit
406  	   log_event( p_message => l_self_caller || ': p_sosl_identifier length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
407  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
408  		    , p_log_category => l_self_log_category
409  		    , p_guid => NULL
410  		    , p_sosl_identifier => NULL
411  		    , p_executor_id => NULL
412  		    , p_ext_script_id => NULL
413  		    , p_caller => l_self_caller
414  		    , p_run_id => NULL
415  		      -- details and original message
416  		    , p_full_message => ('SOSL_IDENTIFIER: ' || TRIM(p_sosl_identifier) || ' length: ' || LENGTH(TRIM(p_sosl_identifier)) || ' msg: ' || p_message || ' - ' || p_full_message)
417  		    )
418  	   ;
419  	   l_sosl_identifier := SUBSTR(TRIM(p_sosl_identifier), 1, 256);
420  	 ELSE
421  	   l_sosl_identifier := TRIM(p_sosl_identifier);
422  	 END IF;
423  	 -- EXT_SCRIPT_ID
424  	 IF NVL(LENGTH(TRIM(p_ext_script_id)), 0) > 4000
425  	 THEN
426  	   -- write extra log entry and cut original content to limit
427  	   log_event( p_message => l_self_caller || ': p_ext_script_id length exceeds column length (4000) in SOSL_SERVER_LOG. See full message for message causing the error.'
428  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
429  		    , p_log_category => l_self_log_category
430  		    , p_guid => NULL
431  		    , p_sosl_identifier => NULL
432  		    , p_executor_id => NULL
433  		    , p_ext_script_id => NULL
434  		    , p_caller => l_self_caller
435  		    , p_run_id => NULL
436  		      -- details and original message
437  		    , p_full_message => ('EXT_SCRIPT_ID: ' || TRIM(p_ext_script_id) || ' length: ' || LENGTH(TRIM(p_ext_script_id)) || ' msg: ' || p_message || ' - ' || p_full_message)
438  		    )
439  	   ;
440  	   l_ext_script_id := SUBSTR(TRIM(p_ext_script_id), 1, 4000);
441  	 ELSE
442  	   l_ext_script_id := TRIM(p_ext_script_id);
443  	 END IF;
444  	 -- no check on numbers
445  	 l_executor_id := p_executor_id;
446  	 l_run_id := p_run_id;
447  	 -- try to write the given data to SOSL_SERVER_LOG
448  	 log_event( p_message => p_message
449  		  , p_log_type => p_log_type
450  		  , p_log_category => l_log_category
451  		  , p_guid => l_guid
452  		  , p_sosl_identifier => l_sosl_identifier
453  		  , p_executor_id => l_executor_id
454  		  , p_ext_script_id => l_ext_script_id
455  		  , p_caller => l_caller
456  		  , p_run_id => l_run_id
457  		  , p_full_message => p_full_message
458  		  )
459  	 ;
460    EXCEPTION
461  	 WHEN OTHERS THEN
462  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
463  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
464  		    , p_log_category => l_self_log_category
465  		    , p_guid => NULL
466  		    , p_sosl_identifier => NULL
467  		    , p_executor_id => NULL
468  		    , p_ext_script_id => NULL
469  		    , p_caller => l_self_caller
470  		    , p_run_id => NULL
471  		      -- full details and original message
472  		    , p_full_message => (SQLERRM || ': ' || p_message)
473  		    )
474  	   ;
475    END full_log;
476  
477    PROCEDURE exception_log( p_caller     IN VARCHAR2
478  			      , p_category   IN VARCHAR2
479  			      , p_sqlerrmsg  IN VARCHAR2
480  			      )
481    IS
482  	 l_category  sosl_server_log.log_category%TYPE;
483  	 l_caller    sosl_server_log.caller%TYPE;
484  	 l_message   VARCHAR2(32767);
485    BEGIN
486  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
487  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
488  	 l_message   := NVL(p_sqlerrmsg, 'Called sosl_log.exception_log without message.');
489  	 log_event( p_message => l_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(l_message, 1, 500)) || CASE WHEN LENGTH(l_message) > 500 THEN ' ... see full_message for complete details.' END
490  		  , p_log_type => sosl_constants.LOG_FATAL_TYPE
491  		  , p_log_category => l_category
492  		  , p_guid => NULL
493  		  , p_sosl_identifier => NULL
494  		  , p_executor_id => NULL
495  		  , p_ext_script_id => NULL
496  		  , p_caller => l_caller
497  		  , p_run_id => NULL
498  		    -- full details and original message
499  		  , p_full_message => l_message
500  		  )
501  	 ;
502    EXCEPTION
503  	 WHEN OTHERS THEN
504  	   -- no extra trouble if already in exception state
505  	   NULL;
506    END exception_log;
507  
508    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
509  				  , p_category	 IN VARCHAR2
510  				  , p_short_msg  IN VARCHAR2
511  				  , p_full_msg	 IN CLOB     DEFAULT NULL
512  				  )
513    IS
514  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
515  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_error_log CLOB';
516  	 l_category	     sosl_server_log.log_category%TYPE;
517  	 l_caller	     sosl_server_log.caller%TYPE;
518  	 l_short_msg	     VARCHAR2(32767);
519  	 l_full_msg	     CLOB;
520    BEGIN
521  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
522  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
523  	 IF p_short_msg IS NULL AND p_full_msg IS NULL
524  	 THEN
525  	   l_short_msg := l_caller || ': ERROR = Called sosl_log.minimal_error_log without any message.';
526  	   l_full_msg  := l_caller || ': ERROR = Called sosl_log.minimal_error_log without any message.';
527  	 ELSIF p_short_msg IS NULL AND p_full_msg IS NOT NULL
528  	 THEN
529  	   -- split long message
530  	   l_short_msg := l_caller || ': ERROR = ' || SUBSTR(p_full_msg, 1, 500) || CASE WHEN LENGTH(p_full_msg) > 500 THEN ' ... see full_message for complete details.' END;
531  	   l_full_msg  := p_full_msg;
532  	 ELSIF LENGTH(p_short_msg) > 3600
533  	 THEN
534  	   -- a very long short message, handle the overflow and distribute it to full message, we do not check for 4000 length to have some formatting space
535  	   l_short_msg := l_caller || ': ERROR = ' || SUBSTR(p_short_msg, 1, 500) || ' ... see full_message for complete details.';
536  	   l_full_msg  := '... ' || SUBSTR(p_short_msg, 501) || ' - ' || p_full_msg;
537  	 ELSE
538  	   -- if long message is NULL we do not care, maybe NULL or given, handled as given.
539  	   l_short_msg := l_caller || ': ERROR = ' || p_short_msg;
540  	   l_full_msg  := p_full_msg;
541  	 END IF;
542  	 log_event( p_message => l_short_msg
543  		  , p_log_type => sosl_constants.LOG_ERROR_TYPE
544  		  , p_log_category => l_category
545  		  , p_guid => NULL
546  		  , p_sosl_identifier => NULL
547  		  , p_executor_id => NULL
548  		  , p_ext_script_id => NULL
549  		  , p_caller => l_caller
550  		  , p_run_id => NULL
551  		    -- full details and original message
552  		  , p_full_message => l_full_msg
553  		  )
554  	 ;
555    EXCEPTION
556  	 WHEN OTHERS THEN
557  	   -- log exception as we should not be already in exception state, only application error
558  	   -- do not raise again
559  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
560    END minimal_error_log;
561  
562    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
563  				  , p_category	 IN VARCHAR2
564  				  , p_short_msg  IN VARCHAR2
565  				  , p_full_msg	 IN VARCHAR2
566  				  )
567    IS
568  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
569  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_error_log VARCHAR2';
570    BEGIN
571  	 sosl_log.minimal_error_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
572    EXCEPTION
573  	 WHEN OTHERS THEN
574  	   -- log exception as we should not be already in exception state, only application error
575  	   -- do not raise again
576  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
577    END minimal_error_log;
578  
579    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
580  				 , p_category	IN VARCHAR2
581  				 , p_short_msg	IN VARCHAR2
582  				 , p_full_msg	IN CLOB      DEFAULT NULL
583  				 )
584    IS
585  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
586  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_info_log CLOB';
587  	 l_category	     sosl_server_log.log_category%TYPE;
588  	 l_caller	     sosl_server_log.caller%TYPE;
589  	 l_short_msg	     VARCHAR2(32767);
590  	 l_full_msg	     CLOB;
591    BEGIN
592  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
593  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
594  	 IF p_short_msg IS NULL AND p_full_msg IS NULL
595  	 THEN
596  	   l_short_msg := l_caller || ': ERROR = Called sosl_log.minimal_info_log without any message.';
597  	   l_full_msg  := l_caller || ': ERROR = Called sosl_log.minimal_info_log without any message.';
598  	 ELSIF p_short_msg IS NULL AND p_full_msg IS NOT NULL
599  	 THEN
600  	   -- split long message
601  	   l_short_msg := SUBSTR(p_full_msg, 1, 500) || CASE WHEN LENGTH(p_full_msg) > 500 THEN ' ... see full_message for complete details.' END;
602  	   l_full_msg  := p_full_msg;
603  	 ELSIF LENGTH(p_short_msg) > 3600
604  	 THEN
605  	   -- a very long short message, handle the overflow and distribute it to full message, we do not check for 4000 length to have some formatting space
606  	   l_short_msg := SUBSTR(p_short_msg, 1, 500) || ' ... see full_message for complete details.';
607  	   l_full_msg  := '... ' || SUBSTR(p_short_msg, 501) || ' - ' || p_full_msg;
608  	 ELSE
609  	   -- if long message is NULL we do not care, maybe NULL or given, handled as given.
610  	   l_short_msg := p_short_msg;
611  	   l_full_msg  := p_full_msg;
612  	 END IF;
613  	 log_event( p_message => l_short_msg
614  		  , p_log_type => sosl_constants.LOG_INFO_TYPE
615  		  , p_log_category => l_category
616  		  , p_guid => NULL
617  		  , p_sosl_identifier => NULL
618  		  , p_executor_id => NULL
619  		  , p_ext_script_id => NULL
620  		  , p_caller => l_caller
621  		  , p_run_id => NULL
622  		    -- full details and original message
623  		  , p_full_message => l_full_msg
624  		  )
625  	 ;
626    EXCEPTION
627  	 WHEN OTHERS THEN
628  	   -- log exception as we should not be already in exception state, only application error
629  	   -- do not raise again
630  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
631    END minimal_info_log;
632  
633    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
634  				 , p_category	IN VARCHAR2
635  				 , p_short_msg	IN VARCHAR2
636  				 , p_full_msg	IN VARCHAR2
637  				 )
638    IS
639  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
640  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_info_log VARCHAR2';
641    BEGIN
642  	 sosl_log.minimal_info_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
643    EXCEPTION
644  	 WHEN OTHERS THEN
645  	   -- log exception as we should not be already in exception state, only application error
646  	   -- do not raise again
647  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
648    END minimal_info_log;
649  
650    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
651  				    , p_category   IN VARCHAR2
652  				    , p_short_msg  IN VARCHAR2
653  				    , p_full_msg   IN CLOB     DEFAULT NULL
654  				    )
655    IS
656  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
657  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_warning_log CLOB';
658  	 l_category	     sosl_server_log.log_category%TYPE;
659  	 l_caller	     sosl_server_log.caller%TYPE;
660  	 l_short_msg	     VARCHAR2(32767);
661  	 l_full_msg	     CLOB;
662    BEGIN
663  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
664  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
665  	 IF p_short_msg IS NULL AND p_full_msg IS NULL
666  	 THEN
667  	   l_short_msg := l_caller || ': ERROR = Called sosl_log.minimal_warning_log without any message.';
668  	   l_full_msg  := l_caller || ': ERROR = Called sosl_log.minimal_warning_log without any message.';
669  	 ELSIF p_short_msg IS NULL AND p_full_msg IS NOT NULL
670  	 THEN
671  	   -- split long message
672  	   l_short_msg := SUBSTR(p_full_msg, 1, 500) || CASE WHEN LENGTH(p_full_msg) > 500 THEN ' ... see full_message for complete details.' END;
673  	   l_full_msg  := p_full_msg;
674  	 ELSIF LENGTH(p_short_msg) > 3600
675  	 THEN
676  	   -- a very long short message, handle the overflow and distribute it to full message, we do not check for 4000 length to have some formatting space
677  	   l_short_msg := SUBSTR(p_short_msg, 1, 500) || ' ... see full_message for complete details.';
678  	   l_full_msg  := '... ' || SUBSTR(p_short_msg, 501) || ' - ' || p_full_msg;
679  	 ELSE
680  	   -- if long message is NULL we do not care, maybe NULL or given, handled as given.
681  	   l_short_msg := p_short_msg;
682  	   l_full_msg  := p_full_msg;
683  	 END IF;
684  	 log_event( p_message => l_short_msg
685  		  , p_log_type => sosl_constants.LOG_WARNING_TYPE
686  		  , p_log_category => l_category
687  		  , p_guid => NULL
688  		  , p_sosl_identifier => NULL
689  		  , p_executor_id => NULL
690  		  , p_ext_script_id => NULL
691  		  , p_caller => l_caller
692  		  , p_run_id => NULL
693  		    -- full details and original message
694  		  , p_full_message => l_full_msg
695  		  )
696  	 ;
697    EXCEPTION
698  	 WHEN OTHERS THEN
699  	   -- log exception as we should not be already in exception state, only application error
700  	   -- do not raise again
701  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
702    END minimal_warning_log;
703  
704    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
705  				    , p_category   IN VARCHAR2
706  				    , p_short_msg  IN VARCHAR2
707  				    , p_full_msg   IN VARCHAR2
708  				    )
709    IS
710  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
711  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_warning_log VARCHAR2';
712    BEGIN
713  	 sosl_log.minimal_warning_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
714    EXCEPTION
715  	 WHEN OTHERS THEN
716  	   -- log exception as we should not be already in exception state, only application error
717  	   -- do not raise again
718  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
719    END minimal_warning_log;
720  
721    PROCEDURE log_column_change( p_old_value     IN VARCHAR2
722  				  , p_new_value     IN VARCHAR2
723  				  , p_column_name   IN VARCHAR2
724  				  , p_caller	    IN VARCHAR2
725  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
726  				  )
727    IS
728  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
729  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change VARCHAR2';
730  	 l_log_category      sosl_server_log.log_category%TYPE;
731  	 l_caller	     sosl_server_log.caller%TYPE;
732    BEGIN
733  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
734  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
735  	   -- log parameter errors
736  	 IF p_column_name IS NULL
737  	 THEN
738  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
739  	 END IF;
740  	 IF p_caller IS NULL
741  	 THEN
742  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
743  	 END IF;
744  	 IF NVL(p_old_value, sosl_constants.GEN_NA_TYPE) != NVL(p_new_value, sosl_constants.GEN_NA_TYPE)
745  	 THEN
746  	   IF p_forbidden
747  	   THEN
748  	     sosl_log.minimal_warning_log( l_caller
749  					 , l_log_category
750  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(p_new_value, sosl_constants.GEN_NULL_TEXT)
751  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
752  					 )
753  	     ;
754  	   ELSE
755  	     sosl_log.minimal_info_log( l_caller
756  				      , l_log_category
757  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(p_old_value, sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(p_new_value, sosl_constants.GEN_NULL_TEXT)
758  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
759  				      )
760  	     ;
761  	   END IF;
762  	 END IF;
763    EXCEPTION
764  	 WHEN OTHERS THEN
765  	   -- log exception as we should not be already in exception state, only application error
766  	   -- do not raise again
767  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
768    END log_column_change; -- VARCHAR2
769  
770    PROCEDURE log_column_change( p_old_value     IN NUMBER
771  				  , p_new_value     IN NUMBER
772  				  , p_column_name   IN VARCHAR2
773  				  , p_caller	    IN VARCHAR2
774  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
775  				  )
776    IS
777  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
778  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change NUMBER';
779  	 l_log_category      sosl_server_log.log_category%TYPE;
780  	 l_caller	     sosl_server_log.caller%TYPE;
781    BEGIN
782  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
783  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
784  	   -- log parameter errors
785  	 IF p_column_name IS NULL
786  	 THEN
787  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
788  	 END IF;
789  	 IF p_caller IS NULL
790  	 THEN
791  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
792  	 END IF;
793  	 -- use TO_CHAR for comparing NULL values as there is no invalid number symbol
794  	 IF NVL(TO_CHAR(p_old_value), sosl_constants.GEN_NA_TYPE) != NVL(TO_CHAR(p_new_value), sosl_constants.GEN_NA_TYPE)
795  	 THEN
796  	   IF p_forbidden
797  	   THEN
798  	     sosl_log.minimal_warning_log( l_caller
799  					 , l_log_category
800  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(TO_CHAR(p_new_value), sosl_constants.GEN_NULL_TEXT)
801  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
802  					 )
803  	     ;
804  	   ELSE
805  	     sosl_log.minimal_info_log( l_caller
806  				      , l_log_category
807  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(TO_CHAR(p_old_value), sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(TO_CHAR(p_new_value), sosl_constants.GEN_NULL_TEXT)
808  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
809  				      )
810  	     ;
811  	   END IF;
812  	 END IF;
813    EXCEPTION
814  	 WHEN OTHERS THEN
815  	   -- log exception as we should not be already in exception state, only application error
816  	   -- do not raise again
817  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
818    END log_column_change; -- NUMBER
819  
820    PROCEDURE log_column_change( p_old_value     IN DATE
821  				  , p_new_value     IN DATE
822  				  , p_column_name   IN VARCHAR2
823  				  , p_caller	    IN VARCHAR2
824  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
825  				  )
826    IS
827  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
828  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change DATE';
829  	 l_log_category      sosl_server_log.log_category%TYPE;
830  	 l_caller	     sosl_server_log.caller%TYPE;
831    BEGIN
832  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
833  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
834  	   -- log parameter errors
835  	 IF p_column_name IS NULL
836  	 THEN
837  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
838  	 END IF;
839  	 IF p_caller IS NULL
840  	 THEN
841  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
842  	 END IF;
843  	 IF NVL(p_old_value, sosl_constants.GEN_NA_DATE_TYPE) != NVL(p_new_value, sosl_constants.GEN_NA_DATE_TYPE)
844  	 THEN
845  	   IF p_forbidden
846  	   THEN
847  	     sosl_log.minimal_warning_log( l_caller
848  					 , l_log_category
849  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_DATE_FORMAT), sosl_constants.GEN_NULL_TEXT)
850  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
851  					 )
852  	     ;
853  	   ELSE
854  	     sosl_log.minimal_info_log( l_caller
855  				      , l_log_category
856  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(TO_CHAR(p_old_value, sosl_constants.GEN_DATE_FORMAT), sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_DATE_FORMAT), sosl_constants.GEN_NULL_TEXT)
857  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
858  				      )
859  	     ;
860  	   END IF;
861  	 END IF;
862    EXCEPTION
863  	 WHEN OTHERS THEN
864  	   -- log exception as we should not be already in exception state, only application error
865  	   -- do not raise again
866  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
867    END log_column_change; -- DATE
868  
869    PROCEDURE log_column_change( p_old_value     IN TIMESTAMP
870  				  , p_new_value     IN TIMESTAMP
871  				  , p_column_name   IN VARCHAR2
872  				  , p_caller	    IN VARCHAR2
873  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
874  				  )
875    IS
876  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
877  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change TIMESTAMP';
878  	 l_log_category      sosl_server_log.log_category%TYPE;
879  	 l_caller	     sosl_server_log.caller%TYPE;
880    BEGIN
881  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
882  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
883  	   -- log parameter errors
884  	 IF p_column_name IS NULL
885  	 THEN
886  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
887  	 END IF;
888  	 IF p_caller IS NULL
889  	 THEN
890  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
891  	 END IF;
892  	 IF NVL(p_old_value, sosl_constants.GEN_NA_TIMESTAMP_TYPE) != NVL(p_new_value, sosl_constants.GEN_NA_TIMESTAMP_TYPE)
893  	 THEN
894  	   IF p_forbidden
895  	   THEN
896  	     sosl_log.minimal_warning_log( l_caller
897  					 , l_log_category
898  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_TIMESTAMP_FORMAT), sosl_constants.GEN_NULL_TEXT)
899  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
900  					 )
901  	     ;
902  	   ELSE
903  	     sosl_log.minimal_info_log( l_caller
904  				      , l_log_category
905  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(TO_CHAR(p_old_value, sosl_constants.GEN_TIMESTAMP_FORMAT), sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_TIMESTAMP_FORMAT), sosl_constants.GEN_NULL_TEXT)
906  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
907  				      )
908  	     ;
909  	   END IF;
910  	 END IF;
911    EXCEPTION
912  	 WHEN OTHERS THEN
913  	   -- log exception as we should not be already in exception state, only application error
914  	   -- do not raise again
915  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
916    END log_column_change; -- TIMESTAMP
917  
918  END;
919  /

Package body created.

SQL> -- util package
SQL> @@../sosl_ddl/packages/sosl_util.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic util package not using data objects of the Simple Oracle Script Loader, apart from sosl_sys and logging.
SQL> CREATE OR REPLACE PACKAGE sosl_util
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader that have minimal dependencies on
  5    * SOSL object. Provides logging.
  6    */
  7  
  8    /* PROCEDURE SOSL_UTIL.SPLIT_FUNCTION_NAME
  9    * Splits the given function name into its parts. Supposed delimiter is the point ".".
 10    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 11    * @param p_package OUT parameter, contains the package name if any or NULL.
 12    * @param p_function OUT parameter, contains the pure function name.
 13    */
 14    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
 15  				    , p_package       OUT VARCHAR2
 16  				    , p_function      OUT VARCHAR2
 17  				    )
 18    ;
 19  
 20    /* FUNCTION SOSL_UTIL.HAS_DB_USER
 21    * Checks if a given user is visible for SOSL by checking ALL_USERS. Users must be visible to SOSL to be able to dynamically
 22    * grant the necessary rights on the API for script execution.
 23    *
 24    * @param p_username The database user name to check.
 25    *
 26    * @return TRUE if the user is visible in ALL_USERS to SOSL, otherwise FALSE.
 27    */
 28    FUNCTION has_db_user(p_username IN VARCHAR2)
 29  	 RETURN BOOLEAN
 30    ;
 31  
 32    /* FUNCTION SOSL_UTIL.HAS_FUNCTION
 33    * Checks if a given function or package function name is visible for SOSL by checking ALL_ATTRIBUTES. The package SOSL_API is
 34    * excluded from the search to avoid references in SOSL_EXECUTOR.
 35    *
 36    * @param p_owner The owner of the function or package function name to check.
 37    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 38    * @param p_datatype The return datatype of the function expected, e.g. a valid Oracle datatype like NUMBER or VARCHAR2.
 39    *
 40    * @return TRUE if the function is visible in ALL_ATTRIBUTES to SOSL and has the required return datatype, otherwise FALSE.
 41    */
 42    FUNCTION has_function( p_owner	       IN VARCHAR2
 43  			    , p_function_name  IN VARCHAR2
 44  			    , p_datatype       IN VARCHAR2
 45  			    )
 46  	 RETURN BOOLEAN
 47    ;
 48  
 49    /*FUNCTION SOSL_UTIL.GET_COL_LENGTH
 50    * Returns the column length for a given table and column or -1 if table or column does not exist from USER_TAB_COLUMNS using
 51    * DATA_LENGTH. DATA_LENGTH is misleading if not a char type or CLOB, as CLOB types report 4000 which is definitely wrong.
 52    * The only types handled are NUMBER and CLOB. All other types return the DATA_LENGTH.
 53    *
 54    * Length for numbers is calculated by adding precision and scale.
 55    *
 56    * CLOB will return the PLSQL equation of a VARCHAR2/CLOB, which is 32767 and still wrong, but useful to see if a PLSQL can handle
 57    * the CLOB. Be careful with CLOB handling. If source is not a table column, PLSQL most likely limits it to 32767 cutting longer content.
 58    *
 59    * Objects not in the current schema will not be considered and return -1 AS USER_TAB_COLUMN is used.
 60    *
 61    * No handling for date and timestamp values, as their char representation has too much dependencies on NLS and formatting to get a
 62    * reliable length.
 63    *
 64    * Byte and char semantic is not considered only the effective chars that can be stored in CHAR or VARCHAR2 as defined by DATA_LENGTH.
 65    *
 66    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
 67    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
 68    *
 69    * @return The calculated length of the column. Fix PLSQL limit 32767 for CLOB types. DATA_LENGTH for data and timestamp types.
 70    */
 71    FUNCTION get_col_length( p_table  IN VARCHAR2
 72  			      , p_column IN VARCHAR2
 73  			      )
 74  	 RETURN INTEGER
 75    ;
 76  
 77    /* FUNCTION SOSL_UTIL.GET_COL_TYPE
 78    * Returns the type of a column from USER_TAB_COLUMNS as defined in DATA_TYPE or NA_TYPE if table or column doesn't exist.
 79    * Objects not in the current schema will not be considered and return NA_TYPE.
 80    *
 81    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
 82    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
 83    *
 84    * @return The type of the column as defined in DATA_TYPE or sosl_sys.NA_TYPE on errors or not found columns and tables.
 85    */
 86    FUNCTION get_col_type( p_table  IN VARCHAR2
 87  			    , p_column IN VARCHAR2
 88  			    )
 89  	 RETURN VARCHAR2
 90    ;
 91  
 92    /* FUNCTION SOSL_UTIL.CHECK_COL
 93    * This function can check NUMBER and VARCHAR2/CHAR columns for length and type. Passing a number for a char column type will result
 94    * in FALSE. Providing a P_VALUE with a length longer than the length calculated, will result in FALSE. It will not consider
 95    * implicite Oracle conversions. Expects type like defined.
 96    *
 97    * Number length is calculated by TO_CHAR string representation removing all delimiters and counting only numbers 0-9.
 98    * Passing a VARCHAR2 value is valid for CHAR and VARCHAR2 column types.
 99    *
100    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
101    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
102    * @param p_value The value for the table column to check against column definition.
103    *
104    * @return TRUE if value and column match in type and length, otherwise FALSE.
105    */
106    FUNCTION check_col( p_table  IN VARCHAR2
107  			 , p_column IN VARCHAR2
108  			 , p_value  IN VARCHAR2
109  			 )
110  	 RETURN BOOLEAN
111    ;
112    FUNCTION check_col( p_table  IN VARCHAR2
113  			 , p_column IN VARCHAR2
114  			 , p_value  IN NUMBER
115  			 )
116  	 RETURN BOOLEAN
117    ;
118  
119    /* FUNCTION SOSL_UTIL.HAS_ROLE
120    * This function determines if a given database user has the requested role granted.
121    *
122    * @param p_db_user The database user to check. Has to be a valid database user.
123    * @param p_role The role to check. Limited to roles starting with SOSL. Must be a valid and existing role.
124    *
125    * @return Will return TRUE, if user has the role assigned, otherwise FALSE, also in case of errors which get logged.
126    */
127    FUNCTION has_role( p_db_user IN VARCHAR2
128  			, p_role    IN VARCHAR2
129  			)
130  	 RETURN BOOLEAN
131    ;
132  
133    /* FUNCTION SOSL_UTIL.GRANT_ROLE
134    * This function grants a given database user the given role.
135    *
136    * @param p_db_user The database user to get the role grant. Has to be a valid database user.
137    * @param p_role The role to grant. Limited to roles starting with SOSL. Must be a valid and existing role with ADMIN rights for SOSL schema.
138    *
139    * @return Will return TRUE, if user has the role or has been granted the role successfully, otherwise FALSE, also in case of errors which get logged.
140    */
141    FUNCTION grant_role( p_db_user IN VARCHAR2
142  			  , p_role    IN VARCHAR2
143  			  )
144  	 RETURN BOOLEAN
145    ;
146  
147    /* FUNCTION SOSL_UTIL.REVOKE_ROLE
148    * This function revoke a given role from a given database user.
149    *
150    * @param p_db_user The database user to remove the role grant. Has to be a valid database user.
151    * @param p_role The role to remove. Limited to roles starting with SOSL. Must be a valid and existing role with ADMIN rights for SOSL schema.
152    *
153    * @return Will return TRUE, if user has not the role or has been revoked the role successfully, otherwise FALSE, also in case of errors which get logged.
154    */
155    FUNCTION revoke_role( p_db_user IN VARCHAR2
156  			   , p_role    IN VARCHAR2
157  			   )
158  	 RETURN BOOLEAN
159    ;
160  
161    /* FUNCTION SOSL_UTIL.UTC_MAIL_DATE
162    * Returns the current date timestamp as a formatted string for date values in mail.
163    *
164    * @return A date string conform to RFC5322 for using mail or NULL on errors.
165    *
166    * @see https://datatracker.ietf.org/doc/html/rfc5322
167    */
168    FUNCTION utc_mail_date
169  	 RETURN VARCHAR2
170    ;
171  
172    /* FUNCTION SOSL_UTIL.FORMAT_MAIL
173    * This function formats a mail message conforming to RFC5322. The content of p_message is not checked against RFC. This is
174    * the repsonsibility of the user. This is for small messages that do not exceed 32k in total.
175    *
176    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
177    * @param p_recipients The semicolon separated list of mail recipient addresses.
178    * @param p_subject A preferablly short subject for the mail.
179    * @param p_message The correctly formatted mail message.
180    *
181    * @return A formatted string with complete mail message that can be used with RFC compliant mail servers or NULL on errors.
182    */
183    FUNCTION format_mail( p_sender	   IN VARCHAR2
184  			   , p_recipients  IN VARCHAR2
185  			   , p_subject	   IN VARCHAR2
186  			   , p_message	   IN VARCHAR2
187  			   )
188  	 RETURN VARCHAR2
189    ;
190  
191    /* FUNCTION SOSL_UTIL.CHECK_MAIL_ADDRESS
192    * Checks the format of an email address roughly. Does not check if this is a valid and working email address.
193    * Format checking based on a minimal email address like a@b.io, which requires a minimum length of six chars
194    * and having the @ and the . as domain separator in the email address. Errors will get logged.
195    *
196    * @param The email address to check, basic expected format is user@company.domain.
197    *
198    * @return Return TRUE if the address fulfills the minimum criteria for a mail address otherwise FALSE, including for errors.
199    */
200    FUNCTION check_mail_address_format(p_mail_address IN VARCHAR2)
201  	 RETURN BOOLEAN
202    ;
203  
204    /* FUNCTION SOSL_UTIL.DUMMY_MAIL
205    * This is a testing function that will NOT send any mail. It will log the mail message created in SOSL_SERVER_LOG using
206    * the field full_message, so output can be controlled.
207    *
208    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
209    * @param p_recipients The semicolon separated list of mail recipient addresses.
210    * @param p_subject A preferablly short subject for the mail.
211    * @param p_message The correctly formatted mail message.
212    *
213    * @return Will return 0 on success or -1 on errors.
214    */
215    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
216  			  , p_recipients  IN VARCHAR2
217  			  , p_subject	  IN VARCHAR2
218  			  , p_message	  IN VARCHAR2
219  			  )
220  	 RETURN NUMBER
221    ;
222  
223    /* FUNCTION SOSL_UTIL.TXT_BOOLEAN
224    * Provides text values to display instead of BOOLEAN or NUMBER values interpreted as BOOLEAN. Numbers are interpreted
225    * similar to Oracle SQL, where 0 is FALSE and 1 is TRUE. 1 is considered as TRUE, any other value as FALSE. NULL values
226    * are interpreted as sosl_sys.NA_TYPE. Maximum 10 characters for TRUE/FALSE equation.
227    *
228    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
229    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
230    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
231    *
232    * @return The text equation for the given p_bool value or sosl_constants.GEN_NA_TYPE on errors.
233    */
234    FUNCTION txt_boolean( p_bool   IN BOOLEAN
235  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
236  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
237  			   )
238  	 RETURN VARCHAR2
239  	 DETERMINISTIC
240  	 PARALLEL_ENABLE
241    ;
242    FUNCTION txt_boolean( p_bool   IN NUMBER
243  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
244  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
245  			   )
246  	 RETURN VARCHAR2
247  	 DETERMINISTIC
248  	 PARALLEL_ENABLE
249    ;
250  
251    /* FUNCTION SOSL_UTIL.YES_NO
252    * A simple wrapper for txt_boolean with YES/NO instead of TRUE/FALSE.
253    *
254    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
255    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
256    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
257    *
258    * @return The text equation for the given p_bool value or sosl_constants.GEN_NA_TYPE on errors.
259    */
260    FUNCTION yes_no( p_bool	 IN BOOLEAN
261  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
262  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
263  		      )
264  	 RETURN VARCHAR2
265  	 DETERMINISTIC
266  	 PARALLEL_ENABLE
267    ;
268    FUNCTION yes_no( p_bool	 IN NUMBER
269  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
270  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
271  		      )
272  	 RETURN VARCHAR2
273  	 DETERMINISTIC
274  	 PARALLEL_ENABLE
275    ;
276  
277    /* FUNCTION SOSL_UTIL.run_state_text
278    * Returns the text interpretation (english) for the supported run states.
279    *
280    * @param p_run_state The numerical run state to express as text.
281    *
282    * @return The text equation for the given run state or sosl_constants.GEN_NA_TYPE on errors.
283    */
284    FUNCTION run_state_text(p_run_state IN NUMBER)
285  	 RETURN VARCHAR2
286  	 DETERMINISTIC
287  	 PARALLEL_ENABLE
288    ;
289  
290    /* FUNCTION SOSL_UTIL.OBJECT_DATE
291    * Works only for objects in the current schema, using USER_OBJECTS. Will return the LAST_DDL_TIME or the NA date type
292    * from SOSL_CONSTANTS if the object could not be found. Object type has to conform to object types used in USER_OBJECTS.
293    *
294    * @param p_object_name The name of the object, will be transformed to UPPERCASE as SOSL does not use mixed case.
295    * @param p_object_type A valid object type for USER_OBJECTS, e.g. FUNCTION, PACKAGE, PACKAGE BODY, PROCEDURE.
296    *
297    * @return The LAST_DDL_TIME as noted in USER_OBJECTS or SOSL_CONSTANTS.GEN_NA_DATE_TYPE on errors or not found.
298    */
299    FUNCTION object_date( p_object_name IN VARCHAR2
300  			   , p_object_type IN VARCHAR2
301  			   )
302  	 RETURN DATE
303    ;
304  
305    /* FUNCTION SOSL_UTIL.GET_VALID_RUN_STATE
306    * Checks if given run state in valid and returns the valid run state or error state.
307    *
308    * @param The run state to check. See SOSL_CONSTANTS for defined run states.
309    *
310    * @return Either the given run state if valid or SOSL_CONSTANTS.RUN_STATE_ERROR.
311    */
312    FUNCTION get_valid_run_state(p_run_state IN NUMBER)
313  	 RETURN NUMBER
314    ;
315  
316  END;
317  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_util.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_util
  2  AS
  3    -- for description see header file
  4    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
  5  				    , p_package       OUT VARCHAR2
  6  				    , p_function      OUT VARCHAR2
  7  				    )
  8    IS
  9  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
 10  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.split_function_name';
 11    BEGIN
 12  	 IF INSTR(p_function_name, '.') > 0
 13  	 THEN
 14  	   p_package   := TRIM(SUBSTR(p_function_name, 1, INSTR(p_function_name, '.') -1));
 15  	   p_function  := TRIM(SUBSTR(p_function_name, INSTR(p_function_name, '.') +1));
 16  	 ELSE
 17  	   p_package   := NULL;
 18  	   p_function  := TRIM(p_function_name);
 19  	 END IF;
 20    EXCEPTION
 21  	 WHEN OTHERS THEN
 22  	   -- log event and raise
 23  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 24  	   RAISE;
 25    END split_function_name;
 26  
 27    FUNCTION has_db_user(p_username IN VARCHAR2)
 28  	 RETURN BOOLEAN
 29    IS
 30  	 l_has_user	     NUMBER;
 31  	 l_return	     BOOLEAN;
 32  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
 33  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.has_db_user';
 34    BEGIN
 35  	 l_return := FALSE;
 36  	 SELECT COUNT(*) INTO l_has_user FROM all_users WHERE username = p_username;
 37  	 IF l_has_user != 0
 38  	 THEN
 39  	   l_return := TRUE;
 40  	 END IF;
 41  	 RETURN l_return;
 42    EXCEPTION
 43  	 WHEN OTHERS THEN
 44  	   -- log event instead of raise
 45  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 46  	   RETURN FALSE;
 47    END has_db_user;
 48  
 49    FUNCTION has_function( p_owner	       IN VARCHAR2
 50  			    , p_function_name  IN VARCHAR2
 51  			    , p_datatype       IN VARCHAR2
 52  			    )
 53  	 RETURN BOOLEAN
 54    IS
 55  	 l_has_function      NUMBER;
 56  	 l_package	     VARCHAR2(128);
 57  	 l_function	     VARCHAR2(128);
 58  	 l_return	     BOOLEAN;
 59  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
 60  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.has_function';
 61    BEGIN
 62  	 l_return := FALSE;
 63  	 split_function_name(p_function_name, l_package, l_function);
 64  	 SELECT COUNT(*)
 65  	   INTO l_has_function
 66  	   FROM all_arguments
 67  	  WHERE position		   = 0				     -- only functions
 68  	    AND argument_name		   IS NULL			     -- only functions
 69  	    AND data_type		   = p_datatype
 70  	    AND owner			   = UPPER(p_owner)
 71  	    AND NVL(package_name, 'N/A')   = NVL(UPPER(l_package), 'N/A')    -- may not contain a package name
 72  	    AND object_name		   = UPPER(l_function)
 73  	    AND package_name		  != 'SOSL'			     -- exclude base package should never be referenced
 74  	 ;
 75  	 IF l_has_function != 0
 76  	 THEN
 77  	   l_return := TRUE;
 78  	 END IF;
 79  	 RETURN l_return;
 80    EXCEPTION
 81  	 WHEN OTHERS THEN
 82  	   -- log event instead of raise
 83  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 84  	   RETURN FALSE;
 85    END has_function;
 86  
 87    FUNCTION get_col_length( p_table  IN VARCHAR2
 88  			      , p_column IN VARCHAR2
 89  			      )
 90  	 RETURN INTEGER
 91    IS
 92  	 l_return	     INTEGER;
 93  	 l_has_column	     INTEGER;
 94  	 l_data_type	     user_tab_columns.data_type%TYPE;
 95  	 l_data_length	     user_tab_columns.data_length%TYPE;
 96  	 l_data_precision    user_tab_columns.data_precision%TYPE;
 97  	 l_data_scale	     user_tab_columns.data_scale%TYPE;
 98  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_UTIL';
 99  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_util.get_col_length';
100    BEGIN
101  	 l_return := -1;
102  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
103  	 IF l_has_column = 1
104  	 THEN
105  	   -- column match calculate length
106  	   SELECT data_type
107  		, data_length
108  		, data_precision
109  		, data_scale
110  	     INTO l_data_type
111  		, l_data_length
112  		, l_data_precision
113  		, l_data_scale
114  	     FROM user_tab_columns
115  	    WHERE table_name  = UPPER(p_table)
116  	      AND column_name = UPPER(p_column)
117  	   ;
118  	   IF l_data_type = 'NUMBER'
119  	   THEN
120  	     IF l_data_scale != 0
121  	     THEN
122  	       -- consider delimiter
123  	       l_return := l_data_precision + l_data_scale;
124  	     ELSE
125  	       l_return := l_data_precision;
126  	     END IF;
127  	   ELSIF l_data_type = 'CLOB'
128  	   THEN
129  	     l_return := 32767;
130  	   ELSE
131  	     l_return := l_data_length;
132  	   END IF;
133  	 END IF;
134  	 RETURN l_return;
135    EXCEPTION
136  	 WHEN OTHERS THEN
137  	   -- log event instead of raise
138  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
139  	   RETURN sosl_constants.NUM_ERROR;
140    END get_col_length;
141  
142    FUNCTION get_col_type( p_table  IN VARCHAR2
143  			    , p_column IN VARCHAR2
144  			    )
145  	 RETURN VARCHAR2
146    IS
147  	 l_return	     VARCHAR2(128);
148  	 l_has_column	     INTEGER;
149  	 l_data_type	     user_tab_columns.data_type%TYPE;
150  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
151  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.get_col_type';
152    BEGIN
153  	 l_return := sosl_constants.GEN_NA_TYPE;
154  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
155  	 IF l_has_column = 1
156  	 THEN
157  	   -- column match get data type
158  	   SELECT data_type
159  	     INTO l_return
160  	     FROM user_tab_columns
161  	    WHERE table_name  = UPPER(p_table)
162  	      AND column_name = UPPER(p_column)
163  	   ;
164  	 END IF;
165  	 RETURN l_return;
166    EXCEPTION
167  	 WHEN OTHERS THEN
168  	   -- log event instead of raise
169  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
170  	   RETURN sosl_constants.GEN_NA_TYPE;
171    END get_col_type;
172  
173    FUNCTION check_col( p_table  IN VARCHAR2
174  			 , p_column IN VARCHAR2
175  			 , p_value  IN VARCHAR2
176  			 )
177  	 RETURN BOOLEAN
178    IS
179  	 l_return	     BOOLEAN;
180  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
181  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.check_col VARCHAR';
182    BEGIN
183  	 l_return := FALSE;
184  	 IF sosl_util.get_col_type(p_table, p_column) IN ('VARCHAR2', 'CHAR')
185  	 THEN
186  	   IF NVL(LENGTH(p_value), 0) <= sosl_util.get_col_length(p_table, p_column)
187  	   THEN
188  	     l_return := TRUE;
189  	   END IF;
190  	 END IF;
191  	 RETURN l_return;
192    EXCEPTION
193  	 WHEN OTHERS THEN
194  	   -- log event instead of raise
195  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
196  	   RETURN FALSE;
197    END check_col; -- VARCHAR2 variant
198  
199    FUNCTION check_col( p_table  IN VARCHAR2
200  			 , p_column IN VARCHAR2
201  			 , p_value  IN NUMBER
202  			 )
203  	 RETURN BOOLEAN
204    IS
205  	 l_return	     BOOLEAN;
206  	 l_number	     VARCHAR2(128);
207  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
208  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.check_col NUMBER';
209    BEGIN
210  	 l_return := FALSE;
211  	 IF sosl_util.get_col_type(p_table, p_column) = 'NUMBER'
212  	 THEN
213  	   l_number := REGEXP_REPLACE(TO_CHAR(p_value), '[^0-9]', '');
214  	   IF NVL(LENGTH(l_number), 0) <= sosl_util.get_col_length(p_table, p_column)
215  	   THEN
216  	     l_return := TRUE;
217  	   END IF;
218  	 END IF;
219  	 RETURN l_return;
220    EXCEPTION
221  	 WHEN OTHERS THEN
222  	   -- log event instead of raise
223  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
224  	   RETURN FALSE;
225    END check_col; -- NUMBER variant
226  
227    FUNCTION has_role( p_db_user IN VARCHAR2
228  			, p_role    IN VARCHAR2
229  			)
230  	 RETURN BOOLEAN
231    IS
232  	 l_count	     NUMBER;
233  	 l_return	     BOOLEAN;
234  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
235  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.has_role';
236    BEGIN
237  	 l_return := FALSE;
238  	 SELECT COUNT(*)
239  	   INTO l_count
240  	   FROM dba_role_privs
241  	  WHERE granted_role LIKE 'SOSL%'
242  	    AND grantee      = UPPER(p_db_user)
243  	    AND granted_role = UPPER(p_role)
244  	 ;
245  	 l_return := (l_count != 0);
246  	 RETURN l_return;
247    EXCEPTION
248  	 WHEN OTHERS THEN
249  	   -- log event instead of raise
250  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
251  	   RETURN FALSE;
252    END has_role;
253  
254    FUNCTION grant_role( p_db_user IN VARCHAR2
255  			  , p_role    IN VARCHAR2
256  			  )
257  	 RETURN BOOLEAN
258    IS
259  	 PRAGMA AUTONOMOUS_TRANSACTION;
260  	 l_return	     BOOLEAN;
261  	 l_statement	     VARCHAR2(1024);
262  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
263  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.grant_role';
264    BEGIN
265  	 l_return := FALSE;
266  	 IF has_role(p_db_user, p_role)
267  	 THEN
268  	   -- has grant everything is okay
269  	   l_return := TRUE;
270  	 ELSE
271  	   -- give grant
272  	   l_statement := 'GRANT ' || p_role || ' TO ' || p_db_user;
273  	   BEGIN
274  	     EXECUTE IMMEDIATE l_statement;
275  	     l_return := TRUE;
276  	   EXCEPTION
277  	     WHEN OTHERS THEN
278  	       -- log error
279  	       sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM || ' - Could not execute: ' || l_statement);
280  	       l_return := FALSE;
281  	   END;
282  	 END IF;
283  	 RETURN l_return;
284    EXCEPTION
285  	 WHEN OTHERS THEN
286  	   -- log event instead of raise
287  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
288  	   RETURN FALSE;
289    END grant_role;
290  
291    FUNCTION revoke_role( p_db_user IN VARCHAR2
292  			   , p_role    IN VARCHAR2
293  			   )
294  	 RETURN BOOLEAN
295    IS
296  	 PRAGMA AUTONOMOUS_TRANSACTION;
297  	 l_return	     BOOLEAN;
298  	 l_statement	     VARCHAR2(1024);
299  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
300  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.revoke_role';
301    BEGIN
302  	 l_return := FALSE;
303  	 IF NOT has_role(p_db_user, p_role)
304  	 THEN
305  	   -- role not given or revoked
306  	   l_return := TRUE;
307  	 ELSE
308  	   -- give grant
309  	   l_statement := 'REVOKE ' || p_role || ' FROM ' || p_db_user;
310  	   BEGIN
311  	     EXECUTE IMMEDIATE l_statement;
312  	     l_return := TRUE;
313  	   EXCEPTION
314  	     WHEN OTHERS THEN
315  	       -- log error
316  	       sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM || ' - Could not execute: ' || l_statement);
317  	       l_return := FALSE;
318  	   END;
319  	 END IF;
320  	 RETURN l_return;
321    EXCEPTION
322  	 WHEN OTHERS THEN
323  	   -- log event instead of raise
324  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
325  	   RETURN FALSE;
326    END revoke_role;
327  
328    FUNCTION utc_mail_date
329  	 RETURN VARCHAR2
330    IS
331  	 l_date VARCHAR2(500);
332    BEGIN
333  	 l_date := TO_CHAR(SYSTIMESTAMP AT TIME ZONE SESSIONTIMEZONE, 'Dy, DD Mon YYYY HH24:MI:SS TZHTZM');
334  	 RETURN l_date;
335    EXCEPTION
336  	 WHEN OTHERS THEN
337  	   -- log event instead of raise
338  	   sosl_log.exception_log('sosl_util.utc_mail_date', 'SOSL_UTIL', SQLERRM);
339  	   RETURN NULL;
340    END utc_mail_date;
341  
342    FUNCTION format_mail( p_sender	   IN VARCHAR2
343  			   , p_recipients  IN VARCHAR2
344  			   , p_subject	   IN VARCHAR2
345  			   , p_message	   IN VARCHAR2
346  			   )
347  	 RETURN VARCHAR2
348    IS
349  	 l_crlf 	 VARCHAR2(2)	   := CHR(13) || CHR(10);
350  	 l_mail_message  VARCHAR2(32767);
351    BEGIN
352  	 l_mail_message := 'From: ' || p_sender || l_crlf ||
353  			   'To: ' || p_recipients || l_crlf ||
354  			   'Date: ' || sosl_util.utc_mail_date || l_crlf ||
355  			   'Subject: ' || p_subject || l_crlf ||
356  			   p_message
357  	 ;
358  	 RETURN l_mail_message;
359    EXCEPTION
360  	 WHEN OTHERS THEN
361  	   -- log event instead of raise
362  	   sosl_log.exception_log('sosl_util.format_mail', 'SOSL_UTIL', SQLERRM);
363  	   RETURN NULL;
364    END format_mail;
365  
366    FUNCTION check_mail_address_format(p_mail_address IN VARCHAR2)
367  	 RETURN BOOLEAN
368    IS
369  	 l_return	     BOOLEAN;
370  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
371  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.check_mail_address_format';
372    BEGIN
373  	 l_return := FALSE;
374  	 IF	 LENGTH(p_mail_address) > 5
375  	    AND  INSTR(p_mail_address, '@') > 0
376  	    AND  INSTR(p_mail_address, '.') > 0
377  	 THEN
378  	   l_return := TRUE;
379  	 END IF;
380  	 RETURN l_return;
381    EXCEPTION
382  	 WHEN OTHERS THEN
383  	   -- log event instead of raise
384  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
385  	   RETURN FALSE;
386    END check_mail_address_format;
387  
388    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
389  			  , p_recipients  IN VARCHAR2
390  			  , p_subject	  IN VARCHAR2
391  			  , p_message	  IN VARCHAR2
392  			  )
393  	 RETURN NUMBER
394    IS
395  	 l_message	     VARCHAR2(32767);
396  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'MAIL DUMMY';
397  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_log.dummy_mail';
398    BEGIN
399  	 l_message := sosl_util.format_mail(p_sender, p_recipients, p_subject, p_message);
400  	 sosl_log.minimal_info_log(l_self_caller, l_self_log_category, 'Fake mail with subject "' || p_subject || '" created in full_message. Check the results.', l_message);
401  	 RETURN sosl_constants.NUM_SUCCESS;
402    EXCEPTION
403  	 WHEN OTHERS THEN
404  	   -- log the error instead of RAISE
405  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
406  	   RETURN sosl_constants.NUM_ERROR;
407    END dummy_mail;
408  
409    FUNCTION txt_boolean( p_bool   IN BOOLEAN
410  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
411  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
412  			   )
413  	 RETURN VARCHAR2
414  	 DETERMINISTIC
415  	 PARALLEL_ENABLE
416    IS
417    BEGIN
418  	 IF p_bool
419  	 THEN
420  	   RETURN TRIM(SUBSTR(NVL(p_true, 'TRUE'), 1, 10));
421  	 ELSE
422  	   RETURN TRIM(SUBSTR(NVL(p_false, 'FALSE'), 1, 10));
423  	 END IF;
424    EXCEPTION
425  	 WHEN OTHERS THEN
426  	   sosl_log.exception_log('sosl_util.txt_boolean BOOLEAN', 'SOSL_UTIL', SQLERRM);
427  	   RETURN sosl_constants.GEN_NA_TYPE;
428    END txt_boolean; -- boolean input
429  
430    FUNCTION txt_boolean( p_bool   IN NUMBER
431  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
432  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
433  			   )
434  	 RETURN VARCHAR2
435  	 DETERMINISTIC
436  	 PARALLEL_ENABLE
437    IS
438    BEGIN
439  	 RETURN sosl_util.txt_boolean((p_bool = 1), p_true, p_false);
440    EXCEPTION
441  	 WHEN OTHERS THEN
442  	   sosl_log.exception_log('sosl_util.txt_boolean NUMBER', 'SOSL_UTIL', SQLERRM);
443  	   RETURN sosl_constants.GEN_NA_TYPE;
444    END txt_boolean; -- number input
445  
446    FUNCTION yes_no( p_bool	 IN BOOLEAN
447  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
448  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
449  		      )
450  	 RETURN VARCHAR2
451  	 DETERMINISTIC
452  	 PARALLEL_ENABLE
453    IS
454    BEGIN
455  	 RETURN sosl_util.txt_boolean(p_bool, p_true, p_false);
456    EXCEPTION
457  	 WHEN OTHERS THEN
458  	   sosl_log.exception_log('sosl_util.yes_no BOOLEAN', 'SOSL_UTIL', SQLERRM);
459  	   RETURN sosl_constants.GEN_NA_TYPE;
460    END yes_no;
461  
462    FUNCTION yes_no( p_bool	 IN NUMBER
463  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
464  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
465  		      )
466  	 RETURN VARCHAR2
467  	 DETERMINISTIC
468  	 PARALLEL_ENABLE
469    IS
470    BEGIN
471  	 RETURN sosl_util.txt_boolean((p_bool = 1), p_true, p_false);
472    EXCEPTION
473  	 WHEN OTHERS THEN
474  	   sosl_log.exception_log('sosl_util.yes_no NUMBER', 'SOSL_UTIL', SQLERRM);
475  	   RETURN sosl_constants.GEN_NA_TYPE;
476    END yes_no;
477  
478    FUNCTION run_state_text(p_run_state IN NUMBER)
479  	 RETURN VARCHAR2
480  	 DETERMINISTIC
481  	 PARALLEL_ENABLE
482    IS
483  	 l_return VARCHAR2(30);
484    BEGIN
485  	 l_return := CASE p_run_state
486  		       WHEN sosl_constants.RUN_STATE_WAITING
487  		       THEN 'Waiting'
488  		       WHEN sosl_constants.RUN_STATE_ENQUEUED
489  		       THEN 'Enqueued'
490  		       WHEN sosl_constants.RUN_STATE_STARTED
491  		       THEN 'Started'
492  		       WHEN sosl_constants.RUN_STATE_RUNNING
493  		       THEN 'Running'
494  		       WHEN sosl_constants.RUN_STATE_FINISHED
495  		       THEN 'Finished'
496  		       WHEN sosl_constants.RUN_STATE_ERROR
497  		       THEN 'ERROR'
498  		       ELSE sosl_constants.GEN_NA_TYPE || ' run state unknown'
499  		     END;
500  	 RETURN l_return;
501    EXCEPTION
502  	 WHEN OTHERS THEN
503  	   sosl_log.exception_log('sosl_util.run_state_text', 'SOSL_UTIL', SQLERRM);
504  	   RETURN sosl_constants.GEN_NA_TYPE;
505    END run_state_text;
506  
507    FUNCTION object_date( p_object_name IN VARCHAR2
508  			   , p_object_type IN VARCHAR2
509  			   )
510  	 RETURN DATE
511    IS
512  	 l_has_object  NUMBER;
513  	 l_return      DATE;
514    BEGIN
515  	 l_return := sosl_constants.GEN_NA_DATE_TYPE;
516  	 SELECT COUNT(*)
517  	   INTO l_has_object
518  	   FROM user_objects
519  	  WHERE object_name = TRIM(UPPER(p_object_name))
520  	    AND object_type = TRIM(UPPER(p_object_type))
521  	 ;
522  	 -- only if we have exactly one object
523  	 IF l_has_object = 1
524  	 THEN
525  	   SELECT last_ddl_time
526  	     INTO l_return
527  	     FROM user_objects
528  	    WHERE object_name = TRIM(UPPER(p_object_name))
529  	      AND object_type = TRIM(UPPER(p_object_type))
530  	   ;
531  	 END IF;
532  	 RETURN l_return;
533    EXCEPTION
534  	 WHEN OTHERS THEN
535  	   sosl_log.exception_log('sosl_util.object_date', 'SOSL_UTIL', SQLERRM);
536  	   RETURN sosl_constants.GEN_NA_DATE_TYPE;
537    END object_date;
538  
539    FUNCTION get_valid_run_state(p_run_state IN NUMBER)
540  	 RETURN NUMBER
541    IS
542    BEGIN
543  	 IF p_run_state IN ( sosl_constants.RUN_STATE_WAITING
544  			   , sosl_constants.RUN_STATE_ENQUEUED
545  			   , sosl_constants.RUN_STATE_STARTED
546  			   , sosl_constants.RUN_STATE_RUNNING
547  			   , sosl_constants.RUN_STATE_FINISHED
548  			   , sosl_constants.RUN_STATE_ERROR
549  			   )
550  	 THEN
551  	   RETURN p_run_state;
552  	 ELSE
553  	   sosl_log.minimal_error_log('sosl_util.get_valid_run_state', 'SOSL_UTIL', 'Run state ' || p_run_state || ' not supported.');
554  	   RETURN sosl_constants.RUN_STATE_ERROR;
555  	 END IF;
556    EXCEPTION
557  	 WHEN OTHERS THEN
558  	   sosl_log.exception_log('sosl_util.get_valid_run_state', 'SOSL_UTIL', SQLERRM);
559  	   RETURN -1;
560    END get_valid_run_state;
561  
562  END;
563  /

Package body created.

SQL> -- packages depending on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_sys.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- main package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl_sys
  2  AS
  3  
  4    /* FUNCTION SOSL_SYS.GET_VALID_EXECUTOR_CNT
  5    * Determines the count of all valid executors. A valid executor is defined as an executor that is
  6    * marked as active and reviewed.
  7    *
  8    * @return The total count of all valid executors or -1 on errors.
  9    */
 10    FUNCTION get_valid_executor_cnt
 11  	 RETURN NUMBER
 12    ;
 13  
 14    /* FUNCTION SOSL_SYS.GET_WAITING_CNT
 15    * Determines the count of all scripts in the run queue with status WAITING.
 16    *
 17    * @return The count of all waiting scripts in the run queue or -1 on errors.
 18    */
 19    FUNCTION get_waiting_cnt
 20  	 RETURN NUMBER
 21    ;
 22  
 23    /* FUNCTION SOSL_SYS.GET_WAITING_CNT
 24    * Determines the count of all scripts of an executor in the run queue with status WAITING.
 25    *
 26    * @param p_executor_id The executor id to get all scripts in the run queue with status WAITING.
 27    *
 28    * @return The count of all waiting scripts in the run queue or -1 on errors.
 29    */
 30    FUNCTION get_waiting_cnt(p_executor_id IN NUMBER)
 31  	 RETURN NUMBER
 32    ;
 33  
 34    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_HAS_SCRIPTS
 35    * Deactivates all executors using the given function owner and function for has_scripts.
 36    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 37    * that throw exceptions or errors on calling them. Errors will be logged.
 38    *
 39    * @param p_function_owner The owner of the has_scripts function definition.
 40    * @param p_fn_has_scripts The defined script call for has_scripts.
 41    * @param p_log_reason A detailed reason why executor has be deactivated.
 42    *
 43    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 44    */
 45    FUNCTION deactivate_by_fn_has_scripts( p_function_owner IN VARCHAR2
 46  					    , p_fn_has_scripts IN VARCHAR2
 47  					    , p_log_reason     IN VARCHAR2
 48  					    )
 49  	 RETURN BOOLEAN
 50    ;
 51  
 52    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_GET_NEXT_SCRIPT
 53    * Deactivates all executors using the given function owner and function for get_next_script.
 54    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 55    * that throw exceptions or errors on calling them. Errors will be logged.
 56    *
 57    * @param p_function_owner The owner of the get_next_script function definition.
 58    * @param p_fn_get_next_script The defined script call for get_next_script.
 59    * @param p_log_reason A detailed reason why executor has be deactivated.
 60    *
 61    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 62    */
 63    FUNCTION deactivate_by_fn_get_next_script( p_function_owner     IN VARCHAR2
 64  						, p_fn_get_next_script IN VARCHAR2
 65  						, p_log_reason	       IN VARCHAR2
 66  						)
 67  	 RETURN BOOLEAN
 68    ;
 69  
 70    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_SET_SCRIPT_STATUS
 71    * Deactivates all executors using the given function owner and function for set_script_status.
 72    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 73    * that throw exceptions or errors on calling them. Errors will be logged.
 74    *
 75    * @param p_function_owner The owner of the set_script_status function definition.
 76    * @param p_fn_set_script_status The defined script call for set_script_status.
 77    * @param p_log_reason A detailed reason why executor has be deactivated.
 78    *
 79    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 80    */
 81    FUNCTION deactivate_by_fn_set_script_status( p_function_owner	   IN VARCHAR2
 82  						  , p_fn_set_script_status IN VARCHAR2
 83  						  , p_log_reason	   IN VARCHAR2
 84  						  )
 85  	 RETURN BOOLEAN
 86    ;
 87  
 88    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_SEND_DB_MAIL
 89    * Deactivates all executors using the given function owner and function for send_db_mail.
 90    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 91    * that throw exceptions or errors on calling them. Errors will be logged.
 92    *
 93    * @param p_function_owner The owner of the send_db_mail function definition.
 94    * @param p_fn_send_db_mail The defined script call for send_db_mail.
 95    * @param p_log_reason A detailed reason why executor has be deactivated.
 96    *
 97    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 98    */
 99    FUNCTION deactivate_by_fn_send_db_mail( p_function_owner  IN VARCHAR2
100  					     , p_fn_send_db_mail IN VARCHAR2
101  					     , p_log_reason	 IN VARCHAR2
102  					     )
103  	 RETURN BOOLEAN
104    ;
105  
106    /* FUNCTION SOSL_SYS.BUILD_SCRIPT_CALL
107    * Builds a SELECT FROM dual statement with the given function name and,
108    * if NOT NULL, function owner that can be executed dynamically. The return values and
109    * types are not checked and must be handled by the caller. By SOSL default the function
110    * owner is set and NOT NULL. Anyway this functions handles also NULL on function owner.
111    *
112    * WORKS ONLY FOR FUNCTION WITHOUT PARAMETER, e.g. has_scripts and get_next_script.
113    *
114    * BE AWARE that oracle cannot distinguish between package functions where the package is named
115    * like the schema, if names are equal, e.g. if a package exists, called SOSL, like the schema SOSL,
116    * Oracle would search with SOSL.myfunction not a function in the SOSL schema, it would search
117    * myfunction in the package SOSL if executed dynamically.
118    *
119    * @param p_function_name The name of the function or package function.
120    * @param p_function_owner If set, the function owner of the function. Will prefix the call.
121    *
122    * @return A statement to retrieve the function call e.g. SELECT owner.function FROM dual.
123    */
124    FUNCTION build_script_call( p_function_name   IN VARCHAR2
125  				 , p_function_owner  IN VARCHAR2 DEFAULT NULL
126  				 )
127  	 RETURN VARCHAR2
128    ;
129  
130    /* FUNCTION SOSL_SYS.BUILD_SIGNAL_CALL
131    * Builds a SELECT FROM dual statement with the given function name and, if NOT NULL, function owner that can be
132    * executed dynamically and the given parameter. The return values and
133    * types are not checked and must be handled by the caller. By SOSL default the function
134    * owner is set and NOT NULL. Anyway this functions handles also NULL on function owner.
135    *
136    * WORKS ONLY FOR FUNCTION WITH DEFINED PARAMETER, e.g. set_script_status and send_db_mail.
137    *
138    * BE AWARE that oracle cannot distinguish between package functions where the package is named
139    * like the schema, if names are equal, e.g. if a package exists, called SOSL, like the schema SOSL,
140    * Oracle would search with SOSL.myfunction not a function in the SOSL schema, it would search
141    * myfunction in the package SOSL if executed dynamically.
142    *
143    * @param p_function_name The name of the function or package function.
144    * @param p_function_owner If set, the function owner of the function. Will prefix the call.
145    * @param p_run_id The first function parameter representing the run id.
146    * @param p_status The second function parameter representing the status that should be set.
147    *
148    * @return A statement to retrieve the function call e.g. SELECT owner.function(1, 0) FROM dual.
149    */
150    FUNCTION build_signal_call( p_function_name   IN VARCHAR2
151  				 , p_function_owner  IN VARCHAR2
152  				 , p_run_id	     IN NUMBER
153  				 , p_status	     IN NUMBER
154  				 )
155  	 RETURN VARCHAR2
156    ;
157  
158    /* FUNCTION SOSL_SYS.GET_HAS_SCRIPT_CNT
159    * Determines the count result of all defined has_script functions of valid executors.
160    * Failures on specific executors are only considered, if none of the defined functions
161    * could be executed without errors. Defined scripts will be executed dynamically. Make
162    * sure that has_scripts execute fast, especially if more than one executor is active.
163    *
164    * Will only execute unique functions. If different executors share the same function owner
165    * and function definition, then the function is only executed once and not per executor.
166    * Call syntax is functionOwner.functionName where functionName can also be a package call.
167    *
168    * ATTENTION Will all executors with scripts throwing execptions!
169    *
170    * @return The total count of all defined has_scripts function or -1 on severe errors.
171    */
172    FUNCTION get_has_script_cnt
173  	 RETURN NUMBER
174    ;
175  
176    /* FUNCTION SOSL_SYS.IS_EXECUTOR_VALID
177    * Checks if the given executor id is valid in sense of active and reviewed. Errors will be logged.
178    *
179    * @param p_executor_id The id of the executor to check if the executor is active and reviewed.
180    *
181    * @return If executor exists, is reviewed and active, returns TRUE otherwise FALSE, also in case of errors.
182    */
183    FUNCTION is_executor_valid(p_executor_id IN NUMBER)
184  	 RETURN BOOLEAN
185    ;
186  
187    /* FUNCTION SOSL_SYS.IS_EXECUTOR
188    * Checks if the given executor id exists in SOSL_EXECUTOR. Errors will be logged.
189    *
190    * @param p_executor_id The id of the executor to check.
191    *
192    * @return If executor exists returns TRUE otherwise FALSE, also in case of errors.
193    */
194    FUNCTION is_executor(p_executor_id IN NUMBER)
195  	 RETURN BOOLEAN
196    ;
197  
198    /**
199    * This package contains the main functions and procedures used by the Simple Oracle Script Loader to handle executors and scripts.
200    * It is not allowed to use this package for function assignments in SOSL_EXECUTOR.
201    */
202  
203    /*FUNCTION SOSL_SYS.HAS_VALID_EXECUTORS
204    * Checks if any valid executor (active and reviewed) exists. Errors get logged, return on error is FALSE.
205    *
206    * @return Return TRUE if at least one active and reviewed executor exists, otherwise FALSE.
207    */
208    FUNCTION has_valid_executors
209  	 RETURN BOOLEAN
210    ;
211  
212    /* FUNCTION SOSL_SYS.HAS_SCRIPTS
213    * This function will be used by the wrapper function HAS_SCRIPTS.
214    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
215    * return a number greater or equal to 0 as well as messages waiting in SOSL_RUN_QUEUE to be processed. Errors will get logged.
216    *
217    * @return The total amount of scripts waiting for processing or -1 on unhandled exceptions/all functions have errors.
218    */
219    FUNCTION has_scripts
220  	 RETURN NUMBER
221    ;
222  
223    /* FUNCTION SOSL_SYS.HAS_RUN_ID
224    * Checks if a given run id exists. Errors get logged.
225    *
226    * @param p_run_id The run id to verify.
227    *
228    * @return TRUE if run id exists otherwise FALSE.
229    */
230    FUNCTION has_run_id(p_run_id IN NUMBER)
231  	 RETURN BOOLEAN
232    ;
233  
234    /* FUNCTION SOSL_SYS.GET_RUN_STATE
235    * Return the current run state for a given run id. Errors get logged.
236    *
237    * @param p_run_id The run id to get the run state for.
238    *
239    * @return On success the current run state or -1 on errors.
240    */
241    FUNCTION get_run_state(p_run_id IN NUMBER)
242  	 RETURN NUMBER
243    ;
244  
245    /* FUNCTION SOSL_SYS.GET_PAYLOAD
246    * Builds a SOSL_PAYLOAD object from the given run id.
247    *
248    * @param p_run_id The run id to get the SOSL_PAYLOAD object for.
249    *
250    * @return On success a valid SOSL_PAYLOAD object or NULL on errors.
251    */
252    FUNCTION get_payload(p_run_id IN NUMBER)
253  	 RETURN SOSL_PAYLOAD
254    ;
255  
256    /* FUNCTION SOSL_SYS.SIGNAL_STATUS_CHANGE
257    * Uses the defined executor from given run id to execute the defined interface function for set_script_status.
258    * The given run id must be valid, as well as the defined function for set_script_status. Otherwise the executor is deactivated.
259    * If mail is activated, will also call the mail functions, errors on mail are logged and ignored (will not lead to FALSE return value).
260    *
261    * @param p_run_id The valid run id to signal state changes.
262    * @param p_status A valid run state.
263    *
264    * @return TRUE if run state successfully signalled otherwise FALSE.
265    */
266    FUNCTION signal_status_change( p_run_id IN NUMBER
267  				    , p_status IN NUMBER
268  				    )
269  	 RETURN BOOLEAN
270    ;
271  
272    /* FUNCTION SOSL_SYS.SET_RUN_STATE
273    * Sets the given run state in SOSL_RUN_QUEUE.
274    *
275    * Run states must follow the state hierarchy: WAITING, ENQUEUED, STARTED, RUNNING, FINISHED. Every state allows to set the
276    * state to ERROR or to the following state. Wrong state hierarchy will lead to run state ERROR. If state is equal to current
277    * state, no change will take place.
278    *
279    * @param p_run_id The valid run id to update.
280    * @param p_status A valid run state.
281    *
282    * @return TRUE if run state successfully updated otherwise FALSE.
283    */
284    FUNCTION set_run_state( p_run_id IN NUMBER
285  			     , p_status IN NUMBER
286  			     )
287  	 RETURN BOOLEAN
288    ;
289  
290    /* FUNCTION SOSL_SYS.SET_SCRIPT_STATUS
291    * This function will be used by the wrapper function SET_SCRIPT_STATUS. It will first set the status of the script
292    * associated to the given run id in SOSL_RUN_QUEUE and then signal the state to all defined set_script_status functions.
293    * Invalid status will lead to run state ERROR used. Errors will get logged. Invalid functions will deactivate the related
294    * executors. If at least one status could be set successfully, it will return success (0).
295    *
296    * Run states must follow the state hierarchy: WAITING, ENQUEUED, STARTED, RUNNING, FINISHED. Every state allows to set the
297    * state to ERROR or to the following state. Wrong state hierarchy will lead to run state ERROR. If state is equal to current
298    * state, no change will take place.
299    *
300    * @param p_run_id The valid run id of the script that should change run state.
301    * @param p_status A valid status as defined in SOSL_CONSTANTS for run states.
302    *
303    * @return Return 0 if successful executed otherwise -1.
304    */
305    FUNCTION set_script_status( p_run_id IN NUMBER
306  				 , p_status IN NUMBER
307  				 )
308  	 RETURN NUMBER
309    ;
310  
311    /* FUNCTION SOSL_SYS.REGISTER_NEXT_SCRIPT
312    * Fetches the PAYLOAD from a given configured function for GET_NEXT_SCRIPT and stores it in SOSL_RUN_QUEUE with the
313    * status WAITING. On errors, if sufficient data are available, the next script information is stored with status ERROR.
314    * All executors using a function with errors will get deactivated.
315    *
316    * @param p_function_name The function to execute for getting the payload. Package functions allowed.
317    * @param p_function_owner The function owner of the function to execute.
318    *
319    * @return TRUE if fetch was successful, otherwise FALSE.
320    */
321    FUNCTION register_next_script( p_function_name  IN VARCHAR2
322  				    , p_function_owner IN VARCHAR2
323  				    )
324  	 RETURN BOOLEAN
325    ;
326  
327    /* FUNCTION SOSL_SYS.REGISTER_WAITING
328    * Registers all waiting scripts available by defined GET_NEXT_SCRIPT function and persisting them in SOSL_RUN_QUEUE.
329    * State may be WAITING or ERROR, if errors occured and SOSL_PAYLOAD has usable values. Errors get logged.
330    *
331    * @return TRUE if successfully registered any waiting script, otherwise FALSE.
332    */
333    FUNCTION register_waiting
334  	 RETURN BOOLEAN
335    ;
336  
337    /* FUNCTION SOSL_SYS.FETCH_NEXT_RUN_ID
338    * Gets the next available RUN_ID from scripts with status WAITING in SOSL_RUN_QUEUE. Mainly sorted by create date but on
339    * similar create date randomly.
340    *
341    * @return The RUN_ID of the next script to execute or -1 on errors.
342    */
343    FUNCTION fetch_next_run_id
344  	 RETURN NUMBER
345    ;
346  
347    /* FUNCTION SOSL_SYS.GET_NEXT_SCRIPT
348    * This function will be used by the wrapper function GET_NEXT_SCRIPT.
349    * It collects from all executors the next script to execute, queues them in SOSL_RUN_QUEUE and then fetches the first script in the
350    * run queue as next script to execute. If no scripts are available or on errors, the function will return -1.
351    * Errors will be logged. From interface functions it excepts the return type SOSL_PAYLOAD.
352    *
353    * @return The next script reference as RUN_ID from SOSL_RUN_QUEUE, containing run id that can be related to executor, external script id and scriptfile.
354    */
355    FUNCTION get_next_script
356  	 RETURN NUMBER
357    ;
358  
359  END;
360  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_sys.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_sys
  2  AS
  3    -- for description see header file
  4    FUNCTION get_valid_executor_cnt
  5  	 RETURN NUMBER
  6    IS
  7  	 l_return NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*)
 10  	   INTO l_return
 11  	   FROM sosl_executor
 12  	  WHERE executor_active   = sosl_constants.NUM_YES
 13  	    AND executor_reviewed = sosl_constants.NUM_YES
 14  	 ;
 15  	 RETURN l_return;
 16    EXCEPTION
 17  	 WHEN OTHERS THEN
 18  	   -- log the error instead of RAISE
 19  	   sosl_log.exception_log('sosl_sys.get_valid_executor_cnt', 'SOSL_SYS', SQLERRM);
 20  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 21  	   RETURN -1;
 22    END get_valid_executor_cnt;
 23  
 24    FUNCTION get_waiting_cnt
 25  	 RETURN NUMBER
 26    IS
 27  	 l_return NUMBER;
 28    BEGIN
 29  	 SELECT COUNT(*)
 30  	   INTO l_return
 31  	   FROM sosl_run_queue
 32  	  WHERE run_state = sosl_constants.RUN_STATE_WAITING
 33  	 ;
 34  	 RETURN l_return;
 35    EXCEPTION
 36  	 WHEN OTHERS THEN
 37  	   -- log the error instead of RAISE
 38  	   sosl_log.exception_log('sosl_sys.get_waiting_cnt', 'SOSL_SYS', SQLERRM);
 39  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 40  	   RETURN -1;
 41    END get_waiting_cnt;
 42  
 43    FUNCTION get_waiting_cnt(p_executor_id IN NUMBER)
 44  	 RETURN NUMBER
 45    IS
 46  	 l_return NUMBER;
 47    BEGIN
 48  	 SELECT COUNT(*)
 49  	   INTO l_return
 50  	   FROM sosl_run_queue
 51  	  WHERE run_state   = sosl_constants.RUN_STATE_WAITING
 52  	    AND executor_id = p_executor_id
 53  	 ;
 54  	 RETURN l_return;
 55    EXCEPTION
 56  	 WHEN OTHERS THEN
 57  	   -- log the error instead of RAISE
 58  	   sosl_log.exception_log('sosl_sys.get_waiting_cnt executor', 'SOSL_SYS', SQLERRM);
 59  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 60  	   RETURN -1;
 61    END get_waiting_cnt;
 62  
 63    FUNCTION deactivate_by_fn_has_scripts( p_function_owner IN VARCHAR2
 64  					    , p_fn_has_scripts IN VARCHAR2
 65  					    , p_log_reason     IN VARCHAR2
 66  					    )
 67  	 RETURN BOOLEAN
 68    IS
 69  	 PRAGMA AUTONOMOUS_TRANSACTION;
 70  	 l_return	     BOOLEAN;
 71  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
 72  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_has_scripts';
 73  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
 74  			      , cp_function_name  IN VARCHAR2
 75  			      )
 76  	 IS
 77  	   SELECT executor_id
 78  		, function_owner
 79  	     FROM sosl_executor
 80  	    WHERE function_owner = cp_function_owner
 81  	      AND fn_has_scripts = cp_function_name
 82  	 ;
 83    BEGIN
 84  	 l_return := TRUE;
 85  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
 86  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_has_scripts)
 87  	 LOOP
 88  	   -- disable executor
 89  	   UPDATE sosl_executor
 90  	      SET executor_active    = sosl_constants.NUM_NO
 91  		, executor_reviewed  = sosl_constants.NUM_NO
 92  	    WHERE executor_id = rec.executor_id
 93  	   ;
 94  	   COMMIT;
 95  	   -- revoke grants for function owner
 96  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
 97  	   THEN
 98  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
 99  	     -- if one fails, it all is in error
100  	     l_return := FALSE;
101  	   END IF;
102  	 END LOOP;
103  	 RETURN l_return;
104    EXCEPTION
105  	 WHEN OTHERS THEN
106  	   -- log the error instead of RAISE
107  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
108  	   RETURN FALSE;
109    END deactivate_by_fn_has_scripts;
110  
111    FUNCTION deactivate_by_fn_get_next_script( p_function_owner     IN VARCHAR2
112  						, p_fn_get_next_script IN VARCHAR2
113  						, p_log_reason	       IN VARCHAR2
114  						)
115  	 RETURN BOOLEAN
116    IS
117  	 PRAGMA AUTONOMOUS_TRANSACTION;
118  	 l_return	     BOOLEAN;
119  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
120  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_get_next_script';
121  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
122  			      , cp_function_name  IN VARCHAR2
123  			      )
124  	 IS
125  	   SELECT executor_id
126  		, function_owner
127  	     FROM sosl_executor
128  	    WHERE function_owner     = cp_function_owner
129  	      AND fn_get_next_script = cp_function_name
130  	 ;
131    BEGIN
132  	 l_return := TRUE;
133  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
134  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_get_next_script)
135  	 LOOP
136  	   -- disable executor
137  	   UPDATE sosl_executor
138  	      SET executor_active    = sosl_constants.NUM_NO
139  		, executor_reviewed  = sosl_constants.NUM_NO
140  	    WHERE executor_id = rec.executor_id
141  	   ;
142  	   COMMIT;
143  	   -- revoke grants for function owner
144  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
145  	   THEN
146  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
147  	     -- if one fails, it all is in error
148  	     l_return := FALSE;
149  	   END IF;
150  	 END LOOP;
151  	 RETURN l_return;
152    EXCEPTION
153  	 WHEN OTHERS THEN
154  	   -- log the error instead of RAISE
155  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
156  	   RETURN FALSE;
157    END deactivate_by_fn_get_next_script;
158  
159    FUNCTION deactivate_by_fn_set_script_status( p_function_owner	   IN VARCHAR2
160  						  , p_fn_set_script_status IN VARCHAR2
161  						  , p_log_reason	   IN VARCHAR2
162  						  )
163  	 RETURN BOOLEAN
164    IS
165  	 PRAGMA AUTONOMOUS_TRANSACTION;
166  	 l_return	     BOOLEAN;
167  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
168  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_set_script_status';
169  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
170  			      , cp_function_name  IN VARCHAR2
171  			      )
172  	 IS
173  	   SELECT executor_id
174  		, function_owner
175  	     FROM sosl_executor
176  	    WHERE function_owner       = cp_function_owner
177  	      AND fn_set_script_status = cp_function_name
178  	 ;
179    BEGIN
180  	 l_return := TRUE;
181  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
182  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_set_script_status)
183  	 LOOP
184  	   -- disable executor
185  	   UPDATE sosl_executor
186  	      SET executor_active    = sosl_constants.NUM_NO
187  		, executor_reviewed  = sosl_constants.NUM_NO
188  	    WHERE executor_id = rec.executor_id
189  	   ;
190  	   COMMIT;
191  	   -- revoke grants for function owner
192  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
193  	   THEN
194  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
195  	     -- if one fails, it all is in error
196  	     l_return := FALSE;
197  	   END IF;
198  	 END LOOP;
199  	 RETURN l_return;
200    EXCEPTION
201  	 WHEN OTHERS THEN
202  	   -- log the error instead of RAISE
203  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
204  	   RETURN FALSE;
205    END deactivate_by_fn_set_script_status;
206  
207    FUNCTION deactivate_by_fn_send_db_mail( p_function_owner  IN VARCHAR2
208  					     , p_fn_send_db_mail IN VARCHAR2
209  					     , p_log_reason	 IN VARCHAR2
210  					     )
211  	 RETURN BOOLEAN
212    IS
213  	 PRAGMA AUTONOMOUS_TRANSACTION;
214  	 l_return	     BOOLEAN;
215  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
216  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_send_db_mail';
217  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
218  			      , cp_function_name  IN VARCHAR2
219  			      )
220  	 IS
221  	   SELECT executor_id
222  		, function_owner
223  	     FROM sosl_executor
224  	    WHERE function_owner  = cp_function_owner
225  	      AND fn_send_db_mail = cp_function_name
226  	 ;
227    BEGIN
228  	 l_return := TRUE;
229  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
230  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_send_db_mail)
231  	 LOOP
232  	   -- disable executor
233  	   UPDATE sosl_executor
234  	      SET executor_active    = sosl_constants.NUM_NO
235  		, executor_reviewed  = sosl_constants.NUM_NO
236  	    WHERE executor_id = rec.executor_id
237  	   ;
238  	   COMMIT;
239  	   -- revoke grants for function owner
240  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
241  	   THEN
242  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
243  	     -- if one fails, it all is in error
244  	     l_return := FALSE;
245  	   END IF;
246  	 END LOOP;
247  	 RETURN l_return;
248    EXCEPTION
249  	 WHEN OTHERS THEN
250  	   -- log the error instead of RAISE
251  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
252  	   RETURN FALSE;
253    END deactivate_by_fn_send_db_mail;
254  
255    FUNCTION build_script_call( p_function_name   IN VARCHAR2
256  				 , p_function_owner  IN VARCHAR2 DEFAULT NULL
257  				 )
258  	 RETURN VARCHAR2
259    IS
260  	 l_statement VARCHAR2(1024);
261    BEGIN
262  	 IF p_function_owner IS NOT NULL
263  	 THEN
264  	   l_statement := 'SELECT ' || p_function_owner || '.' || p_function_name || ' FROM dual';
265  	 ELSE
266  	   l_statement := 'SELECT ' || p_function_name || ' FROM dual';
267  	 END IF;
268  	 RETURN l_statement;
269    EXCEPTION
270  	 WHEN OTHERS THEN
271  	   -- log the error instead of RAISE
272  	   sosl_log.exception_log('sosl_sys.build_script_call', 'SOSL_SYS', SQLERRM);
273  	   RETURN 'SELECT -1 FROM dual';
274    END build_script_call;
275  
276    FUNCTION build_signal_call( p_function_name   IN VARCHAR2
277  				 , p_function_owner  IN VARCHAR2
278  				 , p_run_id	     IN NUMBER
279  				 , p_status	     IN NUMBER
280  				 )
281  	 RETURN VARCHAR2
282    IS
283  	 l_statement VARCHAR2(4000);
284    BEGIN
285  	 IF p_function_owner IS NOT NULL
286  	 THEN
287  	   l_statement := 'SELECT ' || p_function_owner || '.' || p_function_name || '(' ||
288  			  TRIM(TO_CHAR(p_run_id)) || ', ' || TRIM(TO_CHAR(p_status)) || ')' ||
289  			  ' FROM dual'
290  	   ;
291  	 ELSE
292  	   l_statement := 'SELECT ' || p_function_name || '(' ||
293  			  TRIM(TO_CHAR(p_run_id)) || ', ' || TRIM(TO_CHAR(p_status)) || ')' ||
294  			  ' FROM dual';
295  	 END IF;
296  	 RETURN l_statement;
297    EXCEPTION
298  	 WHEN OTHERS THEN
299  	   -- log the error instead of RAISE
300  	   sosl_log.exception_log('sosl_sys.build_signal_call', 'SOSL_SYS', SQLERRM);
301  	   RETURN 'SELECT -1 FROM dual';
302    END build_signal_call;
303  
304  
305    FUNCTION get_has_script_cnt
306  	 RETURN NUMBER
307    IS
308  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
309  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_has_script_cnt';
310  	 l_total	     NUMBER;
311  	 l_count	     NUMBER;
312  	 l_success	     BOOLEAN;
313  	 l_statement	     VARCHAR2(1024);
314  	 CURSOR cur_fn_has_scripts
315  	 IS
316  	   SELECT function_owner
317  		, fn_has_scripts
318  	     FROM sosl_executor
319  	    WHERE executor_active   = sosl_constants.NUM_YES
320  	      AND executor_reviewed = sosl_constants.NUM_YES
321  	    GROUP BY function_owner
322  		   , fn_has_scripts
323  	 ;
324    BEGIN
325  	 -- flag to determine if at least one execution was successful
326  	 l_success := FALSE;
327  	 l_total   := 0;
328  	 l_count   := 0;
329  	 -- loop through functions
330  	 FOR rec IN cur_fn_has_scripts
331  	 LOOP
332  	   l_statement := sosl_sys.build_script_call(rec.fn_has_scripts, rec.function_owner);
333  	   BEGIN
334  	     EXECUTE IMMEDIATE l_statement INTO l_count;
335  	   EXCEPTION
336  	     WHEN OTHERS THEN
337  	       sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
338  	       l_count := -1;
339  	   END;
340  	   IF l_count < 0
341  	   THEN
342  	     -- we have errors with this function disable executors using this function
343  	     IF NOT sosl_sys.deactivate_by_fn_has_scripts(rec.function_owner, rec.fn_has_scripts, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
344  	     THEN
345  	       -- error situation
346  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || rec.fn_has_scripts || ' function owner ' || rec.function_owner);
347  	     END IF;
348  	   ELSE
349  	     l_success := TRUE;
350  	     l_total   := l_total + l_count;
351  	   END IF;
352  	 END LOOP;
353  	 -- now check if we have at least one function executed with success
354  	 IF NOT l_success
355  	 THEN
356  	   -- we should report the error situation
357  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'No defined has_scripts function is working. Disabled executors.');
358  	   l_total := -1;
359  	 END IF;
360  	 RETURN l_total;
361    EXCEPTION
362  	 WHEN OTHERS THEN
363  	   -- log the error instead of RAISE
364  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
365  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
366  	   RETURN -1;
367    END get_has_script_cnt;
368  
369    FUNCTION is_executor_valid(p_executor_id IN NUMBER)
370  	 RETURN BOOLEAN
371    IS
372  	 l_valid_count NUMBER;
373  	 l_return      BOOLEAN;
374    BEGIN
375  	 l_return := FALSE;
376  	 SELECT COUNT(*)
377  	   INTO l_valid_count
378  	   FROM sosl_executor
379  	  WHERE executor_id	   = p_executor_id
380  	    AND executor_active    = sosl_constants.NUM_YES
381  	    AND executor_reviewed  = sosl_constants.NUM_YES
382  	 ;
383  	 l_return := (l_valid_count != 0);
384  	 RETURN l_return;
385    EXCEPTION
386  	 WHEN OTHERS THEN
387  	   sosl_log.exception_log('sosl_sys.is_executor_valid', 'SOSL_SYS', SQLERRM);
388  	   RETURN FALSE;
389    END is_executor_valid;
390  
391    FUNCTION is_executor(p_executor_id IN NUMBER)
392  	 RETURN BOOLEAN
393    IS
394  	 l_valid_count NUMBER;
395  	 l_return      BOOLEAN;
396    BEGIN
397  	 l_return := FALSE;
398  	 SELECT COUNT(*)
399  	   INTO l_valid_count
400  	   FROM sosl_executor
401  	  WHERE executor_id	   = p_executor_id
402  	 ;
403  	 l_return := (l_valid_count != 0);
404  	 RETURN l_return;
405    EXCEPTION
406  	 WHEN OTHERS THEN
407  	   sosl_log.exception_log('sosl_sys.is_executor', 'SOSL_SYS', SQLERRM);
408  	   RETURN FALSE;
409    END is_executor;
410  
411    FUNCTION has_valid_executors
412  	 RETURN BOOLEAN
413    IS
414  	 l_return	     BOOLEAN;
415  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
416  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.has_valid_executors';
417    BEGIN
418  	 l_return := (sosl_sys.get_valid_executor_cnt > 0);
419  	 RETURN l_return;
420    EXCEPTION
421  	 WHEN OTHERS THEN
422  	   -- log the error instead of RAISE
423  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
424  	   RETURN FALSE;
425    END has_valid_executors;
426  
427    FUNCTION has_scripts
428  	 RETURN NUMBER
429    IS
430  	 l_return	     NUMBER;
431  	 l_waiting	     NUMBER;
432  	 l_defined	     NUMBER;
433  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
434  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.has_scripts';
435    BEGIN
436  	 l_return      := -1;
437  	 IF sosl_sys.has_valid_executors
438  	 THEN
439  	   -- initialize the total count
440  	   l_return := 0;
441  	   -- get count of waiting scripts
442  	   l_waiting := sosl_sys.get_waiting_cnt;
443  	   l_defined := sosl_sys.get_has_script_cnt;
444  	   IF	   l_waiting >= 0
445  	      AND  l_defined >= 0
446  	   THEN
447  	     -- build total
448  	     l_return := l_waiting + l_defined;
449  	   ELSE
450  	     -- report error
451  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Defined functions or run queue in error. Fix problems before expecting valid results');
452  	     l_return := -1;
453  	   END IF;
454  	 ELSE
455  	   -- log no valid executors
456  	   sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, 'Nothing to do, no valid executors. Return 0 scripts available');
457  	   l_return := 0;
458  	 END IF;
459  	 RETURN l_return;
460    EXCEPTION
461  	 WHEN OTHERS THEN
462  	   -- log the error instead of RAISE
463  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
464  	   RETURN -1;
465    END has_scripts;
466  
467    FUNCTION has_run_id(p_run_id IN NUMBER)
468  	 RETURN BOOLEAN
469    IS
470  	 l_return  BOOLEAN;
471  	 l_count   NUMBER;
472    BEGIN
473  	 l_return := FALSE;
474  	 SELECT COUNT(*)
475  	   INTO l_count
476  	   FROM sosl_run_queue
477  	  WHERE run_id = p_run_id
478  	 ;
479  	 l_return := (l_count = 1);
480  	 RETURN l_return;
481    EXCEPTION
482  	 WHEN OTHERS THEN
483  	   -- log the error instead of RAISE
484  	   sosl_log.exception_log('sosl_sys.has_run_id', 'SOSL_SYS', SQLERRM);
485  	   RETURN FALSE;
486    END has_run_id;
487  
488    FUNCTION get_run_state(p_run_id IN NUMBER)
489  	 RETURN NUMBER
490    IS
491  	 l_run_state NUMBER;
492    BEGIN
493  	 IF sosl_sys.has_run_id(p_run_id)
494  	 THEN
495  	   SELECT run_state
496  	     INTO l_run_state
497  	     FROM sosl_run_queue
498  	    WHERE run_id = p_run_id
499  	   ;
500  	 ELSE
501  	   l_run_state := sosl_constants.RUN_STATE_ERROR;
502  	 END IF;
503  	 RETURN l_run_state;
504    EXCEPTION
505  	 WHEN OTHERS THEN
506  	   -- log the error instead of RAISE
507  	   sosl_log.exception_log('sosl_sys.get_run_state', 'SOSL_SYS', SQLERRM);
508  	   RETURN -1;
509    END get_run_state;
510  
511    FUNCTION get_payload(p_run_id IN NUMBER)
512  	 RETURN SOSL_PAYLOAD
513    IS
514  	 l_payload	     SOSL_PAYLOAD;
515  	 l_executor_id	     sosl_run_queue.executor_id%TYPE;
516  	 l_ext_script_id     sosl_run_queue.ext_script_id%TYPE;
517  	 l_script_file	     sosl_run_queue.script_file%TYPE;
518  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
519  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_payload';
520    BEGIN
521  	 l_payload := NULL;
522  	 IF sosl_sys.has_run_id(p_run_id)
523  	 THEN
524  	   SELECT executor_id
525  		, ext_script_id
526  		, script_file
527  	     INTO l_executor_id
528  		, l_ext_script_id
529  		, l_script_file
530  	     FROM sosl_run_queue
531  	    WHERE run_id = p_run_id
532  	   ;
533  	   l_payload := SOSL_PAYLOAD(l_executor_id, l_ext_script_id, l_script_file);
534  	 ELSE
535  	   l_payload := NULL;
536  	   -- log error
537  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid run id ' || p_run_id);
538  	 END IF;
539  	 RETURN l_payload;
540    EXCEPTION
541  	 WHEN OTHERS THEN
542  	   -- log the error instead of RAISE
543  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
544  	   RETURN NULL;
545    END get_payload;
546  
547    FUNCTION signal_status_change( p_run_id IN NUMBER
548  				    , p_status IN NUMBER
549  				    )
550  	 RETURN BOOLEAN
551    IS
552  	 l_return		 BOOLEAN;
553  	 l_num_result		 NUMBER;
554  	 l_function_owner	 sosl_executor.function_owner%TYPE;
555  	 l_fn_set_script_status  sosl_executor.fn_set_script_status%TYPE;
556  	 l_fn_send_db_mail	 sosl_executor.fn_send_db_mail%TYPE;
557  	 l_use_mail		 sosl_executor.use_mail%TYPE;
558  	 l_statement		 VARCHAR2(4000);
559  	 l_self_log_category	 sosl_server_log.log_category%TYPE := 'SOSL_SYS';
560  	 l_self_caller		 sosl_server_log.caller%TYPE	   := 'sosl_sys.signal_status_change';
561    BEGIN
562  	 l_return := FALSE;
563  	 IF sosl_sys.has_run_id(p_run_id)
564  	 THEN
565  	   -- get the defined function to signal the status change
566  	   SELECT sexe.function_owner
567  		, sexe.fn_set_script_status
568  		, sexe.fn_send_db_mail
569  		, sexe.use_mail
570  	     INTO l_function_owner
571  		, l_fn_set_script_status
572  		, l_fn_send_db_mail
573  		, l_use_mail
574  	     FROM sosl_run_queue srqu
575  	    INNER JOIN sosl_executor sexe
576  	       ON srqu.executor_id = sexe.executor_id
577  	    WHERE srqu.run_id = p_run_id
578  	   ;
579  	   l_statement := sosl_sys.build_signal_call(l_fn_set_script_status, l_function_owner, p_run_id, p_status);
580  	   BEGIN
581  	     EXECUTE IMMEDIATE l_statement INTO l_num_result;
582  	     IF l_num_result = sosl_constants.NUM_SUCCESS
583  	     THEN
584  	       l_return := TRUE;
585  	     END IF;
586  	   EXCEPTION
587  	     WHEN OTHERS THEN
588  	       sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
589  	   END;
590  	   IF l_return
591  	   THEN
592  	     -- if mail activated execute also the defined mail function
593  	     IF l_use_mail = sosl_constants.NUM_YES
594  	     THEN
595  	       l_statement := sosl_sys.build_signal_call(l_fn_send_db_mail, l_function_owner, p_run_id, p_status);
596  	       BEGIN
597  		 EXECUTE IMMEDIATE l_statement INTO l_num_result;
598  	       EXCEPTION
599  		 WHEN OTHERS THEN
600  		   sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
601  		   l_num_result := sosl_constants.NUM_ERROR;
602  	       END;
603  	       IF l_num_result = sosl_constants.NUM_ERROR
604  	       THEN
605  		 IF NOT sosl_sys.deactivate_by_fn_send_db_mail(l_function_owner, l_fn_send_db_mail, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
606  		 THEN
607  		   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || l_fn_send_db_mail || ' function owner ' || l_function_owner);
608  		 END IF;
609  	       END IF;
610  	     END IF;
611  	   ELSE
612  	     -- deactivate executors using the set_script_status function
613  	     IF NOT sosl_sys.deactivate_by_fn_set_script_status(l_function_owner, l_fn_set_script_status, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
614  	     THEN
615  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || l_fn_set_script_status || ' function owner ' || l_function_owner);
616  	     END IF;
617  	   END IF;
618  	 END IF;
619  	 RETURN l_return;
620    EXCEPTION
621  	 WHEN OTHERS THEN
622  	   -- log the error instead of RAISE
623  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
624  	   RETURN FALSE;
625    END signal_status_change;
626  
627    FUNCTION set_run_state( p_run_id IN NUMBER
628  			     , p_status IN NUMBER
629  			     )
630  	 RETURN BOOLEAN
631    IS
632  	 PRAGMA AUTONOMOUS_TRANSACTION;
633  	 l_return	     BOOLEAN;
634  	 l_run_state	     INTEGER;
635  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
636  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.set_script_status';
637    BEGIN
638  	 l_return := FALSE;
639  	 l_run_state := sosl_util.get_valid_run_state(p_status);
640  	 IF sosl_sys.has_run_id(p_run_id)
641  	 THEN
642  	   UPDATE sosl_run_queue
643  	      SET run_state = l_run_state
644  	    WHERE run_id = p_run_id
645  	   ;
646  	   COMMIT;
647  	   -- check that state was set successfully
648  	   l_return := (l_run_state = sosl_sys.get_run_state(p_run_id));
649  	 END IF;
650  	 RETURN l_return;
651    EXCEPTION
652  	 WHEN OTHERS THEN
653  	   -- log the error instead of RAISE
654  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
655  	   RETURN FALSE;
656    END set_run_state;
657  
658    FUNCTION set_script_status( p_run_id IN NUMBER
659  				 , p_status IN NUMBER
660  				 )
661  	 RETURN NUMBER
662    IS
663  	 l_return	     NUMBER;
664  	 l_run_state	     INTEGER;
665  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
666  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.set_script_status';
667    BEGIN
668  	 l_return := -1;
669  	 -- check status
670  	 l_run_state := sosl_util.get_valid_run_state(p_status);
671  	 -- check run id
672  	 IF sosl_sys.has_run_id(p_run_id)
673  	 THEN
674  	   -- first set own status, then signal changes
675  	   IF	  sosl_sys.set_run_state(p_run_id, p_status)
676  	      AND sosl_sys.signal_status_change(p_run_id, p_status)
677  	   THEN
678  	     l_return := 0;
679  	   ELSE
680  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not set the run state to ' || p_status || ' for run id ' || p_run_id);
681  	   END IF;
682  	 END IF;
683  	 RETURN l_return;
684    EXCEPTION
685  	 WHEN OTHERS THEN
686  	   -- log the error instead of RAISE
687  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
688  	   RETURN -1;
689    END set_script_status;
690  
691    FUNCTION register_next_script( p_function_name  IN VARCHAR2
692  				    , p_function_owner IN VARCHAR2
693  				    )
694  	 RETURN BOOLEAN
695    IS
696  	 PRAGMA AUTONOMOUS_TRANSACTION;
697  	 l_return	     BOOLEAN;
698  	 l_payload	     SOSL_PAYLOAD;
699  	 l_statement	     VARCHAR2(1024);
700  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
701  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.register_next_script';
702    BEGIN
703  	 l_return := FALSE;
704  	 l_statement := sosl_sys.build_script_call(p_function_name, p_function_owner);
705  	 BEGIN
706  	   EXECUTE IMMEDIATE l_statement INTO l_payload;
707  	   IF	   sosl_sys.is_executor_valid(l_payload.executor_id)
708  	      AND  l_payload.ext_script_id IS NOT NULL
709  	      AND  l_payload.script_file   IS NOT NULL
710  	   THEN
711  	     -- valid payload
712  	     INSERT INTO sosl_run_queue
713  	       (executor_id, ext_script_id, script_file)
714  	       VALUES
715  	       (l_payload.executor_id, l_payload.ext_script_id, l_payload.script_file)
716  	     ;
717  	     COMMIT;
718  	     l_return := TRUE;
719  	   ELSE
720  	     -- invalid payload, check if usable and save with error state if possible
721  	     IF     sosl_sys.is_executor(l_payload.executor_id)
722  		AND l_payload.ext_script_id IS NOT NULL
723  		AND l_payload.script_file   IS NOT NULL
724  	     THEN
725  	       -- insert the record with error state
726  	       INSERT INTO sosl_run_queue
727  		 (executor_id, ext_script_id, script_file, run_state)
728  		 VALUES
729  		 (l_payload.executor_id, l_payload.ext_script_id, l_payload.script_file, sosl_constants.RUN_STATE_ERROR)
730  	       ;
731  	       COMMIT;
732  	     END IF;
733  	     -- log the error
734  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'SOSL_PAYLOAD has invalid content, either the executor "' || l_payload.executor_id || '" is not valid or payload fields are NULL. External script id "' || l_payload.ext_script_id || '" script file "' || l_payload.script_file || '".');
735  	     l_return := FALSE;
736  	   END IF;
737  	 EXCEPTION
738  	   WHEN OTHERS THEN
739  	     sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
740  	     l_return := FALSE;
741  	 END;
742  	 -- if we have still FALSE return value, deactivate the executors for the given function
743  	 IF NOT l_return
744  	 THEN
745  	   IF NOT sosl_sys.deactivate_by_fn_get_next_script(p_function_owner, p_function_name, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
746  	   THEN
747  	     -- log error
748  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || p_function_name || ' function owner ' || p_function_owner);
749  	   END IF;
750  	 END IF;
751  	 RETURN l_return;
752    EXCEPTION
753  	 WHEN OTHERS THEN
754  	   -- log the error instead of RAISE
755  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
756  	   RETURN FALSE;
757    END register_next_script;
758  
759    FUNCTION register_waiting
760  	 RETURN BOOLEAN
761    IS
762  	 l_return	     BOOLEAN;
763  	 l_success	     BOOLEAN;
764  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
765  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.register_waiting';
766  	 CURSOR cur_fn_get_next_script
767  	 IS
768  	   SELECT function_owner
769  		, fn_get_next_script
770  	     FROM sosl_executor
771  	    WHERE executor_active   = sosl_constants.NUM_YES
772  	      AND executor_reviewed = sosl_constants.NUM_YES
773  	    GROUP BY function_owner
774  		   , fn_get_next_script
775  	 ;
776    BEGIN
777  	 l_return  := FALSE;
778  	 l_success := FALSE;
779  	 FOR rec IN cur_fn_get_next_script
780  	 LOOP
781  	   IF sosl_sys.register_next_script(rec.function_owner, rec.fn_get_next_script)
782  	   THEN
783  	     l_success := TRUE;
784  	   END IF;
785  	 END LOOP;
786  	 -- if at least one script was registered successfully, errors may be seen in the logs of register_next_script
787  	 IF l_success
788  	 THEN
789  	   l_return := TRUE;
790  	 ELSE
791  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Error fetching get_next_script functions. No defined function works correctly.');
792  	   l_return := FALSE;
793  	 END IF;
794  	 RETURN l_return;
795    EXCEPTION
796  	 WHEN OTHERS THEN
797  	   -- log the error instead of RAISE
798  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
799  	   RETURN FALSE;
800    END register_waiting;
801  
802    FUNCTION fetch_next_run_id
803  	 RETURN NUMBER
804    IS
805  	 l_run_id	     NUMBER;
806  	 l_count	     NUMBER;
807  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
808  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.fetch_next_run_id';
809  	 -- get waiting run id, oldest first
810  	 CURSOR cur_run_id
811  	 IS
812  	   SELECT run_id
813  	     FROM sosl_run_queue
814  	    WHERE run_state = sosl_constants.RUN_STATE_WAITING
815  	    ORDER BY created
816  	 ;
817    BEGIN
818  	 l_run_id := -1;
819  	 SELECT COUNT(*) INTO l_count FROM sosl_run_queue WHERE run_state = sosl_constants.RUN_STATE_WAITING;
820  	 IF l_count > 0
821  	 THEN
822  	   OPEN cur_run_id;
823  	   FETCH cur_run_id INTO l_run_id;
824  	   CLOSE cur_run_id;
825  	 END IF;
826  	 RETURN l_run_id;
827    EXCEPTION
828  	 WHEN OTHERS THEN
829  	   -- log the error instead of RAISE
830  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
831  	   RETURN -1;
832    END fetch_next_run_id;
833  
834    FUNCTION get_next_script
835  	 RETURN NUMBER
836    IS
837  	 l_run_id	     NUMBER;
838  	 l_state_result      NUMBER;
839  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
840  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_next_script';
841    BEGIN
842  	 l_run_id := -1;
843  	 -- if we have scripts
844  	 IF sosl_sys.has_scripts > 0
845  	 THEN
846  	   -- select all valid executors and get their results, store results in SOSL_RUN_QUEUE.
847  	   IF NOT sosl_sys.register_waiting
848  	   THEN
849  	     -- probably an error with defined functions, log the error
850  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Defined functions in error, not registered any new script.');
851  	   END IF;
852  	   -- as we should have scripts, the run queue still may have scripts even if register failed
853  	   l_run_id := sosl_sys.fetch_next_run_id;
854  	   IF l_run_id = sosl_constants.NUM_ERROR
855  	   THEN
856  	     -- log the error
857  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to fetch next run id.');
858  	   ELSE
859  	     -- mark run id as enqueued
860  	     l_state_result := sosl_sys.set_script_status(l_run_id, sosl_constants.RUN_STATE_ENQUEUED);
861  	     IF l_state_result = sosl_constants.NUM_ERROR
862  	     THEN
863  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not update run state to ENQUEUED for run id: ' || l_run_id);
864  	     END IF;
865  	   END IF;
866  	 END IF;
867  	 RETURN l_run_id;
868    EXCEPTION
869  	 WHEN OTHERS THEN
870  	   -- log the error instead of RAISE
871  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
872  	   RETURN -1;
873    END get_next_script;
874  
875  END;
876  /

Package body created.

SQL> @@../sosl_ddl/packages/sosl_api.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic package providing the API to the Simple Oracle Script Loader.
SQL> CREATE OR REPLACE PACKAGE sosl_api
  2  AS
  3    /**
  4    * This package contains SOSL API functions and procedures to be used by executors.
  5    */
  6  
  7    /** Function SOSL_API.SET_CONFIG
  8    * Sets an existing configuration value for a given configuration name.
  9    *
 10    * @return Exit code, either 0 = successful or -1 on error.
 11    */
 12    FUNCTION set_config( p_config_name  IN VARCHAR2
 13  			  , p_config_value IN VARCHAR2
 14  			  )
 15  	 RETURN NUMBER
 16    ;
 17  
 18    /** Function SOSL_API.GET_CONFIG
 19    * Gets an existing configuration value for a given and existing case sensitive configuration name.
 20    *
 21    * @return The configured value as VARCHAR2 or -1 string on error.
 22    */
 23    FUNCTION get_config(p_config_name IN VARCHAR2)
 24  	 RETURN VARCHAR2
 25    ;
 26  
 27  
 28    /** Function SOSL_API.BASE_PATH
 29    * Returns the base path to use for the given run id. Used to switch the run base path for scripts
 30    * running from a different directory.
 31    *
 32    * @return The configured full base path or a simple point for current directory if nothing is configured.
 33    */
 34    FUNCTION base_path(p_run_id IN NUMBER)
 35  	 RETURN VARCHAR2
 36    ;
 37  
 38    /** Function SOSL_API.CFG_PATH
 39    * Returns the relative configuration path to use for the given run id. A sosl_login.cfg file is expected
 40    * at the given location.
 41    *
 42    * @return The configured relative configuration path or the configured default set by the sosl server.
 43    */
 44    FUNCTION cfg_path(p_run_id IN NUMBER)
 45  	 RETURN VARCHAR2
 46    ;
 47  
 48    /** Function SOSL_API.TMP_PATH
 49    * Returns the relative temporary path to use for the given run id.
 50    *
 51    * @return The configured relative temporary path or the configured default set by the sosl server.
 52    */
 53    FUNCTION tmp_path(p_run_id IN NUMBER)
 54  	 RETURN VARCHAR2
 55    ;
 56  
 57    /** Function SOSL_API.LOG_PATH
 58    * Returns the relative log path to use for the given run id.
 59    *
 60    * @return The configured relative log path or the configured default set by the sosl server.
 61    */
 62    FUNCTION log_path(p_run_id IN NUMBER)
 63  	 RETURN VARCHAR2
 64    ;
 65  
 66  END;
 67  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_api.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_api
  2  AS
  3    -- for description see header file
  4  
  5    FUNCTION set_config( p_config_name  IN VARCHAR2
  6  			  , p_config_value IN VARCHAR2
  7  			  )
  8  	 RETURN NUMBER
  9    IS
 10    BEGIN
 11  	 RETURN NULL;
 12    END set_config;
 13  
 14    FUNCTION get_config(p_config_name IN VARCHAR2)
 15  	 RETURN VARCHAR2
 16    IS
 17    BEGIN
 18  	 RETURN NULL;
 19    END get_config;
 20  
 21    FUNCTION base_path(p_run_id IN NUMBER)
 22  	 RETURN VARCHAR2
 23    IS
 24    BEGIN
 25  	 RETURN NULL;
 26    END base_path;
 27  
 28    FUNCTION cfg_path(p_run_id IN NUMBER)
 29  	 RETURN VARCHAR2
 30    IS
 31    BEGIN
 32  	 RETURN NULL;
 33    END cfg_path;
 34  
 35    FUNCTION tmp_path(p_run_id IN NUMBER)
 36  	 RETURN VARCHAR2
 37    IS
 38    BEGIN
 39  	 RETURN NULL;
 40    END tmp_path;
 41  
 42    FUNCTION log_path(p_run_id IN NUMBER)
 43  	 RETURN VARCHAR2
 44    IS
 45    BEGIN
 46  	 RETURN NULL;
 47    END log_path;
 48  
 49  END;
 50  /

Package body created.

SQL> @@../sosl_ddl/packages/sosl_if.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- interface package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl_if
  2  AS
  3    /**
  4    * This package contains the internal interface to SOSL used by the Simple Oracle Script Loader.
  5    * Can be seen as tutorial and implementation hint for own interfaces.
  6    */
  7  
  8    /** Function SOSL_IF.HAS_SCRIPTS
  9    * Determines if script ids are available to be executed. To be defined in SOSL_EXECUTOR.
 10    *
 11    * @return The number of script ids waiting for execution.
 12    */
 13    FUNCTION has_scripts
 14  	 RETURN NUMBER
 15    ;
 16  
 17    /** Function SOSL_IF.GET_NEXT_SCRIPT
 18    * Returns the next script id to execute. To be defined in SOSL_EXECUTOR.
 19    *
 20    * @return The id of the next script to execute.
 21    */
 22    FUNCTION get_next_script
 23  	 RETURN SOSL_PAYLOAD
 24    ;
 25  
 26    /** Function SOSL_IF.SET_SCRIPT_STATUS
 27    * Sets the status of a script. To be defined in SOSL_EXECUTOR.
 28    *
 29    * @param p_reference The reference to the script to update as SOSL_PAYLOAD containing executor_id, ext_script_id and script_file.
 30    * @param p_status The status for the script to set. Status: 0 WAITING, 1 PREPARING, 2 ENQUEUED, 3 RUNNING, 4 SUCCESS, 5 ERROR.
 31    * @param p_status_msg An optional message related to current status change, like error messages. SOSL will provide the identifier of SOSLERRORLOG in case of errors.
 32    *
 33    * @return 0 on success, -1 on errors.
 34    */
 35    FUNCTION set_script_status( p_reference	 IN SOSL_PAYLOAD
 36  				 , p_status	 IN NUMBER
 37  				 , p_status_msg  IN VARCHAR2 DEFAULT NULL
 38  				 )
 39  	 RETURN NUMBER
 40    ;
 41  
 42    /* FUNCTION SOSL_IF.SEND_MAIL
 43    * This function is mainly used for testing. In the default setting, it will only send the mail message to
 44    * SOSL_SERVER_LOG.
 45    *
 46    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
 47    * @param p_recipients The semicolon separated list of mail recipient addresses.
 48    * @param p_subject A preferablly short subject for the mail.
 49    * @param p_message The correctly formatted mail message.
 50    * @param p_test_mode The default is test mode, set to FALSE if mail should be used.
 51    *
 52    * @return Will return 0 on success or -1 on errors.
 53    */
 54    FUNCTION send_mail( p_sender	 IN VARCHAR2
 55  			 , p_recipients  IN VARCHAR2
 56  			 , p_subject	 IN VARCHAR2
 57  			 , p_message	 IN VARCHAR2
 58  			 , p_test_mode	 IN BOOLEAN  DEFAULT TRUE
 59  			 )
 60  	 RETURN NUMBER
 61    ;
 62  
 63  END;
 64  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_if.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_if
  2  AS
  3    -- see package header for documentation
  4    FUNCTION has_scripts
  5  	 RETURN NUMBER
  6    IS
  7  	 l_return	     NUMBER;
  8  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'HAS_SCRIPTS';
  9  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_if.has_scripts';
 10    BEGIN
 11  	 SELECT COUNT(*)
 12  	   INTO l_return
 13  	   FROM sosl_if_script
 14  	 ;
 15  	 RETURN -1;
 16    EXCEPTION
 17  	 WHEN OTHERS THEN
 18  	   -- log the error instead of RAISE
 19  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 20  	   RETURN -1;
 21    END has_scripts;
 22  
 23    FUNCTION get_next_script
 24  	 RETURN SOSL_PAYLOAD
 25    IS
 26    BEGIN
 27  	 RETURN NULL;
 28    END get_next_script;
 29  
 30    FUNCTION set_script_status( p_reference	 IN SOSL_PAYLOAD
 31  				 , p_status	 IN NUMBER
 32  				 , p_status_msg  IN VARCHAR2 DEFAULT NULL
 33  				 )
 34  	 RETURN NUMBER
 35    IS
 36    BEGIN
 37  	 RETURN -1;
 38    END set_script_status;
 39  
 40    FUNCTION send_mail( p_sender	 IN VARCHAR2
 41  			 , p_recipients  IN VARCHAR2
 42  			 , p_subject	 IN VARCHAR2
 43  			 , p_message	 IN VARCHAR2
 44  			 , p_test_mode	 IN BOOLEAN  DEFAULT TRUE
 45  			 )
 46  	 RETURN NUMBER
 47    IS
 48  	 l_return  NUMBER;
 49    BEGIN
 50  	 RETURN sosl_util.dummy_mail(p_sender, p_recipients, p_subject, p_message);
 51    END send_mail;
 52  
 53  END;
 54  /

Package body created.

SQL> -- table trigger using packages and tables defined
SQL> @@../sosl_ddl/trigger/sosl_server_log_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_server_log_ins_trg
  2    BEFORE INSERT ON sosl_server_log
  3    FOR EACH ROW
  4  DECLARE
  5    l_split		   BOOLEAN;
  6    l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_TRIGGER';
  7    l_self_caller	   sosl_server_log.caller%TYPE		 := 'sosl_server_log_ins_trg';
  8  BEGIN
  9    -- first set default value if not set, as Oracle does not support default values from package variables
 10    IF :NEW.log_type = sosl_constants.GEN_NA_TYPE
 11    THEN
 12  	 :NEW.log_type := sosl_constants.LOG_INFO_TYPE;
 13    END IF;
 14    -- instead of check constraint to get package support
 15    IF NOT sosl_log.log_type_valid(:NEW.log_type)
 16    THEN
 17  	 -- do not block logging, log the error instead, move message to full message
 18  	 :NEW.full_message := :NEW.message || :NEW.full_message;
 19  	 :NEW.message	   := 'Invalid log type. Not supported by package SOSL_SYS. Given log type: ' || NVL(:NEW.log_type, sosl_constants.GEN_NULL_TEXT);
 20  	 :NEW.log_type	   := sosl_constants.LOG_FATAL_TYPE;
 21    ELSE
 22  	 :NEW.log_type := sosl_log.get_valid_log_type(:NEW.log_type);
 23    END IF;
 24    :NEW.exec_timestamp := SYSTIMESTAMP;
 25    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 26    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 27    -- split messages
 28    IF NOT sosl_log.distribute(:NEW.message, :NEW.full_message, 4000)
 29    THEN
 30  	 -- do not block logging, log the error instead, if :NEW.message contains error information leave it there
 31  	 IF :NEW.message IS NULL AND :NEW.full_message IS NULL
 32  	 THEN
 33  	   :NEW.message := 'Full message must be given, if message is NULL or vice versa.';
 34  	 END IF;
 35  	 :NEW.log_type := sosl_constants.LOG_FATAL_TYPE;
 36    END IF;
 37  EXCEPTION
 38    WHEN OTHERS THEN
 39  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 40  	 RAISE;
 41  END;
 42  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_upd_trg
  2    BEFORE UPDATE ON sosl_server_log
  3  BEGIN
  4    sosl_log.minimal_error_log( 'sosl_server_log_upd_trg'
  5  				 , 'SOSL_TRIGGER'
  6  				 , '-20000 No updates allowed on a log table.'
  7  				 , 'Forbidden UPDATE on log table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
  8  				 )
  9    ;
 10    RAISE_APPLICATION_ERROR(-20000, 'No updates allowed on a log table.');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_del_trg
  2    BEFORE DELETE ON sosl_server_log
  3  BEGIN
  4    sosl_log.minimal_error_log( 'sosl_server_log_del_trg'
  5  				 , 'SOSL_TRIGGER'
  6  				 , '-20001 Delete records from a log table is not allowed. This is an admin job which needs sufficient rights and usage of the SOSL API.'
  7  				 , 'Forbidden DELETE on log table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
  8  				 )
  9    ;
 10    RAISE_APPLICATION_ERROR(-20001, 'Delete records from a log table is not allowed. This is an admin job which needs sufficient rights and usage of the SOSL API.');
 11  END;
 12  /

Trigger created.

SQL> @@../sosl_ddl/trigger/sosl_config_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_config_ins_upd_trg
  2    BEFORE INSERT OR UPDATE ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok		   BOOLEAN;
  6    l_date		   DATE;
  7    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_CONFIG';
  8    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_config_ins_upd_trg';
  9  BEGIN
 10    -- remove any leading and trailing blanks from config_value
 11    :NEW.config_value   := TRIM(:NEW.config_value);
 12    IF UPDATING
 13    THEN
 14  	 :NEW.created	     := :OLD.created;
 15  	 :NEW.created_by     := :OLD.created_by;
 16  	 :NEW.created_by_os  := :OLD.created_by_os;
 17    ELSE
 18  	 :NEW.created	     := SYSDATE;
 19  	 :NEW.created_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 20  	 :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 21    END IF;
 22    :NEW.updated	   := SYSDATE;
 23    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 24    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 25    -- check max length if defined
 26    IF :NEW.config_type = 'CHAR'
 27    THEN
 28  	 IF :NEW.config_max_length > 0
 29  	 THEN
 30  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 31  	   THEN
 32  	     sosl_log.minimal_error_log( l_self_caller
 33  				       , l_self_log_category
 34  				       , '-20002 The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value)
 35  				       , 'Wrong length of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 36  				       )
 37  	     ;
 38  	     RAISE_APPLICATION_ERROR(-20002, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 39  	   END IF;
 40  	 END IF;
 41    END IF;
 42    -- check number type
 43    IF :NEW.config_type = 'NUMBER'
 44    THEN
 45  	 l_ok := TRUE;
 46  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 47  	 BEGIN
 48  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 49  	 EXCEPTION
 50  	   WHEN OTHERS THEN
 51  	     sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 52  	     l_ok := FALSE;
 53  	 END;
 54  	 IF NOT l_ok
 55  	 THEN
 56  	   sosl_log.minimal_error_log( l_self_caller
 57  				     , l_self_log_category
 58  				     , '-20003 The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.'
 59  				     , 'Wrong type of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 60  				     )
 61  	   ;
 62  	   RAISE_APPLICATION_ERROR(-20003, 'The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.');
 63  	 END IF;
 64    END IF;
 65  END;
 66  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_config_del_trg
  2    BEFORE DELETE ON sosl_config
  3    FOR EACH ROW
  4  BEGIN
  5    -- protect system parameters from delete
  6    IF :OLD.config_name IN ( 'SOSL_PATH_CFG'
  7  			      , 'SOSL_PATH_TMP'
  8  			      , 'SOSL_PATH_LOG'
  9  			      , 'SOSL_START_LOG'
 10  			      , 'SOSL_BASE_LOG'
 11  			      , 'SOSL_EXT_LOG'
 12  			      , 'SOSL_EXT_TMP'
 13  			      , 'SOSL_EXT_LOCK'
 14  			      , 'SOSL_EXT_ERROR'
 15  			      , 'SOSL_MAX_PARALLEL'
 16  			      , 'SOSL_RUNMODE'
 17  			      , 'SOSL_DEFAULT_WAIT'
 18  			      , 'SOSL_NOJOB_WAIT'
 19  			      , 'SOSL_PAUSE_WAIT'
 20  			      )
 21    THEN
 22  	 sosl_log.minimal_error_log( 'sosl_config_del_trg'
 23  				   , 'SOSL_CONFIG'
 24  				   , '-20004 The given system config_name "' || :OLD.config_name || '" cannot be deleted.'
 25  				   , 'Forbidden delete of config name for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 26  				   )
 27  	 ;
 28  	 RAISE_APPLICATION_ERROR(-20004, 'The given system config_name "' || :OLD.config_name || '" cannot be deleted.');
 29    END IF;
 30  END;
 31  /

Trigger created.

SQL> 
SQL> @@../sosl_ddl/trigger/sosl_executor_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_executor_ins_trg
  2    BEFORE INSERT ON sosl_executor
  3    FOR EACH ROW
  4  DECLARE
  5    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_EXECUTOR';
  6    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_executor_ins_trg';
  7  BEGIN
  8    :NEW.created	       := SYSDATE;
  9    :NEW.created_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.created_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 11    :NEW.updated	       := SYSDATE;
 12    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 13    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 14    :NEW.executor_active    := 0;
 15    :NEW.executor_reviewed  := 0;
 16    -- transform users and functions to UPPERCASE, no support currently for special mix-case.
 17    :NEW.function_owner	 := UPPER(:NEW.function_owner);
 18    :NEW.db_user		 := UPPER(:NEW.db_user);
 19    :NEW.fn_has_scripts	 := UPPER(:NEW.fn_has_scripts);
 20    :NEW.fn_get_next_script	 := UPPER(:NEW.fn_get_next_script);
 21    :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 22    :NEW.fn_send_db_mail	 := UPPER(:NEW.fn_send_db_mail);
 23    -- check user
 24    IF NOT sosl_util.has_db_user(:NEW.db_user)
 25    THEN
 26  	 sosl_log.minimal_error_log( l_self_caller
 27  				   , l_self_log_category
 28  				   , '-20005 The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 29  				   , 'Wrong database user for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 30  				   )
 31  	 ;
 32  	 RAISE_APPLICATION_ERROR(-20005, 'The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 33    END IF;
 34    IF NOT sosl_util.has_db_user(:NEW.function_owner)
 35    THEN
 36  	 sosl_log.minimal_error_log( l_self_caller
 37  				   , l_self_log_category
 38  				   , '-20006 The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 39  				   , 'Wrong function owner for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 40  				   )
 41  	 ;
 42  	 RAISE_APPLICATION_ERROR(-20006, 'The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 43    END IF;
 44    -- check configured functions
 45    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 46    THEN
 47  	 sosl_log.minimal_error_log( l_self_caller
 48  				   , l_self_log_category
 49  				   , '-20007 The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 50  				   , 'Wrong function has_scripts for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 51  				   )
 52  	 ;
 53  	 RAISE_APPLICATION_ERROR(-20007, 'The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 54    END IF;
 55    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'OBJECT')
 56    THEN
 57  	 sosl_log.minimal_error_log( l_self_caller
 58  				   , l_self_log_category
 59  				   , '-20008 The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to SOSL.'
 60  				   , 'Wrong function get_next_script for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 61  				   )
 62  	 ;
 63  	 RAISE_APPLICATION_ERROR(-20008, 'The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to SOSL.');
 64    END IF;
 65    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
 66    THEN
 67  	 sosl_log.minimal_error_log( l_self_caller
 68  				   , l_self_log_category
 69  				   , '-20009 The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 70  				   , 'Wrong function set_script_status for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 71  				   )
 72  	 ;
 73  	 RAISE_APPLICATION_ERROR(-20009, 'The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 74    END IF;
 75    -- check mail
 76    IF :NEW.use_mail = 1
 77    THEN
 78  	 IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
 79  	 THEN
 80  	   sosl_log.minimal_error_log( l_self_caller
 81  				     , l_self_log_category
 82  				     , '-20010 The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 83  				     , 'Wrong function send_db_mail for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 84  				     )
 85  	   ;
 86  	   RAISE_APPLICATION_ERROR(-20010, 'The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 87  	 END IF;
 88    END IF;
 89    -- log the insert
 90    sosl_log.minimal_info_log( l_self_caller
 91  				, l_self_log_category
 92  				, 'A new executor has been defined for DB user: ' || :NEW.db_user || ' with function owner: ' || :NEW.function_owner || ' created by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 93  				)
 94    ;
 95  EXCEPTION
 96    WHEN OTHERS THEN
 97  	 -- catch and log all undefined exceptions
 98  	 IF SQLCODE NOT IN (-20005, -20006, -20007, -20008, -20009, -20010)
 99  	 THEN
100  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
101  	 END IF;
102  	 -- raise all errors
103  	 RAISE;
104  END;
105  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_executor_upd_trg
  2    BEFORE UPDATE ON sosl_executor
  3    FOR EACH ROW
  4  DECLARE
  5    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_EXECUTOR';
  6    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_executor_upd_trg';
  7  BEGIN
  8    :NEW.updated	   := SYSDATE;
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11    -- no overwrite for this values, log changes
 12    sosl_log.log_column_change(:NEW.created, :OLD.created, 'SOSL_EXECUTOR.CREATED', l_self_caller);
 13    :NEW.created := :OLD.created;
 14    sosl_log.log_column_change(:NEW.created_by, :OLD.created_by, 'SOSL_EXECUTOR.CREATED_BY', l_self_caller);
 15    :NEW.created_by := :OLD.created_by;
 16    sosl_log.log_column_change(:NEW.created_by_os, :OLD.created_by_os, 'SOSL_EXECUTOR.CREATED_BY_OS', l_self_caller);
 17    :NEW.created_by_os := :OLD.created_by_os;
 18    sosl_log.log_column_change(:NEW.function_owner, :OLD.function_owner, 'SOSL_EXECUTOR.FUNCTION_OWNER', l_self_caller);
 19    :NEW.function_owner := :OLD.function_owner;
 20    sosl_log.log_column_change(:NEW.db_user, :OLD.db_user, 'SOSL_EXECUTOR.DB_USER', l_self_caller);
 21    :NEW.db_user := :OLD.db_user;
 22    -- prepare possibly modified values
 23    sosl_log.log_column_change(:NEW.executor_active, :OLD.executor_active, 'SOSL_EXECUTOR.EXECUTOR_ACTIVE', l_self_caller, FALSE);
 24    sosl_log.log_column_change(:NEW.executor_reviewed, :OLD.executor_reviewed, 'SOSL_EXECUTOR.EXECUTOR_REVIEWED', l_self_caller, FALSE);
 25    sosl_log.log_column_change(:NEW.fn_has_scripts, :OLD.fn_has_scripts, 'SOSL_EXECUTOR.FN_HAS_SCRIPTS', l_self_caller, FALSE);
 26    :NEW.fn_has_scripts := UPPER(:NEW.fn_has_scripts);
 27    sosl_log.log_column_change(:NEW.fn_get_next_script, :OLD.fn_get_next_script, 'SOSL_EXECUTOR.FN_GET_NEXT_SCRIPT', l_self_caller, FALSE);
 28    :NEW.fn_get_next_script := UPPER(:NEW.fn_get_next_script);
 29    sosl_log.log_column_change(:NEW.fn_set_script_status, :OLD.fn_set_script_status, 'SOSL_EXECUTOR.FN_SET_SCRIPT_STATUS', l_self_caller, FALSE);
 30    :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 31    sosl_log.log_column_change(:NEW.fn_send_db_mail, :OLD.fn_send_db_mail, 'SOSL_EXECUTOR.FN_SEND_DB_MAIL', l_self_caller, FALSE);
 32    :NEW.fn_send_db_mail := UPPER(:NEW.fn_send_db_mail);
 33    -- do all checks again including user
 34    -- check user
 35    IF NOT sosl_util.has_db_user(:NEW.db_user)
 36    THEN
 37  	 sosl_log.minimal_error_log( l_self_caller
 38  				   , l_self_log_category
 39  				   , '-20005 The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 40  				   , 'Wrong database user for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 41  				   )
 42  	 ;
 43  	 RAISE_APPLICATION_ERROR(-20005, 'The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 44    END IF;
 45    IF NOT sosl_util.has_db_user(:NEW.function_owner)
 46    THEN
 47  	 sosl_log.minimal_error_log( l_self_caller
 48  				   , l_self_log_category
 49  				   , '-20006 The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 50  				   , 'Wrong function owner for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 51  				   )
 52  	 ;
 53  	 RAISE_APPLICATION_ERROR(-20006, 'The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 54    END IF;
 55    -- check configured functions
 56    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 57    THEN
 58  	 sosl_log.minimal_error_log( l_self_caller
 59  				   , l_self_log_category
 60  				   , '-20007 The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 61  				   , 'Wrong function has_scripts for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 62  				   )
 63  	 ;
 64  	 RAISE_APPLICATION_ERROR(-20007, 'The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 65    END IF;
 66    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'OBJECT')
 67    THEN
 68  	 sosl_log.minimal_error_log( l_self_caller
 69  				   , l_self_log_category
 70  				   , '-20008 The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to SOSL.'
 71  				   , 'Wrong function get_next_script for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 72  				   )
 73  	 ;
 74  	 RAISE_APPLICATION_ERROR(-20008, 'The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to SOSL.');
 75    END IF;
 76    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
 77    THEN
 78  	 sosl_log.minimal_error_log( l_self_caller
 79  				   , l_self_log_category
 80  				   , '-20009 The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 81  				   , 'Wrong function set_script_status for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 82  				   )
 83  	 ;
 84  	 RAISE_APPLICATION_ERROR(-20009, 'The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 85    END IF;
 86    -- check mail
 87    IF :NEW.use_mail = 1
 88    THEN
 89  	 IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
 90  	 THEN
 91  	   sosl_log.minimal_error_log( l_self_caller
 92  				     , l_self_log_category
 93  				     , '-20010 The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.'
 94  				     , 'Wrong function send_db_mail for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 95  				     )
 96  	   ;
 97  	   RAISE_APPLICATION_ERROR(-20010, 'The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to SOSL.');
 98  	 END IF;
 99    END IF;
100    -- check grants if active and reviewed
101    IF      :NEW.executor_active    = sosl_constants.NUM_YES
102  	  AND  :NEW.executor_reviewed  = sosl_constants.NUM_YES
103    THEN
104  	 IF    NOT sosl_util.grant_role(:NEW.db_user, 'SOSL_USER')
105  	    OR NOT sosl_util.grant_role(:NEW.function_owner, 'SOSL_EXECUTOR')
106  	 THEN
107  	   -- could not check or grant role to database user or function owner
108  	   sosl_log.minimal_error_log( l_self_caller
109  				     , l_self_log_category
110  				     , '-20012 Error granting necessary roles to db user (SOSL_USER) or function owner (SOSL_EXECUTOR). Check setup and roles. Probably grant the roles manually before trying update again.'
111  				     , 'Failed granting necessary roles for SOSL_EXECUTOR table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
112  				     )
113  	   ;
114  	   RAISE_APPLICATION_ERROR(-20011, 'Error granting necessary roles to db user (SOSL_USER) or function owner (SOSL_EXECUTOR). Check setup and roles. Probably grant the roles manually before trying update again.');
115  	 END IF;
116    END IF;
117    -- log the update
118    sosl_log.minimal_info_log( l_self_caller
119  				, l_self_log_category
120  				, 'The configuration for executor ID: ' || :OLD.executor_id || ' has been updated by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER') || ' see full_message for details.'
121  				)
122    ;
123  EXCEPTION
124    WHEN OTHERS THEN
125  	 -- catch and log all undefined exceptions
126  	 IF SQLCODE NOT IN (-20005, -20006, -20007, -20008, -20009, -20010, -20011)
127  	 THEN
128  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
129  	 END IF;
130  	 -- raise all errors
131  	 RAISE;
132  END;
133  /

Trigger created.

SQL> @@../sosl_ddl/trigger/sosl_run_queue_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_run_queue_ins_trg
  2    BEFORE INSERT ON sosl_run_queue
  3    FOR EACH ROW
  4  DECLARE
  5    l_executor_valid    NUMBER;
  6    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_RUN_QUEUE';
  7    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_run_queue_ins_trg';
  8  BEGIN
  9    -- check executor, if not accepted and reviewed, set run state to error, else waiting
 10    IF sosl_sys.is_executor_valid(:NEW.executor_id)
 11    THEN
 12  	 :NEW.run_state      := sosl_constants.RUN_STATE_WAITING;
 13  	 :NEW.waiting	     := SYSTIMESTAMP;
 14  	 :NEW.waiting_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 15  	 :NEW.waiting_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 16  	 :NEW.finished	     := NULL;
 17  	 :NEW.finished_by    := NULL;
 18  	 :NEW.finished_by_os := NULL;
 19    ELSE
 20  	 -- log error
 21  	 sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Given executor id ' || :NEW.executor_id || ' is not active and reviewed. Script execution not allowed.');
 22  	 :NEW.run_state      := sosl_constants.RUN_STATE_ERROR;
 23  	 :NEW.waiting	     := NULL;
 24  	 :NEW.waiting_by     := NULL;
 25  	 :NEW.waiting_by_os  := NULL;
 26  	 :NEW.finished	     := SYSTIMESTAMP;
 27  	 :NEW.finished_by    := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 28  	 :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 29    END IF;
 30    -- set basic timestamps
 31    :NEW.created	   := SYSTIMESTAMP;
 32    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 33    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 34    -- overwrite any other injected dates and user on insert
 35    :NEW.enqueued	   := NULL;
 36    :NEW.enqueued_by    := NULL;
 37    :NEW.enqueued_by_os := NULL;
 38    :NEW.started	   := NULL;
 39    :NEW.started_by	   := NULL;
 40    :NEW.started_by_os  := NULL;
 41    :NEW.running	   := NULL;
 42    :NEW.running_by	   := NULL;
 43    :NEW.running_by_os  := NULL;
 44    -- log the insert
 45    sosl_log.minimal_info_log( l_self_caller
 46  				, l_self_log_category
 47  				, 'A new script with run id ' || :NEW.run_id || ' has been added to the run queue created by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 48  				)
 49    ;
 50  EXCEPTION
 51    WHEN OTHERS THEN
 52  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 53  	 -- raise all errors
 54  	 RAISE;
 55  END;
 56  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_run_queue_upd_trg
  2    BEFORE UPDATE ON sosl_run_queue
  3    FOR EACH ROW
  4  DECLARE
  5    l_executor_valid    NUMBER;
  6    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_RUN_QUEUE';
  7    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_run_queue_upd_trg';
  8  BEGIN
  9    -- make sure created and basics are not changed
 10    sosl_log.log_column_change(:NEW.created, :OLD.created, 'SOSL_RUN_QUEUE.CREATED', l_self_caller);
 11    :NEW.created	   := :OLD.created;
 12    sosl_log.log_column_change(:NEW.created_by, :OLD.created_by, 'SOSL_RUN_QUEUE.CREATED_BY', l_self_caller);
 13    :NEW.created_by	   := :OLD.created_by;
 14    sosl_log.log_column_change(:NEW.created_by_os, :OLD.created_by_os, 'SOSL_RUN_QUEUE.CREATED_BY_OS', l_self_caller);
 15    :NEW.created_by_os  := :OLD.created_by_os;
 16    sosl_log.log_column_change(:NEW.executor_id, :OLD.executor_id, 'SOSL_RUN_QUEUE.EXECUTOR_ID', l_self_caller);
 17    :NEW.executor_id    := :OLD.executor_id;
 18    sosl_log.log_column_change(:NEW.ext_script_id, :OLD.ext_script_id, 'SOSL_RUN_QUEUE.EXT_SCRIPT_ID', l_self_caller);
 19    :NEW.ext_script_id  := :OLD.ext_script_id;
 20    sosl_log.log_column_change(:NEW.script_file, :OLD.script_file, 'SOSL_RUN_QUEUE.SCRIPT_FILE', l_self_caller);
 21    :NEW.script_file    := :OLD.script_file;
 22    -- check run state order, error can always be set
 23    IF :NEW.run_state != sosl_constants.RUN_STATE_ERROR
 24    THEN
 25  	 -- only if run state has changed
 26  	 IF :NEW.run_state != :OLD.run_state
 27  	 THEN
 28  	   -- normal transitions, organized as ordered sequence numbers 0 to 4
 29  	   -- WAITING -> ENQUEUED, ENQUEUED -> STARTED, STARTED -> RUNNING, RUNNING -> FINISHED, FINSHED -> WAITING
 30  	   IF	  (   :OLD.run_state = sosl_constants.RUN_STATE_ERROR
 31  		   OR :OLD.run_state = sosl_constants.RUN_STATE_FINISHED
 32  		  )
 33  	      AND :NEW.run_state != sosl_constants.RUN_STATE_WAITING
 34  	   THEN
 35  	     -- log it
 36  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Wrong state transition: ' || sosl_util.run_state_text(:OLD.run_state) || ' not allowed to change to ' || sosl_util.run_state_text(:NEW.run_state) || '. State set to ERROR.');
 37  	     -- ignore invalid run state, set state to error
 38  	     :NEW.run_state := sosl_constants.RUN_STATE_ERROR;
 39  	   ELSE
 40  	     -- next state must be exactly old run state +1
 41  	     IF :NEW.run_state != (:OLD.run_state + 1)
 42  	     THEN
 43  	       -- log it
 44  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Wrong state transition: ' || sosl_util.run_state_text(:OLD.run_state) || ' not allowed to change to ' || sosl_util.run_state_text(:NEW.run_state) || '. State set to ERROR.');
 45  	       -- ignore invalid run state, set state to error
 46  	       :NEW.run_state := sosl_constants.RUN_STATE_ERROR;
 47  	     END IF;
 48  	   END IF;
 49  	 END IF;
 50    END IF;
 51    -- check executor and prevent updates on run state if not valid, set run state to error if executor not valid
 52    IF sosl_sys.is_executor_valid(:NEW.executor_id)
 53    THEN
 54  	-- update dates and user by run state
 55  	 CASE :NEW.run_state
 56  	   WHEN sosl_constants.RUN_STATE_WAITING THEN
 57  	     :NEW.waiting	 := SYSTIMESTAMP;
 58  	     :NEW.waiting_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 59  	     :NEW.waiting_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 60  	   WHEN sosl_constants.RUN_STATE_ENQUEUED THEN
 61  	     :NEW.enqueued	 := SYSTIMESTAMP;
 62  	     :NEW.enqueued_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 63  	     :NEW.enqueued_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 64  	   WHEN sosl_constants.RUN_STATE_STARTED THEN
 65  	     :NEW.started	 := SYSTIMESTAMP;
 66  	     :NEW.started_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 67  	     :NEW.started_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 68  	   WHEN sosl_constants.RUN_STATE_RUNNING THEN
 69  	     :NEW.running	 := SYSTIMESTAMP;
 70  	     :NEW.running_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 71  	     :NEW.running_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 72  	   WHEN sosl_constants.RUN_STATE_FINISHED THEN
 73  	     :NEW.finished	 := SYSTIMESTAMP;
 74  	     :NEW.finished_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 75  	     :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 76  	   ELSE
 77  	     -- any other state is an error state
 78  	     :NEW.finished	 := SYSTIMESTAMP;
 79  	     :NEW.finished_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 80  	     :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 81  	     :NEW.run_state	 := sosl_constants.RUN_STATE_ERROR;
 82  	 END CASE;
 83    ELSE
 84  	 -- log error
 85  	 sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Current executor id ' || :NEW.executor_id || ' is not longer active and reviewed. Script execution not allowed.');
 86  	 -- set run state to error in any case
 87  	 :NEW.run_state      := sosl_constants.RUN_STATE_ERROR;
 88  	 :NEW.enqueued	     := :OLD.enqueued;
 89  	 :NEW.enqueued_by    := :OLD.enqueued_by;
 90  	 :NEW.enqueued_by_os := :OLD.enqueued_by_os;
 91  	 :NEW.started	     := :OLD.started;
 92  	 :NEW.started_by     := :OLD.started_by;
 93  	 :NEW.started_by_os  := :OLD.started_by_os;
 94  	 :NEW.running	     := :OLD.running;
 95  	 :NEW.running_by     := :OLD.running_by;
 96  	 :NEW.running_by_os  := :OLD.running_by_os;
 97  	 :NEW.finished	     := :OLD.finished;
 98  	 :NEW.finished_by    := :OLD.finished_by;
 99  	 :NEW.finished_by_os := :OLD.finished_by_os;
100    END IF;
101    -- log the update
102    sosl_log.minimal_info_log( l_self_caller
103  				, l_self_log_category
104  				, 'Updated run id ' || :OLD.run_id || ' by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
105  				)
106    ;
107  EXCEPTION
108    WHEN OTHERS THEN
109  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
110  	 -- raise all errors
111  	 RAISE;
112  END;
113  /

Trigger created.

SQL> @@../sosl_ddl/trigger/sosl_if_script_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_if_script_ins_trg
  2    BEFORE INSERT ON sosl_if_script
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := NULL;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := NULL;
 10    :NEW.updated_by_os  := NULL;
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_if_script_upd_trg
  2    BEFORE UPDATE ON sosl_if_script
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    :NEW.updated	   := SYSDATE;
 10    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12  END;
 13  /

Trigger created.

SQL> -- wrapper functions
SQL> @@../sosl_ddl/functions/has_scripts.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE FUNCTION has_scripts
  2    RETURN NUMBER
  3  IS
  4    /* Wrapper function for defined executor has_scripts functions.
  5    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
  6    * return a number greater 0. Will log all functions in error.
  7    *
  8    * @return The amount of scripts waiting for all valid executor has_scripts functions or -1 if all functions have errors.
  9    */
 10    l_return 	   NUMBER;
 11    l_self_log_category sosl_server_log.log_category%TYPE := 'HAS_SCRIPTS';
 12    l_self_caller	   sosl_server_log.caller%TYPE	     := 'has_scripts wrapper';
 13  BEGIN
 14    l_return := sosl_sys.has_scripts;
 15    RETURN l_return;
 16  EXCEPTION
 17    WHEN OTHERS THEN
 18  	 -- log the error instead of RAISE
 19  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 20  	 RETURN -1;
 21  END;
 22  /

Function created.

SQL> -- grants, everyone can see if scripts are available, inherited by others
SQL> GRANT EXECUTE ON has_scripts TO sosl_guest;

Grant succeeded.

SQL> @@sosl_config_defaults.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- load default values that can be configured in the database (mandatory)
SQL> -- basic configuration
SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_RUNMODE', 'RUN', 'CHAR', 'Determines if the server should RUN, WAIT or STOP. Read by the SOSL server. RUN will cause the SOSL server, if started to run as long as it does not get a STOP signal from the database. Set it to STOP to stop the SOSL server. Set to WAIT if the server should not call any script apart the check for the run mode. Can be locally overwritten.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAX_PARALLEL', '8', 'NUMBER', 'The maximum of parallel started scripts. Read by the SOSL server. After this amount if scripts is started, next scripts are only loaded, if the run count is below this value.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_DEFAULT_WAIT', '1', 'NUMBER', 'Determines the normal sleep time in seconds the sosl server has between calls if scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_NOJOB_WAIT', '120', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if no scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_PAUSE_WAIT', '3600', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if run mode is set to wait.')
  5  ;

1 row created.

SQL> 
SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_CFG', '..\..\sosl_cfg\', 4000, 'Information only. The relative path with delimiter at path end to configuration files the SOSL server uses for SOSL logins. Set by SOSL server. As configuration files contain credentials and secrets the path should be in a safe space with controlled user rights.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_TMP', '..\..\sosl_tmp\', 239, 'Information only. The relative path with delimiter at path end to temporary files the SOSL server uses. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_LOG', '..\..\sosl_log\', 239, 'Information only. The relative path with delimiter at path end to log files the SOSL server creates. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_START_LOG', 'sosl_server', 'Information only. The log filename for start and end of SOSL server CMD. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_BASE_LOG', 'sosl_job_', 'Information only. The base log filename for single job runs. Will be extended by GUID. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOG', 'log', 'Information only. The log file extension to use. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_TMP', 'tmp', 'Information only. The log file extension for temporary logs to use. On error those file extension will be renamed to SOSL_EXT_ERROR extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOCK', 'lock', 'Information only. The default process lock file extension. Lock files will always get deleted either on service start or after a run. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_ERROR', 'err', 'Information only. The default process error file extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> COMMIT;

Commit complete.

SQL> -- ==============INSTALL done==============
SQL> @@../sosl_sql/util/log_silent.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> SET ECHO OFF
SUCCESS - no errors found during setup          0
