SQL> @@../sosl_ddl/tables/soslerrorlog.sql
SQL> CREATE TABLE soslerrorlog
  2    ( username    VARCHAR2(256)
  3    , timestamp   TIMESTAMP
  4  	 -- older versions than Oracle 23 use VARCHAR2(1024)
  5    , script      CLOB	   -- VARCHAR2(1024)
  6    , identifier  VARCHAR2(256)
  7    , message     CLOB
  8    , statement   CLOB
  9    )
 10  ;

Table created.

SQL> COMMENT ON TABLE soslerrorlog IS 'Userdefined table for SQLPlus error logging';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.username IS 'Oracle account name';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.timestamp IS 'Time when the error occurred';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.script IS 'Name of the originating script if applicable';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.identifier IS 'User defined identifier string';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.message IS 'ORA, PLA or SP2 error message. No feed back messages are included. For example, "PL/SQL Block Created" is not recorded.';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.statement IS 'The statement causing the error';

Comment created.

SQL> @@../sosl_ddl/tables/sosl_config.sql
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_config
  2    ( config_name	     VARCHAR2(128)					       NOT NULL
  3    , config_value	     VARCHAR2(4000)					       NOT NULL
  4    , config_max_length   NUMBER	     DEFAULT -1 			       NOT NULL
  5    , config_type	     VARCHAR2(6)     DEFAULT 'CHAR'			       NOT NULL
  6    , created	     DATE	     DEFAULT SYSDATE			       NOT NULL
  7    , updated	     DATE	     DEFAULT SYSDATE			       NOT NULL
  8    , created_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
  9    , created_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
 11    , updated_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , config_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_config IS 'Holds the configuration used by SOSL. Will use the alias scfg.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_name IS 'The unique case sensitive name of the SOSL configuration object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_value IS 'The configuration value always as VARCHAR2. Type handling and conversion must be done by the caller.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_type IS 'Defines how the config value has to be interpreted. Currently supports CHAR and NUMBER.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_max_length IS 'Defines a maximum length for CHAR type config values if set to a number > 0. Default is -1, do not not check length.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_description IS 'Optional description of the SOSL config object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- primary key
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_pk
  3    PRIMARY KEY (config_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_type
  3    CHECK (config_type IN ('CHAR', 'NUMBER'))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_max_length
  3    CHECK (config_max_length = -1 OR config_max_length > 0)
  4  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_config_ins_upd_trg
  2    BEFORE INSERT OR UPDATE ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok    BOOLEAN;
  6    l_date  DATE;
  7  BEGIN
  8    -- remove any leading and trailing blanks from config_value
  9    :NEW.config_value   := TRIM(:NEW.config_value);
 10    IF UPDATING
 11    THEN
 12  	 :NEW.created	     := :OLD.created;
 13  	 :NEW.created_by     := :OLD.created_by;
 14  	 :NEW.created_by_os  := :OLD.created_by_os;
 15    ELSE
 16  	 :NEW.created	     := SYSDATE;
 17  	 :NEW.created_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 18  	 :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 19    END IF;
 20    :NEW.updated	   := SYSDATE;
 21    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 22    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 23    -- check max length if defined
 24    IF :NEW.config_type = 'CHAR'
 25    THEN
 26  	 IF :NEW.config_max_length > 0
 27  	 THEN
 28  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 29  	   THEN
 30  	     RAISE_APPLICATION_ERROR(-20000, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 31  	   END IF;
 32  	 END IF;
 33    END IF;
 34    -- check number type
 35    IF :NEW.config_type = 'NUMBER'
 36    THEN
 37  	 l_ok := TRUE;
 38  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 39  	 BEGIN
 40  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 41  	 EXCEPTION
 42  	   WHEN OTHERS THEN
 43  	     l_ok := FALSE;
 44  	 END;
 45  	 IF NOT l_ok
 46  	 THEN
 47  	   RAISE_APPLICATION_ERROR(-20001, 'The given config_value "' || :NEW.config_value || '" could not be converted successfully to a number.');
 48  	 END IF;
 49    END IF;
 50  END;
 51  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_config_del_trg
  2    BEFORE DELETE ON sosl_config
  3    FOR EACH ROW
  4  BEGIN
  5    -- protect system parameters from delete
  6    IF :OLD.config_name IN ( 'SOSL_PATH_CFG'
  7  			      , 'SOSL_PATH_TMP'
  8  			      , 'SOSL_PATH_LOG'
  9  			      , 'SOSL_EXT_LOG'
 10  			      , 'SOSL_EXT_LOCK'
 11  			      , 'SOSL_START_LOG'
 12  			      , 'SOSL_BASE_LOG'
 13  			      , 'SOSL_MAX_PARALLEL'
 14  			      )
 15    THEN
 16  	 RAISE_APPLICATION_ERROR(-20002, 'The given system config_name "' || :OLD.config_name || '" cannot be deleted.');
 17    END IF;
 18  END;
 19  /

Trigger created.

SQL> -- load default values that can be configured in the database
SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_PATH_CFG', '..\..\cfg\', 'Relative path with delimiter at path end to configuration files the SOSL server uses. Set by SOSL server. As configuration files contain credentials and secrets the path should be in a safe space with controlled user rights.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_TMP', '..\..\tmp\', 239, 'Relative path with delimiter at path end to temporary files the SOSL server uses. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_LOG', '..\..\log\', 239, 'Relative path with delimiter at path end to log files the SOSL server creates. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_START_LOG', 'sosl_server', 'Log filename for start and end of SOSL server CMD. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_BASE_LOG', 'sosl_job_', 'Base log filename for single job runs. Will be extended by GUID. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOG', 'log', 'Log file extension to use. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_TMP', 'tmp', 'Log file extension for temporary logs to use. On error those file extension will be renamed to SOSL_EXT_ERROR extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOCK', 'lock', 'Default process lock file extension. Lock files will always get deleted either on service start or after a run. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_ERROR', 'err', 'Default process error file extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAX_PARALLEL', '8', 'NUMBER', 'The maximum of parallel started scripts. Read by the SOSL server. After this amount if scripts is started, next scripts are only loaded, if the run count is below this value.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_RUNMODE', 'RUN', 'CHAR', 'Determines if the server should RUN, WAIT or STOP. Read by the SOSL server. RUN will cause the SOSL server, if started to run as long as it does not get a STOP signal from the database. Set it to STOP to stop the SOSL server. Set to WAIT if the server should not call any script apart the check for the run mode. Can be locally overwritten.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_DEFAULT_WAIT', '1', 'NUMBER', 'Determines the normal sleep time in seconds the sosl server has between calls if scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_NOJOB_WAIT', '120', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if no scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_PAUSE_WAIT', '3600', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if run mode is set to wait.')
  5  ;

1 row created.

SQL> COMMIT;

Commit complete.

SQL> @@../sosl_ddl/tables/sosl_script.sql
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_script
  2    ( script_id	    NUMBER(38, 0)  GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , script_name	    VARCHAR2(2000)					     NOT NULL
  4    , script_schema	    VARCHAR2(256)  DEFAULT 'SOSL'			     NOT NULL
  5    , created	    DATE	   DEFAULT SYSDATE			     NOT NULL
  6    , updated	    DATE	   DEFAULT SYSDATE			     NOT NULL
  7    , created_by	    VARCHAR2(256)  DEFAULT USER 			     NOT NULL
  8    , created_by_os	    VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
  9    , updated_by	    VARCHAR2(256)  DEFAULT USER 			     NOT NULL
 10    , updated_by_os	    VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 11    , script_description VARCHAR2(4000)
 12    )
 13  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_script IS 'Holds the script file names that should be executed by SOSL. Will use the alias scrt.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_id IS 'The generated unique id of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_name IS 'The name of the script file including full or relative path. Use relative path (relative to batch_base_path or repository location) to ensure running scripts from different machines.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_schema IS 'The schema the script should run in. Will cause an ALTER SESSION SET CURRENT_SCHEMA before executing the script.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.script_description IS 'Optional description of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_script
  2    ADD CONSTRAINT sosl_script_pk
  3    PRIMARY KEY (script_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_script_ins_trg
  2    BEFORE INSERT ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := SYSDATE;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_script_upd_trg
  2    BEFORE UPDATE ON sosl_script
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    :NEW.updated	   := SYSDATE;
 10    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12  END;
 13  /

Trigger created.

SQL> @@../sosl_ddl/tables/sosl_batch_group.sql
SQL> CREATE TABLE sosl_batch_group
  2    ( batch_group_id 	 NUMBER(38, 0)	GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , batch_group_name	 VARCHAR2(256)						  NOT NULL
  4    , batch_base_path	 VARCHAR2(2000)
  5    , batch_cfg_path 	 VARCHAR2(2000)
  6    , batch_tmp_path 	 VARCHAR2(2000)
  7    , batch_log_path 	 VARCHAR2(2000)
  8    , created		 DATE		DEFAULT SYSDATE 			  NOT NULL
  9    , updated		 DATE		DEFAULT SYSDATE 			  NOT NULL
 10    , created_by		 VARCHAR2(256)	DEFAULT USER				  NOT NULL
 11    , created_by_os		 VARCHAR2(256)	DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , updated_by		 VARCHAR2(256)	DEFAULT USER				  NOT NULL
 13    , updated_by_os		 VARCHAR2(256)	DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 14    , batch_group_description VARCHAR2(4000)
 15    )
 16  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_batch_group IS 'Holds defined batch groups that can be associated with scripts. Will use the alias sbat.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.batch_group_id IS 'The generated unique id of the batch group.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.batch_group_name IS 'The name of the batch group.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.batch_base_path IS 'Optional full path to use as base for scripts in this batch group. If given SOSL will switch to the given directory before executing scripts of this batch group. The script path must be relative to this base path.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.batch_cfg_path IS 'Optional relative path with delimiter at path end to the configuration file for this batch group. If no base path is given, configured sosl path is the default.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.batch_tmp_path IS 'Optional relative temporary path with delimiter at path end for this batch group. If no base path is given, configured sosl path is the default.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.batch_log_path IS 'Optional relative log file path with delimiter at path end for this batch group. If no base path is given, configured sosl path is the default.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.batch_group_description IS 'Optional description of the batch group.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_group.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_batch_group
  2    ADD CONSTRAINT sosl_batch_group_pk
  3    PRIMARY KEY (batch_group_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_batch_group_ins_trg
  2    BEFORE INSERT ON sosl_batch_group
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := SYSDATE;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_batch_group_upd_trg
  2    BEFORE UPDATE ON sosl_batch_group
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    :NEW.updated	   := SYSDATE;
 10    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12  END;
 13  /

Trigger created.

SQL> @@../sosl_ddl/tables/sosl_script_group.sql
SQL> CREATE TABLE sosl_script_group
  2    ( batch_id	   NUMBER(38, 0)   GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , batch_group_id    NUMBER(38, 0)					     NOT NULL
  4    , script_id	   NUMBER(38, 0)					     NOT NULL
  5    , order_nr	   NUMBER(4, 0)    DEFAULT 1				     NOT NULL
  6    , created	   DATE 	   DEFAULT SYSDATE			     NOT NULL
  7    , updated	   DATE 	   DEFAULT SYSDATE			     NOT NULL
  8    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
  9    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 11    , updated_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , batch_description VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> COMMENT ON TABLE sosl_script_group IS 'Relates scripts with a batch group. As long as order_nr is different, a script may be assigned multiple times to a batch group. Equal order_nr mean that those scripts can be executed in parallel. Will use the alias sgrp.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.batch_id IS 'Generated unique id for a batch group to script assignement.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.batch_group_id IS 'The unique batch group id for the script assignment. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.script_id IS 'The unique script id to assign to a batch group. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.order_nr IS 'Defines the order in which scripts are executed in a batch group. Scripts with the same order are executed in parallel. Maximum order is 9999. Batch group, script id and order must be unique.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.batch_description IS 'Optional description of this batch group script assignment.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_script_group.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_script_group
  2    ADD CONSTRAINT sosl_script_group_pk
  3    PRIMARY KEY (batch_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_script_group
  2    ADD CONSTRAINT sosl_script_group_chk_order_nr
  3    CHECK (order_nr > 0)
  4  ;

Table altered.

SQL> -- unique
SQL> ALTER TABLE sosl_script_group
  2    ADD CONSTRAINT sosl_script_group_uk
  3    UNIQUE (batch_group_id, script_id, order_nr)
  4    ENABLE
  5  ;

Table altered.

SQL> -- foreign keys on script_id and batch_group_id
SQL> ALTER TABLE sosl_script_group
  2    ADD CONSTRAINT sosl_script_group_script_id_fk
  3    FOREIGN KEY (script_id)
  4    REFERENCES sosl_script (script_id)
  5    ON DELETE CASCADE
  6  ;

Table altered.

SQL> ALTER TABLE sosl_script_group
  2    ADD CONSTRAINT sosl_script_group_batch_group_id_fk
  3    FOREIGN KEY (batch_group_id)
  4    REFERENCES sosl_batch_group (batch_group_id)
  5    ON DELETE CASCADE
  6  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_script_group_ins_trg
  2    BEFORE INSERT ON sosl_script_group
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := SYSDATE;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_script_group_upd_trg
  2    BEFORE UPDATE ON sosl_script_group
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    -- make sure ids are not changed
 10    :NEW.batch_group_id := :OLD.batch_group_id;
 11    :NEW.script_id	   := :OLD.script_id;
 12    -- update dates and user
 13    :NEW.updated	   := SYSDATE;
 14    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 15    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 16  END;
 17  /

Trigger created.

SQL> @@../sosl_ddl/tables/sosl_batch_plan.sql
SQL> CREATE TABLE sosl_batch_plan
  2    ( plan_id	   NUMBER(38, 0)   GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , plan_name	   VARCHAR2(256)					     NOT NULL
  4    , plan_active	   VARCHAR2(3)	   DEFAULT 'NO'
  5    , plan_accepted	   VARCHAR2(3)	   DEFAULT 'NO'
  6    , job_name	   VARCHAR2(128)
  7    , start_date	   TIMESTAMP
  8    , repeat_interval   VARCHAR2(4000)
  9    , end_date	   TIMESTAMP
 10    , created	   DATE 	   DEFAULT SYSDATE			     NOT NULL
 11    , updated	   DATE 	   DEFAULT SYSDATE			     NOT NULL
 12    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 13    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 14    , updated_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 15    , updated_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 16    , activated	   DATE
 17    , deactivated	   DATE
 18    , accepted	   DATE
 19    , denied 	   DATE
 20    , activated_by_os   VARCHAR2(256)
 21    , deactivated_by_os VARCHAR2(256)
 22    , accepted_by_os    VARCHAR2(256)
 23    , denied_by_os	   VARCHAR2(256)
 24    , plan_description  VARCHAR2(4000)
 25    )
 26  ;

Table created.

SQL> COMMENT ON TABLE sosl_batch_plan IS 'Defines the batch plan which consists of one or more batch groups. Will use the alias spla.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.plan_id IS 'The generated unique id that identifies the batch plan.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.plan_name IS 'The unique name of the batch plan.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.plan_active IS 'Defines if the plan is active. Accepts NO and YES. Not activated plans will not run but inform the log that an attempt was made to start the plan.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.plan_accepted IS 'Defines if the plan is accepted. Accepts NO and YES. Not accepted plans will not run but inform the log that an attempt was made to start the plan.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.job_name IS 'If the plan should be scheduled, provide an valid name for the job. Only normal uppercase characters A-Z, numbers and underscore allowed. Trigger will convert lower case to upper case, disable the job if it exists and create or update the job. If job name changes the old job is dropped. Equivalent to parameter in DBMS_SCHEDULER.CREATE_JOB.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.start_date IS 'The desired start date of the scheduled job. Equivalent to parameter in DBMS_SCHEDULER.CREATE_JOB.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.repeat_interval IS 'The repeat interval for the scheduler, if a scheduler name is defined. Equivalent to parameter in DBMS_SCHEDULER.CREATE_JOB.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.end_date IS 'The desired end date of the scheduled job or NULL. Equivalent to parameter in DBMS_SCHEDULER.CREATE_JOB.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.activated IS 'The date when plan_active was last set or updated to YES, managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.activated_by_os IS 'The OS user that last updated or set plan_active to YES, managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.deactivated IS 'The date when plan_active was last set or updated to NO, managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.deactivated_by_os IS 'The OS user that last updated or set plan_active to NO, managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.accepted IS 'The date when plan_accepted was last set or updated to YES, managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.accepted_by_os IS 'The OS user that last updated or set plan_accepted to YES, managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.denied IS 'The date when plan_accepted was last set or updated to NO, managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.denied_by_os IS 'The OS user that last updated or set plan_accepted to NO, managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_batch_plan.plan_description IS 'Optional plan description.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_batch_plan
  2    ADD CONSTRAINT sosl_batch_plan_pk
  3    PRIMARY KEY (plan_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- unique
SQL> ALTER TABLE sosl_batch_plan
  2    ADD CONSTRAINT sosl_batch_plan_uk
  3    UNIQUE (plan_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- check constraints
SQL> ALTER TABLE sosl_batch_plan
  2    ADD CONSTRAINT sosl_batch_plan_chk_active
  3    CHECK (plan_active IN ('YES', 'NO'))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_batch_plan
  2    ADD CONSTRAINT sosl_batch_plan_chk_accepted
  3    CHECK (plan_accepted IN ('YES', 'NO'))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_batch_plan
  2    ADD CONSTRAINT sosl_batch_plan_chk_job_name
  3    CHECK (REGEXP_INSTR(job_name, '^[A-Z0-9_]*$') > 0)
  4    ENABLE
  5  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_batch_plan_ins_upd_trg
  2    BEFORE INSERT OR UPDATE ON sosl_batch_plan
  3    FOR EACH ROW
  4  DECLARE
  5    l_has_job NUMBER;
  6  BEGIN
  7    IF INSERTING
  8    THEN
  9  	 :NEW.created	     := SYSDATE;
 10  	 :NEW.created_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11  	 :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12    END IF;
 13    :NEW.updated	   := SYSDATE;
 14    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 15    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 16    IF :NEW.plan_active = 'NO'
 17    THEN
 18  	 :NEW.deactivated	:= SYSDATE;
 19  	 :NEW.deactivated_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 20    ELSIF :NEW.plan_active = 'YES'
 21    THEN
 22  	 :NEW.activated       := SYSDATE;
 23  	 :NEW.activated_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 24    END IF;
 25    IF :NEW.plan_accepted = 'NO'
 26    THEN
 27  	 :NEW.denied	   := SYSDATE;
 28  	 :NEW.denied_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 29    ELSIF :NEW.plan_accepted = 'YES'
 30    THEN
 31  	 :NEW.accepted	     := SYSDATE;
 32  	 :NEW.accepted_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 33    END IF;
 34    -- if job_name IS NOT NULL then create or update the scheduler job
 35    IF INSERTING AND :NEW.job_name IS NOT NULL
 36    THEN
 37  	 BEGIN
 38  	   SELECT COUNT(*) INTO l_has_job FROM user_scheduler_jobs WHERE job_name = :NEW.job_name;
 39  	   -- check if already a job with this name exists
 40  	   IF l_has_job > 0
 41  	   THEN
 42  	     DBMS_SCHEDULER.DISABLE(name => :NEW.job_name, force => TRUE);
 43  	     -- update the job, set current plan id
 44  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
 45  					 , attribute => 'job_action'
 46  					 , value => 'BEGIN sosl.run_plan(' || TRIM(TO_CHAR(:NEW.plan_id)) || '); END;'
 47  					 )
 48  	     ;
 49  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
 50  					 , attribute => 'start_date'
 51  					 , value => :NEW.start_date
 52  					 )
 53  	     ;
 54  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
 55  					 , attribute => 'repeat_interval'
 56  					 , value => :NEW.repeat_interval
 57  					 )
 58  	     ;
 59  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
 60  					 , attribute => 'end_date'
 61  					 , value => :NEW.end_date
 62  					 )
 63  	     ;
 64  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
 65  					 , attribute => 'comments'
 66  					 , value => 'Run PLAN_ID ' || TRIM(TO_CHAR(:NEW.plan_id)) || ' plan info: ' || NVL(:NEW.plan_description, 'N/A')
 67  					 )
 68  	     ;
 69  	   ELSE
 70  	     -- create the job
 71  	     DBMS_SCHEDULER.CREATE_JOB( job_name => :NEW.job_name
 72  				      , job_type => 'PLSQL_BLOCK'
 73  				      , job_action => 'BEGIN sosl.run_plan(' || TRIM(TO_CHAR(:NEW.plan_id)) || '); END;'
 74  				      , number_of_arguments => 0
 75  				      , start_date => :NEW.start_date
 76  				      , repeat_interval => :NEW.repeat_interval
 77  				      , end_date => :NEW.end_date
 78  				      , enabled => FALSE
 79  				      , auto_drop => FALSE
 80  				      , comments => 'Run PLAN_ID ' || TRIM(TO_CHAR(:NEW.plan_id)) || ' plan info: ' || NVL(:NEW.plan_description, 'N/A')
 81  				      )
 82  	     ;
 83  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
 84  					 , attribute => 'store_output'
 85  					 , value => TRUE
 86  					 )
 87  	     ;
 88  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
 89  					 , attribute => 'logging_level'
 90  					 , value => DBMS_SCHEDULER.LOGGING_FULL
 91  					 )
 92  	     ;
 93  	   END IF;
 94  	 EXCEPTION
 95  	   WHEN OTHERS THEN
 96  	     RAISE_APPLICATION_ERROR(-20008, 'Could not create or update job ' || :NEW.job_name || ' ERROR: ' || SQLERRM);
 97  	 END;
 98    END IF;
 99    IF UPDATING AND :NEW.job_name IS NOT NULL
100    THEN
101  	 BEGIN
102  	   SELECT COUNT(*) INTO l_has_job FROM user_scheduler_jobs WHERE job_name = :OLD.job_name;
103  	   -- if name has changed, drop old job
104  	   IF	  :OLD.job_name IS NOT NULL
105  	      AND :OLD.job_name != :NEW.job_name
106  	      AND l_has_job > 0
107  	   THEN
108  	     DBMS_SCHEDULER.DISABLE(name => :OLD.job_name, force => TRUE);
109  	     DBMS_SCHEDULER.DROP_JOB(job_name => :OLD.job_name, force => TRUE);
110  	   END IF;
111  	 EXCEPTION
112  	   WHEN OTHERS THEN
113  	     RAISE_APPLICATION_ERROR(-20009, 'Could not drop old job ' || :OLD.job_name || ' ERROR: ' || SQLERRM);
114  	 END;
115  	 -- now handle existing job or create a new job
116  	 BEGIN
117  	   SELECT COUNT(*) INTO l_has_job FROM user_scheduler_jobs WHERE job_name = :NEW.job_name;
118  	   IF l_has_job > 0
119  	   THEN
120  	     -- disable and update job
121  	     DBMS_SCHEDULER.DISABLE(name => :NEW.job_name, force => TRUE);
122  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
123  					 , attribute => 'start_date'
124  					 , value => :NEW.start_date
125  					 )
126  	     ;
127  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
128  					 , attribute => 'repeat_interval'
129  					 , value => :NEW.repeat_interval
130  					 )
131  	     ;
132  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
133  					 , attribute => 'end_date'
134  					 , value => :NEW.end_date
135  					 )
136  	     ;
137  	   ELSE
138  	     -- create a new job with the new job name
139  	     DBMS_SCHEDULER.CREATE_JOB( job_name => :NEW.job_name
140  				      , job_type => 'PLSQL_BLOCK'
141  				      , job_action => 'BEGIN sosl.run_plan(' || TRIM(TO_CHAR(:NEW.plan_id)) || '); END;'
142  				      , number_of_arguments => 0
143  				      , start_date => :NEW.start_date
144  				      , repeat_interval => :NEW.repeat_interval
145  				      , end_date => :NEW.end_date
146  				      , enabled => FALSE
147  				      , auto_drop => FALSE
148  				      , comments => 'Run PLAN_ID ' || TRIM(TO_CHAR(:NEW.plan_id)) || ' plan info: ' || NVL(:NEW.plan_description, 'N/A')
149  				      )
150  	     ;
151  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
152  					 , attribute => 'store_output'
153  					 , value => TRUE
154  					 )
155  	     ;
156  	     DBMS_SCHEDULER.SET_ATTRIBUTE( name => :NEW.job_name
157  					 , attribute => 'logging_level'
158  					 , value => DBMS_SCHEDULER.LOGGING_FULL
159  					 )
160  	     ;
161  	   END IF;
162  	 EXCEPTION
163  	   WHEN OTHERS THEN
164  	     RAISE_APPLICATION_ERROR(-20008, 'Could not create or update job ' || :NEW.job_name || ' ERROR: ' || SQLERRM);
165  	 END;
166    END IF;
167  END;
168  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_batch_plan_del_trg
  2    BEFORE DELETE ON sosl_batch_plan
  3    FOR EACH ROW
  4  DECLARE
  5    l_has_job NUMBER;
  6  BEGIN
  7    -- drop jobs that exist, if plan is deleted
  8    BEGIN
  9  	 SELECT COUNT(*) INTO l_has_job FROM user_scheduler_jobs WHERE job_name = :OLD.job_name;
 10  	 -- drop old job
 11  	 IF l_has_job > 0
 12  	 THEN
 13  	   DBMS_SCHEDULER.DISABLE(name => :OLD.job_name, force => TRUE);
 14  	   DBMS_SCHEDULER.DROP_JOB(job_name => :OLD.job_name, force => TRUE);
 15  	 END IF;
 16    EXCEPTION
 17  	 WHEN OTHERS THEN
 18  	   RAISE_APPLICATION_ERROR(-20009, 'Could not drop old job ' || :OLD.job_name || ' ERROR: ' || SQLERRM);
 19    END;
 20  END;
 21  /

Trigger created.

SQL> @@../sosl_ddl/tables/sosl_group_plan.sql
SQL> CREATE TABLE sosl_group_plan
  2    ( group_plan_id		 NUMBER(38, 0)	 GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , plan_id		 NUMBER(38, 0)						   NOT NULL
  4    , batch_group_id 	 NUMBER(38, 0)						   NOT NULL
  5    , order_nr		 NUMBER(4, 0)	 DEFAULT 1				   NOT NULL
  6    , created		 DATE		 DEFAULT SYSDATE			   NOT NULL
  7    , updated		 DATE		 DEFAULT SYSDATE			   NOT NULL
  8    , created_by		 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
  9    , created_by_os		 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by		 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 11    , updated_by_os		 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , plan_group_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> COMMENT ON TABLE sosl_group_plan IS 'Relates batch plans with a batch group. As long as order_nr is different, a batch group may be assigned multiple times to a plan. Equal order_nr mean that those batch groups can be executed in parallel. Will use the alias splg.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.group_plan_id IS 'Generated unique id for a batch plan to group assignement.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.plan_id IS 'The unique script id to assign to a batch plan. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.batch_group_id IS 'The unique batch group id for the plan assignment. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.order_nr IS 'Defines the order in which batch groups are executed in a batch plan. Batch group with the same order are executed in parallel. Maximum order is 9999. Batch plan, batch group id and order must be unique.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.plan_group_description IS 'Optional description of this batch plan group assignment.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_group_plan.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_group_plan
  2    ADD CONSTRAINT sosl_group_plan_pk
  3    PRIMARY KEY (group_plan_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_group_plan
  2    ADD CONSTRAINT sosl_group_plan_chk_order_nr
  3    CHECK (order_nr > 0)
  4  ;

Table altered.

SQL> -- unique
SQL> ALTER TABLE sosl_group_plan
  2    ADD CONSTRAINT sosl_group_plan_uk
  3    UNIQUE (group_plan_id, batch_group_id, order_nr)
  4    ENABLE
  5  ;

Table altered.

SQL> -- foreign keys on script_id and batch_group_id
SQL> ALTER TABLE sosl_group_plan
  2    ADD CONSTRAINT sosl_group_plan_plan_id_fk
  3    FOREIGN KEY (plan_id)
  4    REFERENCES sosl_batch_plan (plan_id)
  5    ON DELETE CASCADE
  6  ;

Table altered.

SQL> ALTER TABLE sosl_group_plan
  2    ADD CONSTRAINT sosl_group_plan_batch_group_id_fk
  3    FOREIGN KEY (batch_group_id)
  4    REFERENCES sosl_batch_group (batch_group_id)
  5    ON DELETE CASCADE
  6  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_group_plan_ins_trg
  2    BEFORE INSERT ON sosl_group_plan
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := SYSDATE;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_group_plan_upd_trg
  2    BEFORE UPDATE ON sosl_group_plan
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    -- make sure ids are not changed
 10    :NEW.plan_id	   := :OLD.plan_id;
 11    :NEW.batch_group_id := :OLD.batch_group_id;
 12    -- update dates and user
 13    :NEW.updated	   := SYSDATE;
 14    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 15    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 16  END;
 17  /

Trigger created.

SQL> @@../sosl_ddl/tables/sosl_run_queues.sql
SQL> CREATE TABLE sosl_run_queues
  2    ( run_id 	 NUMBER(38, 0)	 GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , plan_id	 NUMBER(38, 0)
  4    , group_plan_id	 NUMBER(38, 0)
  5    , batch_group_id  NUMBER(38, 0)
  6    , batch_id	 NUMBER(38, 0)
  7    , script_id	 NUMBER(38, 0)
  8    , run_state	 NUMBER(1, 0)	 DEFAULT 0				   NOT NULL
  9    , created	 TIMESTAMP						   NOT NULL
 10    , waiting	 TIMESTAMP						   NOT NULL
 11    , enqueued	 TIMESTAMP
 12    , started	 TIMESTAMP
 13    , running	 TIMESTAMP
 14    , finished	 TIMESTAMP
 15    , created_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 16    , created_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , waiting_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 18    , waiting_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 19    , enqueued_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 20    , enqueued_by_os  VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 21    , started_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 22    , started_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 23    , running_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 24    , running_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 25    , finished_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 26    , finished_by_os  VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 27    )
 28  ;

Table created.

SQL> COMMENT ON TABLE sosl_run_queues IS 'This table hold old and new runs of batch plans and the execution run state of each script. Granularity is single script. This is not a message queue. Will use the alias srqu.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.run_id IS 'Generated unique id for a batch run script.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.plan_id IS 'The current unique plan id for the batch run. NULL possible if reference record deleted. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.plan_id IS 'The current unique group plan id for the batch run. NULL possible if reference record deleted. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.batch_group_id IS 'The current unique batch group id for the batch run. NULL possible if reference record deleted. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.batch_id IS 'The current unique batch id for the batch run. NULL possible if reference record deleted. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.script_id IS 'The current unique script id for the batch run. NULL possible if reference record deleted. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.run_state IS 'Holds the run state: 0 Waiting, 1 Enqueued, 2 Started, 3 Running, 4 Finished, -1 Error. To rerun a job, set run_state to 1. Script dependencies are not checked. Always 0 on insert, managed by trigger';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.created IS 'The date of record creation. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.waiting IS 'The last date of setting the script run state to waiting (0). On insert this is the default managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.enqueued IS 'The last date of setting the script run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.started IS 'The last date of setting the script run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.running IS 'The last date of setting the script run state to running (3).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.finished IS 'The last date of setting the script run state to finished or error (4, -1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.waiting_by IS 'Last DB user who set the record run state to waiting (0), managed by default and inser trigger, updates allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.waiting_by_os IS 'Last OS user who set the record run state to waiting (0), managed by default and insert trigger, updates allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.enqueued_by IS 'Last DB user who tried to set the record run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.enqueued_by_os IS 'Last OS user who tried to set the record run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.started_by IS 'Last DB user who tried to set the record run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.started_by_os IS 'Last OS user who tried to set the record run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.running_by IS 'Last DB user who tried to set the record run state to running (3).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.running_by_os IS 'Last OS user who tried to set the record run state to running (3)';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.finished_by IS 'Last DB user who tried to set the record run state to finished (4) or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queues.finished_by_os IS 'Last OS user who tried to set the record run state to finished (4) or -1 on errors.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_run_queues
  2    ADD CONSTRAINT sosl_run_queues_pk
  3    PRIMARY KEY (run_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_run_queues
  2    ADD CONSTRAINT sosl_run_queues_chk_run_state
  3    CHECK (run_state IN (-1, 0, 1, 2, 3, 4))
  4  ;

Table altered.

SQL> -- foreign keys on all ids referenced, will set record to NULL on DELETE
SQL> ALTER TABLE sosl_run_queues
  2    ADD CONSTRAINT sosl_run_queues_plan_id_fk
  3    FOREIGN KEY (plan_id)
  4    REFERENCES sosl_batch_plan (plan_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> ALTER TABLE sosl_run_queues
  2    ADD CONSTRAINT sosl_run_queues_group_plan_id_fk
  3    FOREIGN KEY (group_plan_id)
  4    REFERENCES sosl_group_plan (group_plan_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> ALTER TABLE sosl_run_queues
  2    ADD CONSTRAINT sosl_run_queues_batch_group_id_fk
  3    FOREIGN KEY (batch_group_id)
  4    REFERENCES sosl_batch_group (batch_group_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> ALTER TABLE sosl_run_queues
  2    ADD CONSTRAINT sosl_run_queues_batch_id_fk
  3    FOREIGN KEY (batch_id)
  4    REFERENCES sosl_script_group (batch_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> -- if script id is DELETED no rerun is possible
SQL> ALTER TABLE sosl_run_queues
  2    ADD CONSTRAINT sosl_run_queues_script_id_fk
  3    FOREIGN KEY (script_id)
  4    REFERENCES sosl_script (script_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_run_queues_ins_trg
  2    BEFORE INSERT ON sosl_run_queues
  3    FOR EACH ROW
  4  BEGIN
  5    -- on insert run state is always 0 waiting
  6    :NEW.run_state	   := 0;
  7    -- set basic timestamps
  8    :NEW.created	   := SYSTIMESTAMP;
  9    :NEW.waiting	   := SYSTIMESTAMP;
 10    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12    :NEW.waiting_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 13    :NEW.waiting_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 14  END;
 15  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_run_queues_upd_trg
  2    BEFORE UPDATE ON sosl_run_queues
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    -- update dates and user by run state
 10    CASE :NEW.run_state
 11  	 WHEN 0 THEN
 12  	   :NEW.waiting        := SYSTIMESTAMP;
 13  	   :NEW.waiting_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 14  	   :NEW.waiting_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 15  	 WHEN 1 THEN
 16  	   :NEW.enqueued       := SYSTIMESTAMP;
 17  	   :NEW.enqueued_by    := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 18  	   :NEW.enqueued_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 19  	 WHEN 2 THEN
 20  	   :NEW.started        := SYSTIMESTAMP;
 21  	   :NEW.started_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 22  	   :NEW.started_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 23  	 WHEN 3 THEN
 24  	   :NEW.running        := SYSTIMESTAMP;
 25  	   :NEW.running_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 26  	   :NEW.running_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 27  	 WHEN 4 THEN
 28  	   :NEW.finished       := SYSTIMESTAMP;
 29  	   :NEW.finished_by    := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 30  	   :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 31  	 ELSE
 32  	   -- any other state is an error state
 33  	   :NEW.finished       := SYSTIMESTAMP;
 34  	   :NEW.finished_by    := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 35  	   :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 36  	   :NEW.run_state      := -1;
 37    END CASE;
 38  END;
 39  /

Trigger created.

SQL> @@../sosl_ddl/tables/sosl_server_log.sql
SQL> -- requires login with the correct schema, either SOSL or your on schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_server_log
  2    ( exec_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP 		     NOT NULL
  3    , log_type	   VARCHAR2(30)    DEFAULT 'INFO'			     NOT NULL
  4    , message	   VARCHAR2(4000)					     NOT NULL
  5    , run_id 	   NUMBER(38, 0)
  6    , plan_id	   NUMBER(38, 0)
  7    , group_plan_id	   NUMBER(38, 0)
  8    , batch_group_id    NUMBER(38, 0)
  9    , batch_id	   NUMBER(38, 0)
 10    , script_id	   NUMBER(38, 0)
 11    , guid		   VARCHAR2(64)
 12    , sosl_identifier   VARCHAR2(256)
 13    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 14    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 15    , caller 	   VARCHAR2(256)
 16    , full_message	   CLOB
 17    )
 18    -- monthly partitions
 19    PARTITION BY RANGE (exec_timestamp)
 20    INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
 21    (PARTITION P_OLD
 22  	   VALUES LESS THAN (TO_TIMESTAMP('01-01-2024','DD-MM-YYYY'))
 23    )
 24  ;

Table created.

SQL> COMMENT ON TABLE sosl_server_log IS 'Holds the log events of the SOSL server CMD and interaction with the database. Update is not allowed. Will use the alias slog.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.exec_timestamp IS 'The timestamp of the event. Automatically set by trigger, no update allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_type IS 'The logging type, supports INFO, WARNING, ERROR, FATAL, SUCCESS. Mandatory.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.message IS 'The shortend log message. Mandatory. If only a CLOB is passed, the short message is build from the CLOB.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.full_message IS 'The full log message. For messages longer than 4000 bytes or char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.guid IS 'The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.sosl_identifier IS 'The exact identifier for SOSLERRORLOG if available. No foreign key as log entries may be deleted.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.run_id IS 'The associated run id if available.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.plan_id IS 'The associated batch plan id if available.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.group_plan_id IS 'The associated batch group plan id if available.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.batch_group_id IS 'The associated batch group id if available.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.batch_id IS 'The associated batch id if available.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.script_id IS 'The associated script id if available.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.caller IS 'Caller identification if available, to distinguish database processes from SOSL CMD server processes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by IS 'The logged in DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- no primary key, only index
SQL> CREATE INDEX sosl_server_log_idx
  2    ON sosl_server_log (exec_timestamp)
  3  ;

Index created.

SQL> -- constraints
SQL> ALTER TABLE sosl_server_log
  2    ADD CONSTRAINT sosl_server_log_chk_type
  3    CHECK (log_type IN ('INFO', 'WARNING', 'ERROR', 'FATAL', 'SUCCESS'))
  4  ;

Table altered.

SQL> -- foreign keys on batch_id, if not NULL
SQL> ALTER TABLE sosl_server_log
  2    ADD CONSTRAINT sosl_server_log_batch_id_fk
  3    FOREIGN KEY (batch_id)
  4    REFERENCES sosl_script_group (batch_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> ALTER TABLE sosl_server_log
  2    ADD CONSTRAINT sosl_server_log_plan_id_fk
  3    FOREIGN KEY (plan_id)
  4    REFERENCES sosl_batch_plan (plan_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> -- trigger
SQL> CREATE OR REPLACE TRIGGER sosl_server_log_ins_trg
  2    BEFORE INSERT ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.exec_timestamp := SYSTIMESTAMP;
  6    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  7    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  8    IF (:NEW.message IS NULL)
  9    THEN
 10  	 IF :NEW.full_message IS NOT NULL
 11  	 THEN
 12  	   IF LENGTH(TRIM(:NEW.full_message)) > 4000
 13  	   THEN
 14  	     :NEW.message := TO_CHAR(SUBSTR(TRIM(:NEW.full_message), 1, 3996)) || ' ...';
 15  	   ELSE
 16  	     :NEW.message := TO_CHAR(TRIM(:NEW.full_message));
 17  	   END IF;
 18  	 ELSE
 19  	   RAISE_APPLICATION_ERROR(-20003, 'Full message must be given, if message is NULL.');
 20  	 END IF;
 21    END IF;
 22    -- if a run id is provided, get the related ids
 23    IF :NEW.run_id IS NOT NULL
 24    THEN
 25  	 SELECT plan_id
 26  	      , group_plan_id
 27  	      , batch_group_id
 28  	      , batch_id
 29  	      , script_id
 30  	   INTO :NEW.plan_id
 31  	      , :NEW.group_plan_id
 32  	      , :NEW.batch_group_id
 33  	      , :NEW.batch_id
 34  	      , :NEW.script_id
 35  	   FROM sosl_run_queues
 36  	  WHERE run_id = :NEW.run_id
 37  	 ;
 38    END IF;
 39  END;
 40  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_upd_trg
  2    BEFORE UPDATE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20004, 'No updates allowed on a log table.');
  6  END;
  7  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_del_trg
  2    BEFORE DELETE ON sosl_server_log
  3    FOR EACH ROW
  4  BEGIN
  5    RAISE_APPLICATION_ERROR(-20005, 'You should not delete records from a log table, even if technically possible.');
  6  END;
  7  /

Trigger created.

SQL> @@../sosl_ddl/views/sosl_plan_view.sql
SQL> CREATE OR REPLACE VIEW sosl_plan_view
  2  AS
  3    SELECT spla.plan_name
  4  	    , spla.plan_active
  5  	    , spla.plan_accepted
  6  	    , scrt.script_name
  7  	    , sbat.batch_base_path
  8  	    , scrt.script_description
  9  	    , splg.order_nr AS group_order_nr
 10  	    , sgrp.order_nr AS script_order_nr
 11  	    , splg.plan_group_description
 12  	    , sgrp.batch_description
 13  	    , sbat.batch_group_description
 14  	    , spla.plan_id
 15  	    , splg.batch_group_id
 16  	    , sgrp.script_id
 17  	    , splg.group_plan_id
 18  	    , sgrp.batch_id
 19  	 FROM sosl_batch_plan spla
 20  	 LEFT OUTER JOIN sosl_group_plan splg
 21  	   ON spla.plan_id = splg.plan_id
 22  	 LEFT OUTER JOIN sosl_script_group sgrp
 23  	   ON splg.batch_group_id = sgrp.batch_group_id
 24  	 LEFT OUTER JOIN sosl_batch_group sbat
 25  	   ON splg.batch_group_id = sbat.batch_group_id
 26  	 LEFT OUTER JOIN sosl_script scrt
 27  	   ON sgrp.script_id = scrt.script_id
 28  	ORDER BY spla.plan_id
 29  	       , splg.batch_group_id
 30  	       , splg.order_nr
 31  	       , sgrp.order_nr
 32  ;

View created.

SQL> @@../sosl_sql/util/log_silent.sql
SQL> SET ECHO OFF
SUCCESS - no errors found during setup          0
