SQL> -- types
SQL> @@../sosl_ddl/types/sosl_payload.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- basic api exchange type, only header, no member function
SQL> CREATE OR REPLACE TYPE sosl_payload
  2    AS OBJECT
  3  	 /* This type is used to exchange information on executor, external script id and the script filename including
  4  	 * relative or full path which must exist on the server SOSL is running.
  5  	 * It does not provide any member functions only fields to fill. Object initialization basic example:
  6  	 * DECLARE
  7  	 *   -- to access the type from other schemas, do not forget to qualify it with the SOSL schema used
  8  	 *   l_sosl_payload SOSL.SOSL_PAYLOAD;
  9  	 * BEGIN
 10  	 *   l_sosl_payload := sosl_payload(1, 'My script ID', '../../mydir/scriptfile.sql');
 11  	 * END;
 12  	 */
 13  	 ( executor_id	  NUMBER(38, 0)  -- the executor_id from SOSL_EXECUTOR_DEFINITION responsible for the script
 14  	 , ext_script_id  VARCHAR2(4000) -- the external script id managed by the executor
 15  	 , script_file	  VARCHAR2(4000) -- the script file name with full or relative path on the server where SOSL is running locally
 16  	 )
 17  ;
 18  /

Type created.

SQL> GRANT EXECUTE ON sosl_payload TO sosl_executor;

Grant succeeded.

SQL> -- SQLPlus error logging table
SQL> @@../sosl_ddl/tables/soslerrorlog.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, equals SPERRORLOG
SQL> CREATE TABLE soslerrorlog
  2    ( username    VARCHAR2(256)
  3    , timestamp   TIMESTAMP
  4  	 -- older versions than Oracle 23 use VARCHAR2(1024)
  5    , script      CLOB	   -- VARCHAR2(1024)
  6    , identifier  VARCHAR2(256)
  7    , message     CLOB
  8    , statement   CLOB
  9    )
 10  ;

Table created.

SQL> COMMENT ON TABLE soslerrorlog IS 'Userdefined table for SQLPlus error logging';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.username IS 'Oracle account name';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.timestamp IS 'Time when the error occurred';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.script IS 'Name of the originating script if applicable';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.identifier IS 'User defined identifier string';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.message IS 'ORA, PLA or SP2 error message. No feed back messages are included. For example, "PL/SQL Block Created" is not recorded.';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.statement IS 'The statement causing the error';

Comment created.

SQL> -- Grants, inherited by others, no guest and user access on tables
SQL> GRANT SELECT ON soslerrorlog TO sosl_reviewer;

Grant succeeded.

SQL> GRANT DELETE ON soslerrorlog TO sosl_admin;

Grant succeeded.

SQL> -- logging table
SQL> @@../sosl_ddl/tables/sosl_server_log.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_server_log
  2    ( exec_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP 		     NOT NULL
  3  	 -- due to Oracle limitations we must use trigger not a package variable, trigger takes care
  4  	 -- to assign a default INFO log type if getting sosl_sys.NA_TYPE
  5    , log_type	   VARCHAR2(30)    DEFAULT 'n/a'			     NOT NULL
  6    , log_category	   VARCHAR2(256)   DEFAULT 'n/a'			     NOT NULL
  7    , message	   VARCHAR2(4000)					     NOT NULL
  8    , run_id 	   NUMBER(38, 0)
  9    , executor_id	   NUMBER(38, 0)
 10    , guid		   VARCHAR2(64)
 11    , sosl_identifier   VARCHAR2(256)
 12    , caller 	   VARCHAR2(256)
 13    , ext_script_id	   VARCHAR2(4000)
 14    , script_file	   VARCHAR2(4000)
 15    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 16    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , full_message	   CLOB
 18    )
 19    -- monthly partitions
 20    PARTITION BY RANGE (exec_timestamp)
 21    INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
 22    (PARTITION P_OLD
 23  	   VALUES LESS THAN (TO_TIMESTAMP('01-01-2024','DD-MM-YYYY'))
 24    )
 25  ;

Table created.

SQL> COMMENT ON TABLE sosl_server_log IS 'Holds the log events of the SOSL server CMD and interaction with the database as well as database events. Update is not allowed. Will use the alias slog.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.exec_timestamp IS 'The timestamp of the event. Automatically set by trigger, no set allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_type IS 'The logging type, supports currently INFO, WARNING, ERROR, FATAL, SUCCESS. Mandatory. Defined in package SOSL_SYS.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_category IS 'The log writer may provide an short log category description.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.message IS 'The shortend log message. Mandatory. If only a CLOB is passed, the short message is build from the CLOB. Categories too long will be cutted.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.full_message IS 'The full log message. For messages longer than 4000 bytes or char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.guid IS 'The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.sosl_identifier IS 'The exact identifier for SOSLERRORLOG if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.run_id IS 'The associated run id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.executor_id IS 'The associated executor id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.script_file IS 'The script filename as delivered, including relative or absolute path.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.ext_script_id IS 'The (external) script id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.caller IS 'Caller identification if available, to distinguish database processes from SOSL CMD server processes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by IS 'The logged in DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- no primary key, only index
SQL> CREATE INDEX sosl_server_log_idx
  2    ON sosl_server_log (exec_timestamp, log_type, log_category)
  3  ;

Index created.

SQL> -- no constraints, as Oracle does not allow package functions in CHECK conditions
SQL> 
SQL> -- Grants, inherited by others, no guest and user access on tables
SQL> GRANT SELECT ON sosl_server_log TO sosl_reviewer;

Grant succeeded.

SQL> GRANT DELETE ON sosl_server_log TO sosl_admin;

Grant succeeded.

SQL> -- SOSL objects basic objects
SQL> @@../sosl_ddl/tables/sosl_config.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_config
  2    ( config_name	     VARCHAR2(128)					       NOT NULL
  3    , config_value	     VARCHAR2(4000)					       NOT NULL
  4    , config_max_length   NUMBER	     DEFAULT -1 			       NOT NULL
  5    , config_type	     VARCHAR2(6)     DEFAULT 'CHAR'			       NOT NULL
  6    , created	     DATE	     DEFAULT SYSDATE			       NOT NULL
  7    , updated	     DATE	     DEFAULT SYSDATE			       NOT NULL
  8    , created_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
  9    , created_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
 11    , updated_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , config_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_config IS 'Holds the configuration used by SOSL. Will use the alias scfg.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_name IS 'The unique case sensitive name of the SOSL configuration object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_value IS 'The configuration value always as VARCHAR2. Type handling and conversion must be done by the caller.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_type IS 'Defines how the config value has to be interpreted. Currently supports CHAR and NUMBER.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_max_length IS 'Defines a maximum length for CHAR type config values if set to a number > 0. Default is -1, do not not check length.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_description IS 'Optional description of the SOSL config object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- primary key
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_pk
  3    PRIMARY KEY (config_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_type
  3    CHECK (config_type IN ('CHAR', 'NUMBER'))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_max_length
  3    CHECK (config_max_length = -1 OR config_max_length > 0)
  4  ;

Table altered.

SQL> -- Grants, inherited by others, no guest and user access on tables
SQL> GRANT SELECT ON sosl_config TO sosl_reviewer;

Grant succeeded.

SQL> GRANT UPDATE ON sosl_config TO sosl_admin;

Grant succeeded.

SQL> @@../sosl_ddl/tables/sosl_executor_definition.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_executor_definition
  2    ( executor_id	       NUMBER(38, 0)   GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , executor_name	       VARCHAR2(256)						 NOT NULL
  4    , db_user	       VARCHAR2(128)						 NOT NULL
  5    , function_owner        VARCHAR2(128)						 NOT NULL
  6    , fn_has_scripts        VARCHAR2(520)						 NOT NULL
  7    , fn_get_next_script    VARCHAR2(520)						 NOT NULL
  8    , fn_set_script_status  VARCHAR2(520)						 NOT NULL
  9    , cfg_file	       VARCHAR2(4000)						 NOT NULL
 10    , use_mail	       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 11    , fn_send_db_mail       VARCHAR2(520)   DEFAULT 'yourpackage.yourfunction'	 NOT NULL
 12    , executor_active       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 13    , executor_reviewed     NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 14    , created	       DATE	       DEFAULT SYSDATE				 NOT NULL
 15    , updated	       DATE	       DEFAULT SYSDATE				 NOT NULL
 16    , created_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 17    , created_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 18    , updated_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 19    , updated_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 20    , script_schema	       VARCHAR2(128)   DEFAULT NULL
 21    , executor_description  VARCHAR2(4000)
 22    )
 23  ;

Table created.

SQL> COMMENT ON TABLE sosl_executor_definition IS 'Defines the executors registered with SOSL. To improve security you may activate AUDIT on this table. Will use the alias sed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_id IS 'The generated unique id that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_name IS 'The unique name that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.db_user IS 'The login name of the database user must match cfg_file login and be USER after login. No mixed case support, converted to upper case. Must exist and have the necessary rights to execute the queued scripts. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.function_owner IS 'The owner user name of the API functions, refers to the schema where the functions are defined. No mixed case support, converted to upper case. Can differ from the database user that executes SOSL. All API functions must have the same owner for one executor. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.fn_has_scripts IS 'The name of the interface function to use by HAS_SCRIPTS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to role SOSL_EXECUTOR. It shall not require parameters and return the amount of waiting scripts as NUMBER or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.fn_get_next_script IS 'The name of the interface function to use by GET_NEXT_SCRIPT wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to role SOSL_EXECUTOR. It shall not require parameters and return the script id, executor id and script file name as type SOSL_PAYLOAD. It should manage the given script id to ensure that scripts are not run twice.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.fn_set_script_status IS 'The name of the interface function to use by SET_SCRIPT_STATUS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to role SOSL_EXECUTOR. It shall require the parameters P_RUN_ID IN NUMBER, P_STATUS IN NUMBER and return 0 or -1 on errors. Details can be fetched from SOSL_RUN_QUEUE. P_STATUS reflects the intended state as defined in SOSL_CONSTANTS RUN% constants. The effective state may differ from the intended state if transition has failed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.fn_send_db_mail IS 'The name of the interface function to use by SEND_DB_MAIL wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to role SOSL_EXECUTOR. It shall require the parameters P_RUN_ID IN NUMBER, P_STATUS IN NUMBER and return 0 or -1 on errors. P_STATUS reflects the intended state as defined in SOSL_CONSTANTS RUN% constants. The effective state may differ from the intended state if transition has failed. Message building and sending is up to the defined function. If mail is activated this function is called on every state change.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.cfg_file IS 'The filename with absolute or relative path to the login config file for this executor. File and path must exist on the CMD server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.use_mail IS 'Defines if mail should be provided by SOSL. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). You may also integrate mail behind the SOSL scenes by integrating it into your interface functions.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_active IS 'Defines if the executor is active. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_reviewed IS 'Defines if the executor is reviewed, accepted and ready to be used. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.script_schema IS 'The (optional) schema the script should run in. If set will cause an ALTER SESSION SET CURRENT_SCHEMA before executing the script otherwise db user schema is used. DB user must have rights for this schema if set. If acting on own schema or scripts do ALTER SESSION by themselves, you should leave it NULL.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_description IS 'Optional executor description.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_pk
  3    PRIMARY KEY (executor_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- unique constraint
SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_uk
  3    UNIQUE (executor_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- check constraints
SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_chk_use_mail
  3    CHECK (use_mail IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_chk_active
  3    CHECK (executor_active IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_chk_reviewed
  3    CHECK (executor_reviewed IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> GRANT SELECT ON sosl_executor_definition TO sosl_reviewer;

Grant succeeded.

SQL> GRANT UPDATE ON sosl_executor_definition TO sosl_reviewer;

Grant succeeded.

SQL> GRANT INSERT ON sosl_executor_definition TO sosl_executor;

Grant succeeded.

SQL> GRANT DELETE ON sosl_executor_definition TO sosl_admin;

Grant succeeded.

SQL> @@../sosl_ddl/tables/sosl_run_queue.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE TABLE sosl_run_queue
  2    ( run_id 	 NUMBER(38, 0)	 GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , run_state	 NUMBER(1, 0)	 DEFAULT 0				   NOT NULL
  4    , executor_id	 NUMBER(38, 0)						   NOT NULL
  5    , ext_script_id	 VARCHAR2(4000) 					   NOT NULL
  6    , script_file	 VARCHAR2(4000) 					   NOT NULL
  7    , script_guid	 VARCHAR2(64)	 DEFAULT 'n/a'				   NOT NULL
  8    , sosl_identifier VARCHAR2(256)	 DEFAULT 'n/a'				   NOT NULL
  9    , created	 TIMESTAMP	 DEFAULT SYSTIMESTAMP			   NOT NULL
 10    , waiting	 TIMESTAMP
 11    , enqueued	 TIMESTAMP
 12    , started	 TIMESTAMP
 13    , running_since	 TIMESTAMP
 14    , finished	 TIMESTAMP
 15    , created_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 16    , created_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , waiting_by	 VARCHAR2(256)	 DEFAULT USER
 18    , waiting_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 19    , enqueued_by	 VARCHAR2(256)	 DEFAULT USER
 20    , enqueued_by_os  VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 21    , started_by	 VARCHAR2(256)	 DEFAULT USER
 22    , started_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 23    , running_by	 VARCHAR2(256)	 DEFAULT USER
 24    , running_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 25    , finished_by	 VARCHAR2(256)	 DEFAULT USER
 26    , finished_by_os  VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 27    )
 28  ;

Table created.

SQL> COMMENT ON TABLE sosl_run_queue IS 'This table hold old and new runs of batch plans and the execution run state of each script. Granularity is single script. This is not a message queue. Will use the alias srq.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.run_id IS 'Generated unique id for a batch run script.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.run_state IS 'Holds the run state: 0 Waiting, 1 Enqueued, 2 Started, 3 Running, 4 Finished, -1 Error. To rerun a job, set run_state to 1. Will not be accepted if executor is not active and reviewed. Script dependencies are not checked. Can only be 0 or -1 on insert, managed by trigger';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.executor_id IS 'The valid executor id as returned from API (NUMBER). No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.ext_script_id IS 'The (external) identifier for the current script as returned from API (VARCHAR2). No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.script_file IS 'The script file name including (relative) path from API (VARCHAR2). No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.script_guid IS 'The unique id of the SOSL server associated with the script execution. This is a generic reference to SOSLERRORLOG.IDENTIFIER and local server logs. Set by SOSL server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.sosl_identifier IS 'The unique SOSL identifier id of the SOSL server associated with the script execution. This is a unique reference to SOSLERRORLOG.IDENTIFIER and local server logs. Set by SOSL server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.created IS 'The date of record creation. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.waiting IS 'The last date of setting the script run state to waiting (0). On insert this is the default managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.enqueued IS 'The last date of setting the script run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.started IS 'The last date of setting the script run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.running_since IS 'The last date of setting the script run state to running (3).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.finished IS 'The last date of setting the script run state to finished or error (4, -1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.waiting_by IS 'Last DB user who set the record run state to waiting (0), managed by default and inser trigger, updates allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.waiting_by_os IS 'Last OS user who set the record run state to waiting (0), managed by default and insert trigger, updates allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.enqueued_by IS 'Last DB user who tried to set the record run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.enqueued_by_os IS 'Last OS user who tried to set the record run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.started_by IS 'Last DB user who tried to set the record run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.started_by_os IS 'Last OS user who tried to set the record run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.running_by IS 'Last DB user who tried to set the record run state to running (3).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.running_by_os IS 'Last OS user who tried to set the record run state to running (3)';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.finished_by IS 'Last DB user who tried to set the record run state to finished (4) or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.finished_by_os IS 'Last OS user who tried to set the record run state to finished (4) or -1 on errors.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_run_queue
  2    ADD CONSTRAINT sosl_run_queue_pk
  3    PRIMARY KEY (run_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_run_queue
  2    ADD CONSTRAINT sosl_run_queue_chk_run_state
  3    CHECK (run_state IN (-1, 0, 1, 2, 3, 4))
  4  ;

Table altered.

SQL> -- foreign keys on all ids referenced, will set record to NULL on DELETE
SQL> ALTER TABLE sosl_run_queue
  2    ADD CONSTRAINT sosl_run_queue_executor_id_fk
  3    FOREIGN KEY (executor_id)
  4    REFERENCES sosl_executor_definition (executor_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> GRANT SELECT ON sosl_run_queue TO sosl_reviewer;

Grant succeeded.

SQL> GRANT DELETE ON sosl_run_queue TO sosl_admin;

Grant succeeded.

SQL> -- internal interface objects using the API
SQL> @@../sosl_ddl/tables/sosl_if_script.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_if_script
  2    ( script_id	     NUMBER(38, 0)  GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , script_name	     VARCHAR2(2000)					      NOT NULL
  4    , run_state	     NUMBER(1, 0)   DEFAULT 0				      NOT NULL
  5    , run_order	     NUMBER(38, 0)  DEFAULT 1				      NOT NULL
  6    , script_active	     NUMBER(1, 0)   DEFAULT 0				      NOT NULL
  7    , created	     DATE	    DEFAULT SYSDATE			      NOT NULL
  8    , created_by	     VARCHAR2(256)  DEFAULT USER			      NOT NULL
  9    , created_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , executor_id	     NUMBER(38, 0)
 11    , updated	     DATE
 12    , updated_by	     VARCHAR2(256)  DEFAULT USER
 13    , updated_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 14    , script_description  VARCHAR2(4000)
 15    )
 16  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_if_script IS 'Internal interface table that holds the script file names that should be executed by SOSL. Used for tests and simple batch script setups. No logic control in triggers apart from insert and update dates and users. Will use the alias sis.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_id IS 'The generated unique id of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.executor_id IS 'The optional related executor id of the script file. If defined, must match an existing executor. If not defined, script is ignored.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_name IS 'The name of the script file including full or relative path. Use relative path (relative to batch_base_path or repository location) to ensure running scripts from different machines.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.run_order IS 'The order in which the script file should be executed. Same number means in parallel. Higher order numbers wait for scripts with lower order numbers to complete. Must be greater than 0.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.run_state IS 'Holds the run state: 0 Waiting, 1 Enqueued, 2 Started, 3 Running, 4 Finished, -1 Error. To rerun a job, set run_state to 1. Will not be accepted if executor is not active and reviewed. Script dependencies are not checked. Can only be 0 or -1 on insert, managed by trigger';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_active IS 'Defines active state of script. Only active scripts are handled. 0 is inactive, 1 is active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_description IS 'Optional description of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_pk
  3    PRIMARY KEY (script_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_chk_run_state
  3    CHECK (run_state IN (-1, 0, 1, 2, 3, 4))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_chk_active
  3    CHECK (script_active IN (0, 1))
  4  ;

Table altered.

SQL> -- foreign key
SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_fk
  3    FOREIGN KEY (executor_id)
  4    REFERENCES sosl_executor_definition (executor_id)
  5    ON DELETE SET NULL
  6    ENABLE
  7  ;

Table altered.

SQL> GRANT SELECT ON sosl_if_script TO sosl_reviewer;

Grant succeeded.

SQL> GRANT INSERT ON sosl_if_script TO sosl_executor;

Grant succeeded.

SQL> GRANT DELETE ON sosl_if_script TO sosl_admin;

Grant succeeded.

SQL> -- create the views for the granted SYS views used in package SOSL_UTIL
SQL> @@../sosl_ddl/views/sosl_role_privs_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE VIEW sosl_role_privs_v
  2  AS
  3    SELECT grantee
  4  	    , granted_role
  5  	    , admin_option
  6  	    , delegate_option
  7  	    , default_role
  8  	    , common
  9  	    , inherited
 10  	 FROM dba_role_privs
 11  	      -- exclude SYS if not function owner
 12  	WHERE (   grantee  != 'SYS'
 13  	       OR 'SYS'    IN (SELECT function_owner FROM sosl_executor_definition WHERE executor_active = 1 AND executor_reviewed = 1)
 14  	      )
 15  	      -- limit to SOSL roles, schema and function owners
 16  	  AND (   grantee LIKE 'SOSL\_%' ESCAPE '\'
 17  	       OR grantee    = (SELECT sosl_schema FROM sosl_install_v)
 18  	       OR grantee   IN (SELECT function_owner FROM sosl_executor_definition WHERE executor_active = 1 AND executor_reviewed = 1)
 19  	      )
 20  	ORDER BY grantee
 21  ;

View created.

SQL> GRANT SELECT ON sosl_role_privs_v TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_sessions_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- short version of GV$SESSION for SOSL user, machine/terminal and function owners
SQL> -- including a basic join on GV$SQL
SQL> CREATE OR REPLACE VIEW sosl_sessions_v
  2  AS
  3    SELECT gsn.schemaname
  4  	    , gsn.username
  5  	    , gsn.osuser
  6  	    , gsn.logon_time
  7  	    , gsn.sid
  8  	    , gsn.serial#
  9  	    , gsn.status
 10  	    , gsn.blocking_session_status
 11  	    , gsn.state AS wait_status
 12  	    , CASE
 13  		WHEN gsq.sql_text IS NOT NULL
 14  		       -- reduce formatting space chars
 15  		THEN SUBSTR(REGEXP_REPLACE(gsq.sql_text, '\s{2,}', ' '), 1, 80) || '...'
 16  		ELSE NULL
 17  	      END AS short_sql
 18  	    , gsn.sql_exec_start
 19  	    , gsn.event
 20  	    , gsn.machine
 21  	    , gsn.module
 22  	    , gsn.action
 23  	    , gsn.terminal
 24  	    , gsn.program
 25  	    , gsn.server
 26  	    , gsn.wait_time
 27  	    , gsn.seconds_in_wait
 28  	    , gsn.process
 29  	    , gsn.sql_id
 30  	    , gsn.inst_id
 31  	    , gsn.con_id
 32  	    , gsn.action_hash
 33  	    , gsn.module_hash
 34  	    , gsn.lockwait
 35  	    , gsn.blocking_instance
 36  	    , gsn.blocking_session
 37  	    , gsn.final_blocking_session_status
 38  	    , gsn.final_blocking_instance
 39  	    , gsn.final_blocking_session
 40  	    , gsn.wait_class_id
 41  	    , gsn.wait_class#
 42  	    , gsn.wait_class
 43  	    , gsn.wait_time_micro
 44  	    , gsn.time_remaining_micro
 45  	    , gsn.total_time_waited_micro
 46  	    , gsn.heur_time_waited_micro
 47  	    , gsn.time_since_last_wait_micro
 48  	 FROM gv$session gsn
 49  	 LEFT OUTER JOIN gv$sql gsq
 50  	   ON gsn.sql_id	     = gsq.sql_id
 51  	  AND gsn.inst_id	     = gsq.inst_id
 52  	  AND gsn.con_id	     = gsq.con_id
 53  	  AND gsn.module_hash	     = gsq.module_hash
 54  	  AND gsn.action_hash	     = gsq.action_hash
 55  	  AND NVL(gsn.module, 'N/A') = NVL(gsq.module, 'N/A')
 56  	  AND NVL(gsn.action, 'N/A') = NVL(gsq.action, 'N/A')
 57  	WHERE gsn.username IS NOT NULL -- exclude oracle system
 58  	  AND (   gsn.username		= (SELECT sosl_schema FROM sosl_install_v)
 59  	       OR gsn.schemaname	= (SELECT sosl_schema FROM sosl_install_v)
 60  	       OR UPPER(gsn.terminal)	= (SELECT UPPER(sosl_machine) FROM sosl_install_v)
 61  	       OR gsn.username	       IN (SELECT function_owner FROM sosl_executor_definition WHERE executor_active = 1 AND executor_reviewed = 1)
 62  	       OR gsn.schemaname       IN (SELECT function_owner FROM sosl_executor_definition WHERE executor_active = 1 AND executor_reviewed = 1)
 63  	       OR UPPER(gsn.machine) LIKE (SELECT '%' || UPPER(sosl_machine) || '%' FROM sosl_install_v)
 64  	      )
 65  ;

View created.

SQL> GRANT SELECT ON sosl_sessions_v TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_sessions_admin_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Admin content providing full GV$SESSION content
SQL> CREATE OR REPLACE VIEW sosl_sessions_admin_v
  2  AS
  3    SELECT inst_id
  4  	    , saddr
  5  	    , sid
  6  	    , serial#
  7  	    , audsid
  8  	    , paddr
  9  	    , user#
 10  	    , username
 11  	    , command
 12  	    , ownerid
 13  	    , taddr
 14  	    , lockwait
 15  	    , status
 16  	    , server
 17  	    , schema#
 18  	    , schemaname
 19  	    , osuser
 20  	    , process
 21  	    , machine
 22  	    , port
 23  	    , terminal
 24  	    , program
 25  	    , type
 26  	    , sql_address
 27  	    , sql_hash_value
 28  	    , sql_id
 29  	    , sql_child_number
 30  	    , sql_exec_start
 31  	    , sql_exec_id
 32  	    , prev_sql_addr
 33  	    , prev_hash_value
 34  	    , prev_sql_id
 35  	    , prev_child_number
 36  	    , prev_exec_start
 37  	    , prev_exec_id
 38  	    , plsql_entry_object_id
 39  	    , plsql_entry_subprogram_id
 40  	    , plsql_object_id
 41  	    , plsql_subprogram_id
 42  	    , module
 43  	    , module_hash
 44  	    , action
 45  	    , action_hash
 46  	    , client_info
 47  	    , fixed_table_sequence
 48  	    , row_wait_obj#
 49  	    , row_wait_file#
 50  	    , row_wait_block#
 51  	    , row_wait_row#
 52  	    , top_level_call#
 53  	    , logon_time
 54  	    , last_call_et
 55  	    , pdml_enabled
 56  	    , failover_type
 57  	    , failover_method
 58  	    , failed_over
 59  	    , resource_consumer_group
 60  	    , pdml_status
 61  	    , pddl_status
 62  	    , pq_status
 63  	    , current_queue_duration
 64  	    , client_identifier
 65  	    , blocking_session_status
 66  	    , blocking_instance
 67  	    , blocking_session
 68  	    , final_blocking_session_status
 69  	    , final_blocking_instance
 70  	    , final_blocking_session
 71  	    , seq#
 72  	    , event#
 73  	    , event
 74  	    , p1text
 75  	    , p1
 76  	    , p1raw
 77  	    , p2text
 78  	    , p2
 79  	    , p2raw
 80  	    , p3text
 81  	    , p3
 82  	    , p3raw
 83  	    , wait_class_id
 84  	    , wait_class#
 85  	    , wait_class
 86  	    , wait_time
 87  	    , seconds_in_wait
 88  	    , state
 89  	    , wait_time_micro
 90  	    , time_remaining_micro
 91  	    , total_time_waited_micro
 92  	    , heur_time_waited_micro
 93  	    , time_since_last_wait_micro
 94  	    , service_name
 95  	    , sql_trace
 96  	    , sql_trace_waits
 97  	    , sql_trace_binds
 98  	    , sql_trace_plan_stats
 99  	    , session_edition_id
100  	    , creator_addr
101  	    , creator_serial#
102  	    , ecid
103  	    , sql_translation_profile_id
104  	    , pga_tunable_mem
105  	    , shard_ddl_status
106  	    , con_id
107  	    , external_name
108  	    , plsql_debugger_connected
109  	    , drain_status
110  	    , drain_deadline
111  	    , drain_origin
112  	 FROM gv$session gses
113  ;

View created.

SQL> GRANT SELECT ON sosl_sessions_admin_v TO sosl_admin;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_session_sql_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Short version of GV$SQL
SQL> CREATE OR REPLACE VIEW sosl_session_sql_v
  2  AS
  3    SELECT sql_id
  4  	    , last_active_time
  5  	    , object_status
  6  	    , optimizer_mode
  7  	    , rows_processed
  8  	    , SUBSTR(REGEXP_REPLACE(sql_text, '\s{2,}', ' '), 1, 80) || '...' AS short_sql
  9  	    , parsing_schema_name
 10  	    , service
 11  	    , child_number
 12  	    , optimizer_cost
 13  	    , cpu_time
 14  	    , elapsed_time
 15  	    , locked_total
 16  	    , pinned_total
 17  	    , physical_read_bytes
 18  	    , physical_write_bytes
 19  	    , inst_id
 20  	    , con_id
 21  	    , module
 22  	    , action
 23  	    , module_hash
 24  	    , action_hash
 25  	    , sql_text
 26  	    , sql_fulltext
 27  	 FROM gv$sql
 28  ;

View created.

SQL> GRANT SELECT ON sosl_session_sql_v TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_session_sql_admin_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Admin content providing full GV$SQL content
SQL> CREATE OR REPLACE VIEW sosl_session_sql_admin_v
  2  AS
  3    SELECT inst_id
  4  	    , sql_text
  5  	    , sql_fulltext
  6  	    , sql_id
  7  	    , sharable_mem
  8  	    , persistent_mem
  9  	    , runtime_mem
 10  	    , sorts
 11  	    , loaded_versions
 12  	    , open_versions
 13  	    , users_opening
 14  	    , fetches
 15  	    , executions
 16  	    , px_servers_executions
 17  	    , end_of_fetch_count
 18  	    , users_executing
 19  	    , loads
 20  	    , first_load_time
 21  	    , invalidations
 22  	    , parse_calls
 23  	    , disk_reads
 24  	    , direct_writes
 25  	    , direct_reads
 26  	    , buffer_gets
 27  	    , application_wait_time
 28  	    , concurrency_wait_time
 29  	    , cluster_wait_time
 30  	    , user_io_wait_time
 31  	    , plsql_exec_time
 32  	    , java_exec_time
 33  	    , rows_processed
 34  	    , command_type
 35  	    , optimizer_mode
 36  	    , optimizer_cost
 37  	    , optimizer_env
 38  	    , optimizer_env_hash_value
 39  	    , parsing_user_id
 40  	    , parsing_schema_id
 41  	    , parsing_schema_name
 42  	    , kept_versions
 43  	    , address
 44  	    , type_chk_heap
 45  	    , hash_value
 46  	    , old_hash_value
 47  	    , plan_hash_value
 48  	    , full_plan_hash_value
 49  	    , child_number
 50  	    , service
 51  	    , service_hash
 52  	    , module
 53  	    , module_hash
 54  	    , action
 55  	    , action_hash
 56  	    , serializable_aborts
 57  	    , outline_category
 58  	    , cpu_time
 59  	    , elapsed_time
 60  	    , outline_sid
 61  	    , child_address
 62  	    , sqltype
 63  	    , remote
 64  	    , object_status
 65  	    , literal_hash_value
 66  	    , last_load_time
 67  	    , is_obsolete
 68  	    , is_bind_sensitive
 69  	    , is_bind_aware
 70  	    , is_shareable
 71  	    , child_latch
 72  	    , sql_profile
 73  	    , sql_patch
 74  	    , sql_plan_baseline
 75  	    , program_id
 76  	    , program_line#
 77  	    , exact_matching_signature
 78  	    , force_matching_signature
 79  	    , last_active_time
 80  	    , bind_data
 81  	    , typecheck_mem
 82  	    , io_cell_offload_eligible_bytes
 83  	    , io_interconnect_bytes
 84  	    , physical_read_requests
 85  	    , physical_read_bytes
 86  	    , physical_write_requests
 87  	    , physical_write_bytes
 88  	    , optimized_phy_read_requests
 89  	    , locked_total
 90  	    , pinned_total
 91  	    , io_cell_uncompressed_bytes
 92  	    , io_cell_offload_returned_bytes
 93  	    , con_id
 94  	    , is_reoptimizable
 95  	    , is_resolved_adaptive_plan
 96  	    , im_scans
 97  	    , im_scan_bytes_uncompressed
 98  	    , im_scan_bytes_inmemory
 99  	    , ddl_no_invalidate
100  	    , is_rolling_invalid
101  	    , is_rolling_refresh_invalid
102  	    , result_cache
103  	    , sql_quarantine
104  	    , avoided_executions
105  	    , heap0_load_time
106  	    , heap6_load_time
107  	    , result_cache_executions
108  	    , result_cache_rejection_reason
109  	 FROM gv$sql
110  ;

View created.

SQL> GRANT SELECT ON sosl_session_sql_admin_v TO sosl_admin;

Grant succeeded.

SQL> -- package with no dependency on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_constants.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic package for constants used by the Simple Oracle Script Loader, no dependencies.
SQL> CREATE OR REPLACE PACKAGE sosl_constants
  2  AS
  3    /**
  4    * This package contains SOSL constant declarations and functions for retrieving the constant with pure SQL.
  5    * As there are no dependencies, exceptions must be catched or handled by the caller. No logging for this functions.
  6    */
  7  
  8    /*====================================== start package constants used by SOSL ======================================*/
  9    -- define log_type constants used in SOSL_SERVER_LOG
 10    LOG_ERROR_TYPE	     CONSTANT CHAR(5)  := 'ERROR';
 11    LOG_WARNING_TYPE      CONSTANT CHAR(7)  := 'WARNING';
 12    LOG_FATAL_TYPE	     CONSTANT CHAR(5)  := 'FATAL';
 13    LOG_INFO_TYPE	     CONSTANT CHAR(4)  := 'INFO';
 14    LOG_SUCCESS_TYPE      CONSTANT CHAR(7)  := 'SUCCESS';
 15    -- Generic n/a type. Should be different from table defaults like 'not set' as table triggers interpret their DDL default value as fallback
 16    -- to set default values using package variables, which is not supported in table DDL by Oracle using DEFAULT. Packages may use variables
 17    -- from other packages in DEFAULT declarations.
 18    GEN_NA_TYPE	     CONSTANT CHAR(3)	 := 'n/a';
 19    GEN_NA_DATE_TYPE      CONSTANT DATE	 := TO_DATE('01.01.1900', 'DD.MM.YYYY');
 20    GEN_NA_TIMESTAMP_TYPE CONSTANT TIMESTAMP  := TO_TIMESTAMP('01.01.1900', 'DD.MM.YYYY');
 21    GEN_DATE_FORMAT	     CONSTANT CHAR(21)	 := 'YYYY-MM-DD HH24:MI:SS';
 22    GEN_TIMESTAMP_FORMAT  CONSTANT CHAR(24)	 := 'YYYY-MM-DD HH24:MI:SS.FF';
 23    GEN_NULL_TEXT	     CONSTANT CHAR(4)	 := 'NULL';
 24    -- numerical equations to TRUE/YES and FALSE/NO
 25    NUM_YES		     CONSTANT INTEGER  := 1;
 26    NUM_NO		     CONSTANT INTEGER  := 0;
 27    -- default error numeric expression, that is returned by functions to indicate an error had occured
 28    NUM_ERROR	     CONSTANT INTEGER  := -1;
 29    -- default success numeric expression, that is returned by functions to indicate processing was successful
 30    NUM_SUCCESS	     CONSTANT INTEGER  := 0;
 31    -- Run states
 32    RUN_STATE_WAITING     CONSTANT INTEGER  := 0;
 33    RUN_STATE_ENQUEUED    CONSTANT INTEGER  := 1;
 34    RUN_STATE_STARTED     CONSTANT INTEGER  := 2;
 35    RUN_STATE_RUNNING     CONSTANT INTEGER  := 3;
 36    RUN_STATE_FINISHED    CONSTANT INTEGER  := 4;
 37    RUN_STATE_ERROR	     CONSTANT INTEGER  := -1;
 38    -- server run modes
 39    SERVER_RUN_MODE	     CONSTANT CHAR(3)  := 'RUN';
 40    SERVER_PAUSE_MODE     CONSTANT CHAR(5)  := 'PAUSE';
 41    SERVER_STOP_MODE      CONSTANT CHAR(4)  := 'STOP';
 42    -- formatting
 43    LF		     CONSTANT CHAR(1)  := CHR(10);
 44    CR		     CONSTANT CHAR(1)  := CHR(13);
 45    CRLF		     CONSTANT CHAR(2)  := CHR(13) || CHR(10);
 46    -- SQL Developer gauge formatting - only works with SQL Developer
 47    -- syntax: SQLDEV:GAUGE:min:max:min_treshold:max_treshold:value
 48    PURE_GRAY	     CONSTANT CHAR(23) := 'SQLDEV:GAUGE:0:0:0:0:-1';
 49    PURE_RED 	     CONSTANT CHAR(23) := 'SQLDEV:GAUGE:0:0:1:0:-1';
 50    PURE_YELLOW	     CONSTANT CHAR(23) := 'SQLDEV:GAUGE:0:1:0:1:-1';
 51    PURE_GREEN	     CONSTANT CHAR(23) := 'SQLDEV:GAUGE:0:1:1:0:-1';
 52    /*====================================== end package constants used by SOSL ======================================*/
 53  
 54    /* FUNCTION SOSL_CONSTANTS.run_state_text
 55    * Returns the text interpretation (english) for the supported run states.
 56    *
 57    * @param p_run_state The numerical run state to express as text.
 58    *
 59    * @return The text equation for the given run state or sosl_constants.GEN_NA_TYPE on errors.
 60    */
 61    FUNCTION run_state_text(p_run_state IN NUMBER)
 62  	 RETURN VARCHAR2
 63  	 DETERMINISTIC
 64  	 PARALLEL_ENABLE
 65    ;
 66  
 67    -- All get_ functions only return the defined constant, no extra code. Constant name prefixed with GET_.
 68    FUNCTION get_log_error_type
 69  	 RETURN VARCHAR2
 70  	 DETERMINISTIC
 71  	 PARALLEL_ENABLE
 72    ;
 73    FUNCTION get_log_warning_type
 74  	 RETURN VARCHAR2
 75  	 DETERMINISTIC
 76  	 PARALLEL_ENABLE
 77    ;
 78    FUNCTION get_log_fatal_type
 79  	 RETURN VARCHAR2
 80  	 DETERMINISTIC
 81  	 PARALLEL_ENABLE
 82    ;
 83    FUNCTION get_log_info_type
 84  	 RETURN VARCHAR2
 85  	 DETERMINISTIC
 86  	 PARALLEL_ENABLE
 87    ;
 88    FUNCTION get_log_success_type
 89  	 RETURN VARCHAR2
 90  	 DETERMINISTIC
 91  	 PARALLEL_ENABLE
 92    ;
 93    FUNCTION get_gen_na_type
 94  	 RETURN VARCHAR2
 95  	 DETERMINISTIC
 96  	 PARALLEL_ENABLE
 97    ;
 98    FUNCTION get_gen_na_date_type
 99  	 RETURN DATE
100  	 DETERMINISTIC
101  	 PARALLEL_ENABLE
102    ;
103    FUNCTION get_gen_na_timestamp_type
104  	 RETURN DATE
105  	 DETERMINISTIC
106  	 PARALLEL_ENABLE
107    ;
108    FUNCTION get_gen_date_format
109  	 RETURN VARCHAR2
110  	 DETERMINISTIC
111  	 PARALLEL_ENABLE
112    ;
113    FUNCTION get_gen_timestamp_format
114  	 RETURN VARCHAR2
115  	 DETERMINISTIC
116  	 PARALLEL_ENABLE
117    ;
118    FUNCTION get_gen_null_text
119  	 RETURN VARCHAR2
120  	 DETERMINISTIC
121  	 PARALLEL_ENABLE
122    ;
123    FUNCTION get_num_yes
124  	 RETURN NUMBER
125  	 DETERMINISTIC
126  	 PARALLEL_ENABLE
127    ;
128    FUNCTION get_num_no
129  	 RETURN NUMBER
130  	 DETERMINISTIC
131  	 PARALLEL_ENABLE
132    ;
133    FUNCTION get_num_error
134  	 RETURN NUMBER
135  	 DETERMINISTIC
136  	 PARALLEL_ENABLE
137    ;
138    FUNCTION get_num_success
139  	 RETURN NUMBER
140  	 DETERMINISTIC
141  	 PARALLEL_ENABLE
142    ;
143    FUNCTION get_run_state_waiting
144  	 RETURN NUMBER
145  	 DETERMINISTIC
146  	 PARALLEL_ENABLE
147    ;
148    FUNCTION get_run_state_enqueued
149  	 RETURN NUMBER
150  	 DETERMINISTIC
151  	 PARALLEL_ENABLE
152    ;
153    FUNCTION get_run_state_started
154  	 RETURN NUMBER
155  	 DETERMINISTIC
156  	 PARALLEL_ENABLE
157    ;
158    FUNCTION get_run_state_running
159  	 RETURN NUMBER
160  	 DETERMINISTIC
161  	 PARALLEL_ENABLE
162    ;
163    FUNCTION get_run_state_finished
164  	 RETURN NUMBER
165  	 DETERMINISTIC
166  	 PARALLEL_ENABLE
167    ;
168    FUNCTION get_run_state_error
169  	 RETURN NUMBER
170  	 DETERMINISTIC
171  	 PARALLEL_ENABLE
172    ;
173    FUNCTION get_server_run_mode
174  	 RETURN VARCHAR2
175  	 DETERMINISTIC
176  	 PARALLEL_ENABLE
177    ;
178    FUNCTION get_server_pause_mode
179  	 RETURN VARCHAR2
180  	 DETERMINISTIC
181  	 PARALLEL_ENABLE
182    ;
183    FUNCTION get_server_stop_mode
184  	 RETURN VARCHAR2
185  	 DETERMINISTIC
186  	 PARALLEL_ENABLE
187    ;
188    FUNCTION get_lf
189  	 RETURN VARCHAR2
190  	 DETERMINISTIC
191  	 PARALLEL_ENABLE
192    ;
193    FUNCTION get_cr
194  	 RETURN VARCHAR2
195  	 DETERMINISTIC
196  	 PARALLEL_ENABLE
197    ;
198    FUNCTION get_crlf
199  	 RETURN VARCHAR2
200  	 DETERMINISTIC
201  	 PARALLEL_ENABLE
202    ;
203  
204    FUNCTION gray
205  	 RETURN VARCHAR2
206  	 DETERMINISTIC
207  	 PARALLEL_ENABLE
208    ;
209  
210    FUNCTION red
211  	 RETURN VARCHAR2
212  	 DETERMINISTIC
213  	 PARALLEL_ENABLE
214    ;
215  
216    FUNCTION yellow
217  	 RETURN VARCHAR2
218  	 DETERMINISTIC
219  	 PARALLEL_ENABLE
220    ;
221  
222    FUNCTION green
223  	 RETURN VARCHAR2
224  	 DETERMINISTIC
225  	 PARALLEL_ENABLE
226    ;
227  
228  END;
229  /

Package created.

SQL> -- grants
SQL> GRANT EXECUTE ON sosl_constants TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/packages/sosl_constants.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_constants
  2  AS
  3    -- for description see header file
  4  
  5    FUNCTION run_state_text(p_run_state IN NUMBER)
  6  	 RETURN VARCHAR2
  7  	 DETERMINISTIC
  8  	 PARALLEL_ENABLE
  9    IS
 10  	 l_return VARCHAR2(30);
 11    BEGIN
 12  	 l_return := CASE p_run_state
 13  		       WHEN sosl_constants.RUN_STATE_WAITING
 14  		       THEN 'Waiting'
 15  		       WHEN sosl_constants.RUN_STATE_ENQUEUED
 16  		       THEN 'Enqueued'
 17  		       WHEN sosl_constants.RUN_STATE_STARTED
 18  		       THEN 'Started'
 19  		       WHEN sosl_constants.RUN_STATE_RUNNING
 20  		       THEN 'Running'
 21  		       WHEN sosl_constants.RUN_STATE_FINISHED
 22  		       THEN 'Finished'
 23  		       WHEN sosl_constants.RUN_STATE_ERROR
 24  		       THEN 'ERROR'
 25  		       ELSE sosl_constants.GEN_NA_TYPE
 26  		     END;
 27  	 RETURN l_return;
 28    EXCEPTION
 29  	 WHEN OTHERS THEN
 30  	   RETURN sosl_constants.GEN_NA_TYPE;
 31    END run_state_text;
 32  
 33    FUNCTION get_log_error_type
 34  	 RETURN VARCHAR2
 35  	 DETERMINISTIC
 36  	 PARALLEL_ENABLE
 37    IS
 38    BEGIN
 39  	 RETURN sosl_constants.LOG_ERROR_TYPE;
 40    END get_log_error_type;
 41  
 42    FUNCTION get_log_warning_type
 43  	 RETURN VARCHAR2
 44  	 DETERMINISTIC
 45  	 PARALLEL_ENABLE
 46    IS
 47    BEGIN
 48  	 RETURN sosl_constants.LOG_WARNING_TYPE;
 49    END get_log_warning_type;
 50  
 51    FUNCTION get_log_fatal_type
 52  	 RETURN VARCHAR2
 53  	 DETERMINISTIC
 54  	 PARALLEL_ENABLE
 55    IS
 56    BEGIN
 57  	 RETURN sosl_constants.LOG_FATAL_TYPE;
 58    END get_log_fatal_type;
 59  
 60    FUNCTION get_log_info_type
 61  	 RETURN VARCHAR2
 62  	 DETERMINISTIC
 63  	 PARALLEL_ENABLE
 64    IS
 65    BEGIN
 66  	 RETURN sosl_constants.LOG_INFO_TYPE;
 67    END get_log_info_type;
 68  
 69    FUNCTION get_log_success_type
 70  	 RETURN VARCHAR2
 71  	 DETERMINISTIC
 72  	 PARALLEL_ENABLE
 73    IS
 74    BEGIN
 75  	 RETURN sosl_constants.LOG_SUCCESS_TYPE;
 76    END get_log_success_type;
 77  
 78    FUNCTION get_gen_na_type
 79  	 RETURN VARCHAR2
 80  	 DETERMINISTIC
 81  	 PARALLEL_ENABLE
 82    IS
 83    BEGIN
 84  	 RETURN sosl_constants.GEN_NA_TYPE;
 85    END get_gen_na_type;
 86  
 87    FUNCTION get_gen_na_date_type
 88  	 RETURN DATE
 89  	 DETERMINISTIC
 90  	 PARALLEL_ENABLE
 91    IS
 92    BEGIN
 93  	 RETURN sosl_constants.GEN_NA_DATE_TYPE;
 94    END get_gen_na_date_type;
 95  
 96    FUNCTION get_gen_na_timestamp_type
 97  	 RETURN DATE
 98  	 DETERMINISTIC
 99  	 PARALLEL_ENABLE
100    IS
101    BEGIN
102  	 RETURN sosl_constants.GEN_NA_TIMESTAMP_TYPE;
103    END get_gen_na_timestamp_type;
104  
105    FUNCTION get_gen_date_format
106  	 RETURN VARCHAR2
107  	 DETERMINISTIC
108  	 PARALLEL_ENABLE
109    IS
110    BEGIN
111  	 RETURN sosl_constants.GEN_DATE_FORMAT;
112    END get_gen_date_format;
113  
114    FUNCTION get_gen_timestamp_format
115  	 RETURN VARCHAR2
116  	 DETERMINISTIC
117  	 PARALLEL_ENABLE
118    IS
119    BEGIN
120  	 RETURN sosl_constants.GEN_TIMESTAMP_FORMAT;
121    END get_gen_timestamp_format;
122  
123    FUNCTION get_gen_null_text
124  	 RETURN VARCHAR2
125  	 DETERMINISTIC
126  	 PARALLEL_ENABLE
127    IS
128    BEGIN
129  	 RETURN sosl_constants.GEN_NULL_TEXT;
130    END get_gen_null_text;
131  
132    FUNCTION get_num_yes
133  	 RETURN NUMBER
134  	 DETERMINISTIC
135  	 PARALLEL_ENABLE
136    IS
137    BEGIN
138  	 RETURN sosl_constants.NUM_YES;
139    END get_num_yes;
140  
141    FUNCTION get_num_no
142  	 RETURN NUMBER
143  	 DETERMINISTIC
144  	 PARALLEL_ENABLE
145    IS
146    BEGIN
147  	 RETURN sosl_constants.NUM_NO;
148    END get_num_no;
149  
150    FUNCTION get_num_error
151  	 RETURN NUMBER
152  	 DETERMINISTIC
153  	 PARALLEL_ENABLE
154    IS
155    BEGIN
156  	 RETURN sosl_constants.NUM_ERROR;
157    END get_num_error;
158  
159    FUNCTION get_num_success
160  	 RETURN NUMBER
161  	 DETERMINISTIC
162  	 PARALLEL_ENABLE
163    IS
164    BEGIN
165  	 RETURN sosl_constants.NUM_SUCCESS;
166    END get_num_success;
167  
168    FUNCTION get_run_state_waiting
169  	 RETURN NUMBER
170  	 DETERMINISTIC
171  	 PARALLEL_ENABLE
172    IS
173    BEGIN
174  	 RETURN sosl_constants.RUN_STATE_WAITING;
175    END get_run_state_waiting;
176  
177    FUNCTION get_run_state_enqueued
178  	 RETURN NUMBER
179  	 DETERMINISTIC
180  	 PARALLEL_ENABLE
181    IS
182    BEGIN
183  	 RETURN sosl_constants.RUN_STATE_ENQUEUED;
184    END get_run_state_enqueued;
185  
186    FUNCTION get_run_state_started
187  	 RETURN NUMBER
188  	 DETERMINISTIC
189  	 PARALLEL_ENABLE
190    IS
191    BEGIN
192  	 RETURN sosl_constants.RUN_STATE_STARTED;
193    END get_run_state_started;
194  
195    FUNCTION get_run_state_running
196  	 RETURN NUMBER
197  	 DETERMINISTIC
198  	 PARALLEL_ENABLE
199    IS
200    BEGIN
201  	 RETURN sosl_constants.RUN_STATE_RUNNING;
202    END get_run_state_running;
203  
204    FUNCTION get_run_state_finished
205  	 RETURN NUMBER
206  	 DETERMINISTIC
207  	 PARALLEL_ENABLE
208    IS
209    BEGIN
210  	 RETURN sosl_constants.RUN_STATE_FINISHED;
211    END get_run_state_finished;
212  
213    FUNCTION get_run_state_error
214  	 RETURN NUMBER
215  	 DETERMINISTIC
216  	 PARALLEL_ENABLE
217    IS
218    BEGIN
219  	 RETURN sosl_constants.RUN_STATE_ERROR;
220    END get_run_state_error;
221  
222    FUNCTION get_server_run_mode
223  	 RETURN VARCHAR2
224  	 DETERMINISTIC
225  	 PARALLEL_ENABLE
226    IS
227    BEGIN
228  	 RETURN sosl_constants.SERVER_RUN_MODE;
229    END get_server_run_mode;
230  
231    FUNCTION get_server_pause_mode
232  	 RETURN VARCHAR2
233  	 DETERMINISTIC
234  	 PARALLEL_ENABLE
235    IS
236    BEGIN
237  	 RETURN sosl_constants.SERVER_PAUSE_MODE;
238    END get_server_pause_mode;
239  
240    FUNCTION get_server_stop_mode
241  	 RETURN VARCHAR2
242  	 DETERMINISTIC
243  	 PARALLEL_ENABLE
244    IS
245    BEGIN
246  	 RETURN sosl_constants.SERVER_STOP_MODE;
247    END get_server_stop_mode;
248  
249    FUNCTION get_lf
250  	 RETURN VARCHAR2
251  	 DETERMINISTIC
252  	 PARALLEL_ENABLE
253    IS
254    BEGIN
255  	 RETURN sosl_constants.LF;
256    END get_lf;
257  
258    FUNCTION get_cr
259  	 RETURN VARCHAR2
260  	 DETERMINISTIC
261  	 PARALLEL_ENABLE
262    IS
263    BEGIN
264  	 RETURN sosl_constants.CR;
265    END get_cr;
266  
267    FUNCTION get_crlf
268  	 RETURN VARCHAR2
269  	 DETERMINISTIC
270  	 PARALLEL_ENABLE
271    IS
272    BEGIN
273  	 RETURN sosl_constants.CRLF;
274    END get_crlf;
275  
276    FUNCTION gray
277  	 RETURN VARCHAR2
278  	 DETERMINISTIC
279  	 PARALLEL_ENABLE
280    IS
281    BEGIN
282  	 RETURN sosl_constants.PURE_GRAY;
283    END gray;
284  
285    FUNCTION red
286  	 RETURN VARCHAR2
287  	 DETERMINISTIC
288  	 PARALLEL_ENABLE
289    IS
290    BEGIN
291  	 RETURN sosl_constants.PURE_RED;
292    END red;
293  
294    FUNCTION yellow
295  	 RETURN VARCHAR2
296  	 DETERMINISTIC
297  	 PARALLEL_ENABLE
298    IS
299    BEGIN
300  	 RETURN sosl_constants.PURE_YELLOW;
301    END yellow;
302  
303    FUNCTION green
304  	 RETURN VARCHAR2
305  	 DETERMINISTIC
306  	 PARALLEL_ENABLE
307    IS
308    BEGIN
309  	 RETURN sosl_constants.PURE_GREEN;
310    END green;
311  
312  END;
313  /

Package body created.

SQL> -- logging package
SQL> @@../sosl_ddl/packages/sosl_log.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic logging package, dependencies only to sosl_server_log and sosl_sys.
SQL> CREATE OR REPLACE PACKAGE sosl_log
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader for managing logging.
  5    * The interface has as well functions and procedures. Functions inform about success or error, whereas severe procedure exceptions
  6    * must be handled by the caller. The intention is to log as much information as possible before running into an exception
  7    * that can't be handled any longer.
  8    *
  9    * CURRENT ORACLE error: NOCOPY for IN parameters creates compile errors, whereas documentation allows IN NOCOPY var. Any
 10    * CLOB handling errors are possibly caused by the inability to provide a CLOB as reference.
 11    */
 12  
 13    /*====================================== start internal functions made visible for testing ======================================*/
 14    /* PROCEDURE SOSL_LOG.LOG_FALLBACK
 15    * This procedure tries some fallback actions, if logging raised an exception. It will not throw an extra exception. Intended to be
 16    * used during exception handling before raising the error.
 17    * It will try to log the error in one of this tables: SOSL_SERVER_LOG, SOSLERRORLOG, SPERRORLOG or, if everything fails output the error
 18    * via DBMS_OUTPUT.
 19    *
 20    * As we can't determine if the message contains an illegal character forcing the exception, the caller should transfer SQLERRM and
 21    * verify the transmitted content before passing it to this procedure or avoid transmitting parameters which should cause errors.
 22    *
 23    * If error could be logged it matches as follows:
 24    * SOSL_SERVER_LOG(caller, sosl_identifier, message) VALUES (p_script, p_identifier, p_message)
 25    * SOSLERRORLOG, SPERRORLOG(script, identifier, message) VALUES (p_script, p_identifier, p_message)
 26    * It will not prevent the exception, only try to log it somewhere, where it could be found without needing to analyze the db server
 27    * logs. Everything runs as autonomous transaction.
 28    *
 29    * DO NOT USE THIS PROCEDURE. It is internal for this package and only visible for testing.
 30    *
 31    * @param p_script The package function or procedure causing the error, e.g. sosl_log.log_event.
 32    * @param p_identifier The identifier for this error. Saved in SOSL_IDENTIFIER in SOSL_SERVER_LOG or IDENTIFIER in the error log tables.
 33    * @param p_message The message to save. Reduce it to SQLERRM if possible.
 34    */
 35    PROCEDURE log_fallback( p_script      IN VARCHAR2
 36  			     , p_identifier  IN VARCHAR2
 37  			     , p_message     IN VARCHAR2
 38  			     )
 39    ;
 40    /* PROCEDURE SOSL_LOG.LOG_EVENT
 41    * Writes a log entry as autonomous transaction. This is the internal base procedure, exposed for testing.
 42    * If on errors writing log entries is not possible the procedure hands the exception to the caller. This is the pure insert without
 43    * any checks. It takes the values as given and table may trigger exceptions. DO NOT USE THIS PROCEDURE. It is internal for this package.
 44    *
 45    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 46    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Must be valid.
 47    * @param p_log_category An optional logging category.
 48    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 49    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 50    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 51    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 52    * @param p_script_file The script file name and path if available. Used as well by CMD server and SOSL packages and functions.
 53    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 54    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 55    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 56    */
 57    PROCEDURE log_event( p_message	       IN VARCHAR2
 58  			  , p_log_type	       IN VARCHAR2
 59  			  , p_log_category     IN VARCHAR2
 60  			  , p_guid	       IN VARCHAR2
 61  			  , p_sosl_identifier  IN VARCHAR2
 62  			  , p_executor_id      IN NUMBER
 63  			  , p_ext_script_id    IN VARCHAR2
 64  			  , p_script_file      IN VARCHAR2
 65  			  , p_caller	       IN VARCHAR2
 66  			  , p_run_id	       IN NUMBER
 67  			  , p_full_message     IN CLOB
 68  			  )
 69    ;
 70  /*====================================== end internal functions made visible for testing ======================================*/
 71  
 72    /* FUNCTION SOSL_LOG.LOG_TYPE_VALID
 73    * Central function to check the log type. Supports the log types defined in SOSL_CONSTANTS. If log types should get expanded
 74    * adjust constants, this function, the table constraint on log_type and probably the default value for SOSL_SERVER_LOG in
 75    * table definition and trigger.
 76    *
 77    * @param p_log_type The log type to check. Case insensitive.
 78    *
 79    *@return TRUE if the given log type is supported. FALSE if not. Exceptions and errors will lead also to FALSE.
 80    */
 81    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 82  	 RETURN BOOLEAN
 83  	 DETERMINISTIC
 84  	 PARALLEL_ENABLE
 85    ;
 86  
 87    /* FUNCTION SOSL_LOG.GET_VALID_LOG_TYPE
 88    * Verifies an given log type, returns either the given log type as upper case or the defined error default.
 89    *
 90    * @param p_log_type The log type to verify and return. Case insensitive.
 91    * @param p_error_default The alternative log type to return, if the log type is invalid. Must be a valid log type and not INFO or SUCCESS. If invalid, FATAL is returned.
 92    *
 93    * @return The valid log type as upper case on success. The valid error default if log type not supported. FATAL if the error default is invalid.
 94    */
 95    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 96  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_constants.LOG_ERROR_TYPE
 97  				  )
 98  	 RETURN VARCHAR2
 99  	 DETERMINISTIC
100  	 PARALLEL_ENABLE
101    ;
102  
103    /* FUNCTION SOSL_LOG.DISTRIBUTE
104    * This functions distributes char data between a VARCHAR2 and a CLOB variable by the following rules:
105    * p_string empty or NULL: Fill p_string to p_max_string_length - p_split_end length.
106    * p_string length > p_max_string_length: Cut p_string to p_max_string_length, including p_split_end appended.
107    *	  p_clob NOT EMPTY: add split_start, rest of p_string before p_clob content.
108    *	  p_clob EMPTY: add split_start and rest of p_string.
109    * p_string length > 0 and < p_max_string_length: no change of p_string and p_clob.
110    * p_string and p_clob empty or NULL: leave unchanged, return FALSE otherwise always TRUE.
111    * In case of exceptions will try to write SQLERRM to p_string as CLOBs tend to be more error prone.
112    * Mainly used by SOSL_SERVER_LOG.
113    *
114    * @param p_string The string to distribute or check. In PLSQL strings can get 32767 chars long, whereas table columns are limited currently to 4000.
115    * @param p_clob The CLOB to distribute or check. Uses NOCOPY to guarantee that CLOB full length is used as given.
116    * @param p_max_string_length The maximum length p_string should have. If this size is exeeded the string gets distribute between p_string and p_clob.
117    * @param p_split_end The split end characters to indicate that the string is continued in p_clob.
118    * @param p_split_start The split start characters for the continuing string in the CLOB.
119    * @param p_delimiter The delimiter between rest of string in CLOB and original CLOB content, if both have content and string must be splitted.
120    *
121    * @return FALSE if p_string and p_clob are empty/NULL or an exception had occurred, otherwise TRUE.
122    */
123    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
124  			  , p_clob		IN OUT NOCOPY  CLOB
125  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
126  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
127  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
128  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
129  			  )
130  	 RETURN BOOLEAN
131    ;
132  
133    /* PROCEDURE SOSL_LOG.FULL_LOG
134    * Procedure with all parameters for logging. Will check parameters before logging. You should at least set also p_log_category
135    * and p_caller, to be able to assign the log entry to a specific event and object. On parameter errors a separate log entry is
136    * created. Intention is to write a log in any case and not throw any exception. This still may happen on main system malfunctions
137    * but is limited to this events.
138    * To keep things as fast as possible, column length checks are hardcoded, no extra round trip to USER_TAB_COLUMNS. If table definition
139    * changes, this package has to be adjusted.
140    *
141    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
142    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Will be set to ERROR if not valid.
143    * @param p_log_category An optional logging category.
144    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
145    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
146    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
147    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
148    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
149    * @param p_script_file The script file name and path if available. Used as well by CMD server and SOSL packages and functions.
150    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
151    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
152    */
153    PROCEDURE full_log( p_message	      IN VARCHAR2
154  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_constants.LOG_INFO_TYPE
155  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
156  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
157  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
158  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
159  			 , p_executor_id      IN NUMBER      DEFAULT NULL
160  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
161  			 , p_script_file      IN VARCHAR2    DEFAULT NULL
162  			 , p_run_id	      IN NUMBER      DEFAULT NULL
163  			 , p_full_message     IN CLOB	     DEFAULT NULL
164  			 )
165    ;
166  
167    /* PROCEDURE SOSL_LOG.EXCEPTION_LOG
168    * Prepared and standardize logging for unhandled exceptions with reduced parameters. This procedure will not deal with extra exceptions.
169    * It will try to log the exception and then return to the caller without raising any new exceptions or logging them. It is designed
170    * for relative stability in case of exceptions. Will do a simple NVL check on parameters, nothing more before formatting and submitting
171    * the log entry. Will set log type to SOSL_CONSTANTS.LOG_FATAL_TYPE.
172    *
173    * @param p_caller The full name of function, procedure or package that has caused the unhandled exception. Case sensitive.
174    * @param p_category The log category for the function, procedure or package. Case sensitive.
175    * @param p_sqlerrmsg The full error message, usually SQLERRM. Limited to VARCHAR2 limit 32767 chars.
176    */
177    PROCEDURE exception_log( p_caller     IN VARCHAR2
178  			      , p_category   IN VARCHAR2
179  			      , p_sqlerrmsg  IN VARCHAR2
180  			      )
181    ;
182  
183    /* PROCEDURE SOSL_LOG.MINIMAL_LOG
184    * Prepared and standardize logging for any log type with reduced parameters. Will do a simple NVL check on parameters, nothing more
185    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
186    *
187    * @param p_caller The full name of function, procedure or package that should be logged. Case sensitive.
188    * @param p_category The log category for the function, procedure or package. Case sensitive.
189    * @param p_log_type The log type for the logging as defined in SOSL_CONSTANTS.LOG_... constants.
190    * @param p_short_msg The short success message, preferably smaller than 4000 chars. Will be formatted using p_caller.
191    * @param p_full_msg The complete success message, with details. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
192    */
193    PROCEDURE minimal_log( p_caller	   IN VARCHAR2
194  			    , p_category   IN VARCHAR2
195  			    , p_log_type   IN VARCHAR2
196  			    , p_short_msg  IN VARCHAR2
197  			    , p_full_msg   IN CLOB     DEFAULT NULL
198  			    )
199    ;
200    PROCEDURE minimal_log( p_caller	   IN VARCHAR2
201  			    , p_category   IN VARCHAR2
202  			    , p_log_type   IN VARCHAR2
203  			    , p_short_msg  IN VARCHAR2
204  			    , p_full_msg   IN VARCHAR2
205  			    )
206    ;
207  
208    /* PROCEDURE SOSL_LOG.MINIMAL_ERROR_LOG
209    * Prepared and standardize logging for errors with reduced parameters. Will do a simple NVL check on parameters, nothing more
210    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
211    * Will set log type to SOSL_CONSTANTS.LOG_ERROR_TYPE.
212    *
213    * @param p_caller The full name of function, procedure or package that has caused the error. Case sensitive.
214    * @param p_category The log category for the function, procedure or package. Case sensitive.
215    * @param p_short_msg The short error message, preferably smaller than 4000 chars. Will be formatted using p_caller.
216    * @param p_full_msg The complete error message, with details on the error. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
217    */
218    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
219  				  , p_category	 IN VARCHAR2
220  				  , p_short_msg  IN VARCHAR2
221  				  , p_full_msg	 IN CLOB     DEFAULT NULL
222  				  )
223    ;
224    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
225  				  , p_category	 IN VARCHAR2
226  				  , p_short_msg  IN VARCHAR2
227  				  , p_full_msg	 IN VARCHAR2
228  				  )
229    ;
230  
231    /* PROCEDURE SOSL_LOG.MINIMAL_ERROR_LOG
232    * Prepared and standardize logging for information with reduced parameters. Will do a simple NVL check on parameters, nothing more
233    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
234    * Will set log type to SOSL_CONSTANTS.LOG_INFO_TYPE.
235    *
236    * @param p_caller The full name of function, procedure or package that should be logged. Case sensitive.
237    * @param p_category The log category for the function, procedure or package. Case sensitive.
238    * @param p_short_msg The short info message, preferably smaller than 4000 chars. Will be formatted using p_caller.
239    * @param p_full_msg The complete info message, with details. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
240    */
241    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
242  				 , p_category	IN VARCHAR2
243  				 , p_short_msg	IN VARCHAR2
244  				 , p_full_msg	IN CLOB      DEFAULT NULL
245  				 )
246    ;
247    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
248  				 , p_category	IN VARCHAR2
249  				 , p_short_msg	IN VARCHAR2
250  				 , p_full_msg	IN VARCHAR2
251  				 )
252    ;
253  
254    /* PROCEDURE SOSL_LOG.MINIMAL_WARNING_LOG
255    * Prepared and standardize logging for warning with reduced parameters. Will do a simple NVL check on parameters, nothing more
256    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
257    * Will set log type to SOSL_CONSTANTS.LOG_WARNING_TYPE.
258    *
259    * @param p_caller The full name of function, procedure or package that should be logged. Case sensitive.
260    * @param p_category The log category for the function, procedure or package. Case sensitive.
261    * @param p_short_msg The short warning message, preferably smaller than 4000 chars. Will be formatted using p_caller.
262    * @param p_full_msg The complete warning message, with details. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
263    */
264    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
265  				    , p_category   IN VARCHAR2
266  				    , p_short_msg  IN VARCHAR2
267  				    , p_full_msg   IN CLOB     DEFAULT NULL
268  				    )
269    ;
270    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
271  				    , p_category   IN VARCHAR2
272  				    , p_short_msg  IN VARCHAR2
273  				    , p_full_msg   IN VARCHAR2
274  				    )
275    ;
276  
277    /* PROCEDURE SOSL_LOG.MINIMAL_SUCCESS_LOG
278    * Prepared and standardize logging for success with reduced parameters. Will do a simple NVL check on parameters, nothing more
279    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
280    * Will set log type to SOSL_CONSTANTS.LOG_SUCCESS_TYPE.
281    *
282    * @param p_caller The full name of function, procedure or package that should be logged. Case sensitive.
283    * @param p_category The log category for the function, procedure or package. Case sensitive.
284    * @param p_short_msg The short success message, preferably smaller than 4000 chars. Will be formatted using p_caller.
285    * @param p_full_msg The complete success message, with details. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
286    */
287    PROCEDURE minimal_success_log( p_caller	   IN VARCHAR2
288  				    , p_category   IN VARCHAR2
289  				    , p_short_msg  IN VARCHAR2
290  				    , p_full_msg   IN CLOB     DEFAULT NULL
291  				    )
292    ;
293    PROCEDURE minimal_success_log( p_caller	   IN VARCHAR2
294  				    , p_category   IN VARCHAR2
295  				    , p_short_msg  IN VARCHAR2
296  				    , p_full_msg   IN VARCHAR2
297  				    )
298    ;
299  
300    /* PROCEDURE SOSL_LOG.LOG_COLUMN_CHANGE
301    * Checks old and new values of a given column for differences and logs the difference. The log type will be WARNING if
302    * forbidden is TRUE, otherwise INFO. Supported types: VARCHAR2, NUMBER, DATE and TIMESTAMP
303    *
304    * @param p_old_value The old column value.
305    * @param p_new_value The new column value.
306    * @param p_column_name The name of the table and column, e.g. table.column that is checked for changes. No checks, apart from NULL, only log info. Used as log category.
307    * @param p_caller The name of the procedure, package, trigger or function that is calling this procedure. No checks, apart from NULL, only log info.
308    * @param p_forbidden Influences the log type, if TRUE the log type is WARNING else the log type is INFO.
309    */
310    PROCEDURE log_column_change( p_old_value     IN VARCHAR2
311  				  , p_new_value     IN VARCHAR2
312  				  , p_column_name   IN VARCHAR2
313  				  , p_caller	    IN VARCHAR2
314  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
315  				  )
316    ;
317    PROCEDURE log_column_change( p_old_value     IN NUMBER
318  				  , p_new_value     IN NUMBER
319  				  , p_column_name   IN VARCHAR2
320  				  , p_caller	    IN VARCHAR2
321  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
322  				  )
323    ;
324    PROCEDURE log_column_change( p_old_value     IN DATE
325  				  , p_new_value     IN DATE
326  				  , p_column_name   IN VARCHAR2
327  				  , p_caller	    IN VARCHAR2
328  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
329  				  )
330    ;
331    PROCEDURE log_column_change( p_old_value     IN TIMESTAMP
332  				  , p_new_value     IN TIMESTAMP
333  				  , p_column_name   IN VARCHAR2
334  				  , p_caller	    IN VARCHAR2
335  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
336  				  )
337    ;
338  
339  END;
340  /

Package created.

SQL> -- grants
SQL> GRANT EXECUTE ON sosl_log TO sosl_executor;

Grant succeeded.

SQL> @@../sosl_ddl/packages/sosl_log.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_log
  2  AS
  3    -- for description see header file
  4    PROCEDURE log_fallback( p_script      IN VARCHAR2
  5  			     , p_identifier  IN VARCHAR2
  6  			     , p_message     IN VARCHAR2
  7  			     )
  8    IS
  9  	 PRAGMA AUTONOMOUS_TRANSACTION;
 10  	 l_saved BOOLEAN;
 11    BEGIN
 12  	 l_saved := FALSE;
 13  	 -- try to save information in tables probably available
 14  	 BEGIN
 15  	   INSERT INTO sosl_server_log
 16  	     ( message
 17  	     , log_type
 18  	     , log_category
 19  	     , sosl_identifier
 20  	     , caller
 21  	     )
 22  	     VALUES
 23  	       ( p_message
 24  	       , sosl_constants.LOG_FATAL_TYPE
 25  	       , 'SOSL_LOG internal error'
 26  	       , p_identifier
 27  	       , p_script
 28  	       )
 29  	   ;
 30  	   COMMIT;
 31  	   l_saved := TRUE;
 32  	 EXCEPTION
 33  	   WHEN OTHERS THEN
 34  	     l_saved := FALSE;
 35  	 END;
 36  	 IF NOT l_saved
 37  	 THEN
 38  	   BEGIN
 39  	     INSERT INTO soslerrorlog
 40  	       ( message
 41  	       , identifier
 42  	       , script
 43  	       , username
 44  	       , timestamp
 45  	       )
 46  	       VALUES
 47  		 ( p_message
 48  		 , p_identifier
 49  		 , p_script
 50  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 51  		 , SYSTIMESTAMP
 52  		 )
 53  	     ;
 54  	     COMMIT;
 55  	     l_saved := TRUE;
 56  	   EXCEPTION
 57  	     WHEN OTHERS THEN
 58  	       l_saved := FALSE;
 59  	   END;
 60  	 END IF;
 61  	 IF NOT l_saved
 62  	 THEN
 63  	   BEGIN
 64  	     INSERT INTO sperrorlog
 65  	       ( message
 66  	       , identifier
 67  	       , script
 68  	       , username
 69  	       , timestamp
 70  	       )
 71  	       VALUES
 72  		 ( p_message
 73  		 , p_identifier
 74  		 , p_script
 75  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 76  		 , SYSTIMESTAMP
 77  		 )
 78  	     ;
 79  	     COMMIT;
 80  	     l_saved := TRUE;
 81  	   EXCEPTION
 82  	     WHEN OTHERS THEN
 83  	       l_saved := FALSE;
 84  	   END;
 85  	 END IF;
 86  	 -- all inserts failed, use DBMS_OUTPUT
 87  	 IF NOT l_saved
 88  	 THEN
 89  	   DBMS_OUTPUT.PUT_LINE('SOSL_LOG.LOG_FALLBACK could not save error. Fatal error in ' || p_script || ' error: ' || p_message);
 90  	 END IF;
 91    EXCEPTION
 92  	 WHEN OTHERS THEN
 93  	   -- fallback failed, let caller handle and raise the error, do nothing therefore.
 94  	   NULL;
 95    END log_fallback;
 96  
 97    PROCEDURE log_event( p_message	       IN VARCHAR2
 98  			  , p_log_type	       IN VARCHAR2
 99  			  , p_log_category     IN VARCHAR2
100  			  , p_guid	       IN VARCHAR2
101  			  , p_sosl_identifier  IN VARCHAR2
102  			  , p_executor_id      IN NUMBER
103  			  , p_ext_script_id    IN VARCHAR2
104  			  , p_script_file      IN VARCHAR2
105  			  , p_caller	       IN VARCHAR2
106  			  , p_run_id	       IN NUMBER
107  			  , p_full_message     IN CLOB
108  			  )
109    IS
110  	 PRAGMA AUTONOMOUS_TRANSACTION;
111    BEGIN
112  	 INSERT INTO sosl_server_log
113  	   ( message
114  	   , log_type
115  	   , log_category
116  	   , guid
117  	   , sosl_identifier
118  	   , executor_id
119  	   , ext_script_id
120  	   , script_file
121  	   , caller
122  	   , run_id
123  	   , full_message
124  	   )
125  	   VALUES
126  	     ( p_message
127  	     , p_log_type
128  	     , p_log_category
129  	     , p_guid
130  	     , p_sosl_identifier
131  	     , p_executor_id
132  	     , p_ext_script_id
133  	     , p_script_file
134  	     , p_caller
135  	     , p_run_id
136  	     , p_full_message
137  	     )
138  	 ;
139  	 COMMIT;
140    EXCEPTION
141  	 WHEN OTHERS THEN
142  	   -- try fallback
143  	   log_fallback('sosl_log.log_event', 'SOSL_LOG', SQLERRM);
144  	   -- try ROLLBACK
145  	   ROLLBACK;
146  	   -- and raise the error again now
147  	   RAISE;
148    END log_event;
149  
150    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
151  	 RETURN BOOLEAN
152  	 DETERMINISTIC
153  	 PARALLEL_ENABLE
154    IS
155  	 l_return	     BOOLEAN;
156  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
157  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_type_valid';
158    BEGIN
159  	 l_return := FALSE;
160  	 IF UPPER(p_log_type) IN ( sosl_constants.LOG_INFO_TYPE
161  				 , sosl_constants.LOG_WARNING_TYPE
162  				 , sosl_constants.LOG_ERROR_TYPE
163  				 , sosl_constants.LOG_FATAL_TYPE
164  				 , sosl_constants.LOG_SUCCESS_TYPE
165  				 )
166  	 THEN
167  	   l_return := TRUE;
168  	 END IF;
169  	 RETURN l_return;
170    EXCEPTION
171  	 WHEN OTHERS THEN
172  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
173  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
174  		    , p_log_category => l_self_log_category
175  		    , p_guid => NULL
176  		    , p_sosl_identifier => NULL
177  		    , p_executor_id => NULL
178  		    , p_ext_script_id => NULL
179  		    , p_script_file => NULL
180  		    , p_caller => l_self_caller
181  		    , p_run_id => NULL
182  		      -- full details
183  		    , p_full_message => SQLERRM
184  		    )
185  	   ;
186  	   RETURN FALSE;
187    END log_type_valid;
188  
189    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
190  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_constants.LOG_ERROR_TYPE
191  				  )
192  	 RETURN VARCHAR2
193  	 DETERMINISTIC
194  	 PARALLEL_ENABLE
195    IS
196  	 l_return	     VARCHAR2(30);
197  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
198  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.get_valid_log_type';
199    BEGIN
200  	 l_return := sosl_constants.LOG_FATAL_TYPE;
201  	 IF log_type_valid(p_log_type)
202  	 THEN
203  	   l_return := UPPER(p_log_type);
204  	 ELSE
205  	   IF	   log_type_valid(p_error_default)
206  	      AND  UPPER(p_error_default) NOT IN ( sosl_constants.LOG_INFO_TYPE
207  						 , sosl_constants.LOG_SUCCESS_TYPE
208  						 )
209  	   THEN
210  	     l_return := UPPER(p_error_default);
211  	   END IF;
212  	 END IF;
213  	 RETURN l_return;
214    EXCEPTION
215  	 WHEN OTHERS THEN
216  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
217  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
218  		    , p_log_category => l_self_log_category
219  		    , p_guid => NULL
220  		    , p_sosl_identifier => NULL
221  		    , p_executor_id => NULL
222  		    , p_ext_script_id => NULL
223  		    , p_script_file => NULL
224  		    , p_caller => l_self_caller
225  		    , p_run_id => NULL
226  		      -- full details
227  		    , p_full_message => SQLERRM
228  		    )
229  	   ;
230  	   RETURN sosl_constants.LOG_FATAL_TYPE;
231    END get_valid_log_type;
232  
233    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
234  			  , p_clob		IN OUT NOCOPY  CLOB
235  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
236  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
237  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
238  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
239  			  )
240  	 RETURN BOOLEAN
241    IS
242  	 l_string	     VARCHAR2(32767);
243  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
244  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.distribute';
245    BEGIN
246  	 IF	(p_string IS NULL OR NVL(LENGTH(TRIM(p_string)), 0) = 0)
247  	    AND (p_clob   IS NULL OR NVL(LENGTH(TRIM(p_clob)), 0) = 0)
248  	 THEN
249  	   RETURN FALSE;
250  	 END IF;
251  	 IF	p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
252  	    AND p_clob	 IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
253  	 THEN
254  	   IF LENGTH(p_string) > p_max_string_length
255  	   THEN
256  	     -- need to split
257  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1)) || p_delimiter;
258  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
259  	     p_clob   := l_string || p_clob;
260  	   END IF;
261  	   RETURN TRUE;
262  	 END IF;
263  	 IF p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
264  	 THEN
265  	   IF LENGTH(p_string) > p_max_string_length
266  	   THEN
267  	     -- need to split
268  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1));
269  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
270  	     p_clob   := TO_CLOB(l_string);
271  	   ELSE
272  	     p_clob := TO_CLOB(l_string);
273  	   END IF;
274  	   RETURN TRUE;
275  	 END IF;
276  	 IF p_clob IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
277  	 THEN
278  	   IF LENGTH(p_clob) > p_max_string_length
279  	   THEN
280  	     p_string := TO_CHAR(SUBSTR(p_clob, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end);
281  	   ELSE
282  	     p_string := TO_CHAR(p_clob);
283  	   END IF;
284  	   RETURN TRUE;
285  	 END IF;
286  	 -- should not reach this point
287  	 log_event( p_message => l_self_caller || ': Logic incomplete. Procedure should exit before and not reach end of procedure'
288  		  , p_log_type => sosl_constants.LOG_FATAL_TYPE
289  		  , p_log_category => l_self_log_category
290  		  , p_guid => NULL
291  		  , p_sosl_identifier => NULL
292  		  , p_executor_id => NULL
293  		  , p_ext_script_id => NULL
294  		  , p_script_file => NULL
295  		  , p_caller => l_self_caller
296  		  , p_run_id => NULL
297  		    -- full details
298  		  , p_full_message => SQLERRM
299  		  )
300  	 ;
301  	 RETURN FALSE;
302    EXCEPTION
303  	 WHEN OTHERS THEN
304  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
305  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
306  		    , p_log_category => l_self_log_category
307  		    , p_guid => NULL
308  		    , p_sosl_identifier => NULL
309  		    , p_executor_id => NULL
310  		    , p_ext_script_id => NULL
311  		    , p_script_file => NULL
312  		    , p_caller => l_self_caller
313  		    , p_run_id => NULL
314  		      -- full details
315  		    , p_full_message => SQLERRM
316  		    )
317  	   ;
318  	   RETURN FALSE;
319    END distribute;
320  
321    PROCEDURE full_log( p_message	      IN VARCHAR2
322  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_constants.LOG_INFO_TYPE
323  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
324  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
325  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
326  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
327  			 , p_executor_id      IN NUMBER      DEFAULT NULL
328  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
329  			 , p_script_file      IN VARCHAR2    DEFAULT NULL
330  			 , p_run_id	      IN NUMBER      DEFAULT NULL
331  			 , p_full_message     IN CLOB	     DEFAULT NULL
332  			 )
333    IS
334  	 -- set variables to current type
335  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
336  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.full_log';
337  	 l_log_category      sosl_server_log.log_category%TYPE;
338  	 l_log_type	     sosl_server_log.log_type%TYPE;
339  	 l_caller	     sosl_server_log.caller%TYPE;
340  	 l_guid 	     sosl_server_log.guid%TYPE;
341  	 l_sosl_identifier   sosl_server_log.sosl_identifier%TYPE;
342  	 l_executor_id	     sosl_server_log.executor_id%TYPE;
343  	 l_ext_script_id     sosl_server_log.ext_script_id%TYPE;
344  	 l_script_file	     sosl_server_log.script_file%TYPE;
345  	 l_run_id	     sosl_server_log.run_id%TYPE;
346  	 l_col_length	     INTEGER;
347    BEGIN
348  	 -- basic column checks message splitting is left to table triggers
349  	 l_log_type := sosl_log.get_valid_log_type(p_log_type);
350  	 -- LOG_CATEGORY
351  	 IF NVL(LENGTH(TRIM(p_log_category)), 0) > 256
352  	 THEN
353  	   -- write extra log entry and cut original content to limit
354  	   log_event( p_message => l_self_caller || ': p_log_category length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
355  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
356  		    , p_log_category => l_self_log_category
357  		    , p_guid => NULL
358  		    , p_sosl_identifier => NULL
359  		    , p_executor_id => NULL
360  		    , p_ext_script_id => NULL
361  		    , p_script_file => NULL
362  		    , p_caller => l_self_caller
363  		    , p_run_id => NULL
364  		      -- details and original message
365  		    , p_full_message => ('LOG_CATEGORY: ' || TRIM(p_log_category) || ' length: ' || LENGTH(TRIM(p_log_category)) || ' msg: ' || p_message || ' - ' || p_full_message)
366  		    )
367  	   ;
368  	   l_log_category := SUBSTR(TRIM(p_log_category), 1, 256);
369  	 ELSE
370  	   l_log_category := NVL(TRIM(p_log_category), sosl_constants.GEN_NA_TYPE);
371  	 END IF;
372  	 -- CALLER
373  	 IF NVL(LENGTH(TRIM(p_caller)), 0) > 256
374  	 THEN
375  	   -- write extra log entry and cut original content to limit
376  	   log_event( p_message => l_self_caller || ': p_caller length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
377  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
378  		    , p_log_category => l_self_log_category
379  		    , p_guid => NULL
380  		    , p_sosl_identifier => NULL
381  		    , p_executor_id => NULL
382  		    , p_ext_script_id => NULL
383  		    , p_script_file => NULL
384  		    , p_caller => l_self_caller
385  		    , p_run_id => NULL
386  		      -- details and original message
387  		    , p_full_message => ('CALLER: ' || TRIM(p_caller) || ' length: ' || LENGTH(TRIM(p_caller)) || ' msg: ' || p_message || ' - ' || p_full_message)
388  		    )
389  	   ;
390  	   l_caller := SUBSTR(TRIM(p_caller), 1, 256);
391  	 ELSE
392  	   l_caller := TRIM(p_caller);
393  	 END IF;
394  	 -- GUID
395  	 IF NVL(LENGTH(TRIM(p_guid)), 0) > 64
396  	 THEN
397  	   -- write extra log entry and cut original content to limit
398  	   log_event( p_message => l_self_caller || ': p_guid length exceeds column length (64) in SOSL_SERVER_LOG. See full message for message causing the error.'
399  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
400  		    , p_log_category => l_self_log_category
401  		    , p_guid => NULL
402  		    , p_sosl_identifier => NULL
403  		    , p_executor_id => NULL
404  		    , p_ext_script_id => NULL
405  		    , p_script_file => NULL
406  		    , p_caller => l_self_caller
407  		    , p_run_id => NULL
408  		      -- details and original message
409  		    , p_full_message => ('GUID: ' || TRIM(p_guid) || ' length: ' || LENGTH(TRIM(p_guid)) || ' msg: ' || p_message || ' - ' || p_full_message)
410  		    )
411  	   ;
412  	   l_guid := SUBSTR(TRIM(p_guid), 1, 64);
413  	 ELSE
414  	   l_guid := TRIM(p_guid);
415  	 END IF;
416  	 -- SOSL_IDENTIFIER
417  	 IF NVL(LENGTH(TRIM(p_sosl_identifier)), 0) > 256
418  	 THEN
419  	   -- write extra log entry and cut original content to limit
420  	   log_event( p_message => l_self_caller || ': p_sosl_identifier length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
421  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
422  		    , p_log_category => l_self_log_category
423  		    , p_guid => NULL
424  		    , p_sosl_identifier => NULL
425  		    , p_executor_id => NULL
426  		    , p_ext_script_id => NULL
427  		    , p_script_file => NULL
428  		    , p_caller => l_self_caller
429  		    , p_run_id => NULL
430  		      -- details and original message
431  		    , p_full_message => ('SOSL_IDENTIFIER: ' || TRIM(p_sosl_identifier) || ' length: ' || LENGTH(TRIM(p_sosl_identifier)) || ' msg: ' || p_message || ' - ' || p_full_message)
432  		    )
433  	   ;
434  	   l_sosl_identifier := SUBSTR(TRIM(p_sosl_identifier), 1, 256);
435  	 ELSE
436  	   l_sosl_identifier := TRIM(p_sosl_identifier);
437  	 END IF;
438  	 -- EXT_SCRIPT_ID
439  	 IF NVL(LENGTH(TRIM(p_ext_script_id)), 0) > 4000
440  	 THEN
441  	   -- write extra log entry and cut original content to limit
442  	   log_event( p_message => l_self_caller || ': p_ext_script_id length exceeds column length (4000) in SOSL_SERVER_LOG. See full message for message causing the error.'
443  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
444  		    , p_log_category => l_self_log_category
445  		    , p_guid => NULL
446  		    , p_sosl_identifier => NULL
447  		    , p_executor_id => NULL
448  		    , p_ext_script_id => NULL
449  		    , p_script_file => NULL
450  		    , p_caller => l_self_caller
451  		    , p_run_id => NULL
452  		      -- details and original message
453  		    , p_full_message => ('EXT_SCRIPT_ID: ' || TRIM(p_ext_script_id) || ' length: ' || LENGTH(TRIM(p_ext_script_id)) || ' msg: ' || p_message || ' - ' || p_full_message)
454  		    )
455  	   ;
456  	   l_ext_script_id := SUBSTR(TRIM(p_ext_script_id), 1, 4000);
457  	 ELSE
458  	   l_ext_script_id := TRIM(p_ext_script_id);
459  	 END IF;
460  	 -- SCRIPT_FILE
461  	 IF NVL(LENGTH(TRIM(p_script_file)), 0) > 4000
462  	 THEN
463  	   -- write extra log entry and cut original content to limit
464  	   log_event( p_message => l_self_caller || ': p_script_file length exceeds column length (4000) in SOSL_SERVER_LOG. See full message for message causing the error.'
465  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
466  		    , p_log_category => l_self_log_category
467  		    , p_guid => NULL
468  		    , p_sosl_identifier => NULL
469  		    , p_executor_id => NULL
470  		    , p_ext_script_id => NULL
471  		    , p_script_file => NULL
472  		    , p_caller => l_self_caller
473  		    , p_run_id => NULL
474  		      -- details and original message
475  		    , p_full_message => ('SCRIPT_FILE: ' || TRIM(p_script_file) || ' length: ' || LENGTH(TRIM(p_script_file)) || ' msg: ' || p_message || ' - ' || p_full_message)
476  		    )
477  	   ;
478  	   l_script_file := SUBSTR(TRIM(p_script_file), 1, 4000);
479  	 ELSE
480  	   l_script_file := TRIM(p_script_file);
481  	 END IF;
482  	 -- no check on numbers
483  	 l_executor_id := p_executor_id;
484  	 l_run_id := p_run_id;
485  	 -- try to write the given data to SOSL_SERVER_LOG
486  	 log_event( p_message => p_message
487  		  , p_log_type => l_log_type
488  		  , p_log_category => l_log_category
489  		  , p_guid => l_guid
490  		  , p_sosl_identifier => l_sosl_identifier
491  		  , p_executor_id => l_executor_id
492  		  , p_ext_script_id => l_ext_script_id
493  		  , p_script_file => l_script_file
494  		  , p_caller => l_caller
495  		  , p_run_id => l_run_id
496  		  , p_full_message => p_full_message
497  		  )
498  	 ;
499    EXCEPTION
500  	 WHEN OTHERS THEN
501  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
502  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
503  		    , p_log_category => l_self_log_category
504  		    , p_guid => NULL
505  		    , p_sosl_identifier => NULL
506  		    , p_executor_id => NULL
507  		    , p_ext_script_id => NULL
508  		    , p_script_file => NULL
509  		    , p_caller => l_self_caller
510  		    , p_run_id => NULL
511  		      -- full details and original message
512  		    , p_full_message => (SQLERRM || ': ' || p_message)
513  		    )
514  	   ;
515    END full_log;
516  
517    PROCEDURE exception_log( p_caller     IN VARCHAR2
518  			      , p_category   IN VARCHAR2
519  			      , p_sqlerrmsg  IN VARCHAR2
520  			      )
521    IS
522  	 l_category  sosl_server_log.log_category%TYPE;
523  	 l_caller    sosl_server_log.caller%TYPE;
524  	 l_message   VARCHAR2(32767);
525    BEGIN
526  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
527  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
528  	 l_message   := NVL(p_sqlerrmsg, 'Called sosl_log.exception_log without message.');
529  	 full_log( p_message => l_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(l_message, 1, 500)) || CASE WHEN LENGTH(l_message) > 500 THEN ' ... see full_message for complete details.' END
530  		 , p_log_type => sosl_constants.LOG_FATAL_TYPE
531  		 , p_log_category => l_category
532  		 , p_guid => NULL
533  		 , p_sosl_identifier => NULL
534  		 , p_executor_id => NULL
535  		 , p_ext_script_id => NULL
536  		 , p_script_file => NULL
537  		 , p_caller => l_caller
538  		 , p_run_id => NULL
539  		   -- full details and original message
540  		 , p_full_message => l_message
541  		 )
542  	 ;
543    EXCEPTION
544  	 WHEN OTHERS THEN
545  	   -- no extra trouble if already in exception state
546  	   NULL;
547    END exception_log;
548  
549    PROCEDURE minimal_log( p_caller	   IN VARCHAR2
550  			    , p_category   IN VARCHAR2
551  			    , p_log_type   IN VARCHAR2
552  			    , p_short_msg  IN VARCHAR2
553  			    , p_full_msg   IN CLOB     DEFAULT NULL
554  			    )
555    IS
556  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
557  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_log CLOB';
558  	 l_category	     sosl_server_log.log_category%TYPE;
559  	 l_caller	     sosl_server_log.caller%TYPE;
560  	 l_log_type	     sosl_server_log.log_type%TYPE;
561  	 l_short_msg	     VARCHAR2(32767);
562  	 l_full_msg	     CLOB;
563    BEGIN
564  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
565  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
566  	 l_log_type  := get_valid_log_type(p_log_type);
567  	 IF p_short_msg IS NULL AND p_full_msg IS NULL
568  	 THEN
569  	   l_log_type  := sosl_constants.LOG_ERROR_TYPE;
570  	   l_short_msg := 'Called sosl_log.minimal_log without any message. Intended log type ' || p_log_type;
571  	   l_full_msg  := 'Called sosl_log.minimal_log without any message. Intended log type ' || p_log_type;
572  	 ELSIF p_short_msg IS NULL AND p_full_msg IS NOT NULL
573  	 THEN
574  	   -- split long message
575  	   l_short_msg := SUBSTR(p_full_msg, 1, 500) || CASE WHEN LENGTH(p_full_msg) > 500 THEN ' ... see full_message for complete details.' END;
576  	   l_full_msg  := p_full_msg;
577  	 ELSIF LENGTH(p_short_msg) > 3600
578  	 THEN
579  	   -- a very long short message, handle the overflow and distribute it to full message, we do not check for 4000 length to have some formatting space
580  	   l_short_msg := SUBSTR(p_short_msg, 1, 500) || ' ... see full_message for complete details.';
581  	   l_full_msg  := '... ' || SUBSTR(p_short_msg, 501) || ' - ' || p_full_msg;
582  	 ELSE
583  	   -- if long message is NULL we do not care, maybe NULL or given, handled as given.
584  	   l_short_msg := p_short_msg;
585  	   l_full_msg  := p_full_msg;
586  	 END IF;
587  	 full_log( p_message => l_short_msg
588  		 , p_log_type => l_log_type
589  		 , p_log_category => l_category
590  		 , p_guid => NULL
591  		 , p_sosl_identifier => NULL
592  		 , p_executor_id => NULL
593  		 , p_ext_script_id => NULL
594  		 , p_script_file => NULL
595  		 , p_caller => l_caller
596  		 , p_run_id => NULL
597  		   -- full details and original message
598  		 , p_full_message => l_full_msg
599  		 )
600  	 ;
601    EXCEPTION
602  	 WHEN OTHERS THEN
603  	   -- log exception as we should not be already in exception state, only application error
604  	   -- do not raise again
605  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
606    END minimal_log;
607  
608    PROCEDURE minimal_log( p_caller	   IN VARCHAR2
609  			    , p_category   IN VARCHAR2
610  			    , p_log_type   IN VARCHAR2
611  			    , p_short_msg  IN VARCHAR2
612  			    , p_full_msg   IN VARCHAR2
613  			    )
614    IS
615  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
616  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_log VARCHAR2';
617    BEGIN
618  	 sosl_log.minimal_log(p_caller, p_category, p_log_type, p_short_msg, TO_CLOB(p_full_msg));
619    EXCEPTION
620  	 WHEN OTHERS THEN
621  	   -- log exception as we should not be already in exception state, only application error
622  	   -- do not raise again
623  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
624    END minimal_log;
625  
626    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
627  				  , p_category	 IN VARCHAR2
628  				  , p_short_msg  IN VARCHAR2
629  				  , p_full_msg	 IN CLOB     DEFAULT NULL
630  				  )
631    IS
632  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
633  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_error_log CLOB';
634    BEGIN
635  	 minimal_log(p_caller, p_category, sosl_constants.LOG_ERROR_TYPE, p_short_msg, p_full_msg);
636    EXCEPTION
637  	 WHEN OTHERS THEN
638  	   -- log exception as we should not be already in exception state, only application error
639  	   -- do not raise again
640  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
641    END minimal_error_log;
642  
643    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
644  				  , p_category	 IN VARCHAR2
645  				  , p_short_msg  IN VARCHAR2
646  				  , p_full_msg	 IN VARCHAR2
647  				  )
648    IS
649  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
650  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_error_log VARCHAR2';
651    BEGIN
652  	 sosl_log.minimal_error_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
653    EXCEPTION
654  	 WHEN OTHERS THEN
655  	   -- log exception as we should not be already in exception state, only application error
656  	   -- do not raise again
657  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
658    END minimal_error_log;
659  
660    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
661  				 , p_category	IN VARCHAR2
662  				 , p_short_msg	IN VARCHAR2
663  				 , p_full_msg	IN CLOB      DEFAULT NULL
664  				 )
665    IS
666  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
667  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_info_log CLOB';
668    BEGIN
669  	 minimal_log(p_caller, p_category, sosl_constants.LOG_INFO_TYPE, p_short_msg, p_full_msg);
670    EXCEPTION
671  	 WHEN OTHERS THEN
672  	   -- log exception as we should not be already in exception state, only application error
673  	   -- do not raise again
674  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
675    END minimal_info_log;
676  
677    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
678  				 , p_category	IN VARCHAR2
679  				 , p_short_msg	IN VARCHAR2
680  				 , p_full_msg	IN VARCHAR2
681  				 )
682    IS
683  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
684  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_info_log VARCHAR2';
685    BEGIN
686  	 sosl_log.minimal_info_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
687    EXCEPTION
688  	 WHEN OTHERS THEN
689  	   -- log exception as we should not be already in exception state, only application error
690  	   -- do not raise again
691  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
692    END minimal_info_log;
693  
694    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
695  				    , p_category   IN VARCHAR2
696  				    , p_short_msg  IN VARCHAR2
697  				    , p_full_msg   IN CLOB     DEFAULT NULL
698  				    )
699    IS
700  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
701  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_warning_log CLOB';
702    BEGIN
703  	 minimal_log(p_caller, p_category, sosl_constants.LOG_WARNING_TYPE, p_short_msg, p_full_msg);
704    EXCEPTION
705  	 WHEN OTHERS THEN
706  	   -- log exception as we should not be already in exception state, only application error
707  	   -- do not raise again
708  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
709    END minimal_warning_log;
710  
711    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
712  				    , p_category   IN VARCHAR2
713  				    , p_short_msg  IN VARCHAR2
714  				    , p_full_msg   IN VARCHAR2
715  				    )
716    IS
717  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
718  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_warning_log VARCHAR2';
719    BEGIN
720  	 sosl_log.minimal_warning_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
721    EXCEPTION
722  	 WHEN OTHERS THEN
723  	   -- log exception as we should not be already in exception state, only application error
724  	   -- do not raise again
725  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
726    END minimal_warning_log;
727  
728    PROCEDURE minimal_success_log( p_caller	   IN VARCHAR2
729  				    , p_category   IN VARCHAR2
730  				    , p_short_msg  IN VARCHAR2
731  				    , p_full_msg   IN CLOB     DEFAULT NULL
732  				    )
733    IS
734  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
735  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_success_log CLOB';
736    BEGIN
737  	 minimal_log(p_caller, p_category, sosl_constants.LOG_SUCCESS_TYPE, p_short_msg, p_full_msg);
738    EXCEPTION
739  	 WHEN OTHERS THEN
740  	   -- log exception as we should not be already in exception state, only application error
741  	   -- do not raise again
742  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
743    END minimal_success_log;
744  
745    PROCEDURE minimal_success_log( p_caller	   IN VARCHAR2
746  				    , p_category   IN VARCHAR2
747  				    , p_short_msg  IN VARCHAR2
748  				    , p_full_msg   IN VARCHAR2
749  				    )
750    IS
751  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
752  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_success_log VARCHAR2';
753    BEGIN
754  	 sosl_log.minimal_warning_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
755    EXCEPTION
756  	 WHEN OTHERS THEN
757  	   -- log exception as we should not be already in exception state, only application error
758  	   -- do not raise again
759  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
760    END minimal_success_log;
761  
762    PROCEDURE log_column_change( p_old_value     IN VARCHAR2
763  				  , p_new_value     IN VARCHAR2
764  				  , p_column_name   IN VARCHAR2
765  				  , p_caller	    IN VARCHAR2
766  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
767  				  )
768    IS
769  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
770  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change VARCHAR2';
771  	 l_log_category      sosl_server_log.log_category%TYPE;
772  	 l_caller	     sosl_server_log.caller%TYPE;
773    BEGIN
774  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
775  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
776  	   -- log parameter errors
777  	 IF p_column_name IS NULL
778  	 THEN
779  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
780  	 END IF;
781  	 IF p_caller IS NULL
782  	 THEN
783  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
784  	 END IF;
785  	 IF NVL(p_old_value, sosl_constants.GEN_NA_TYPE) != NVL(p_new_value, sosl_constants.GEN_NA_TYPE)
786  	 THEN
787  	   IF p_forbidden
788  	   THEN
789  	     sosl_log.minimal_warning_log( l_caller
790  					 , l_log_category
791  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(p_new_value, sosl_constants.GEN_NULL_TEXT)
792  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
793  					 )
794  	     ;
795  	   ELSE
796  	     sosl_log.minimal_info_log( l_caller
797  				      , l_log_category
798  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(p_old_value, sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(p_new_value, sosl_constants.GEN_NULL_TEXT)
799  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
800  				      )
801  	     ;
802  	   END IF;
803  	 END IF;
804    EXCEPTION
805  	 WHEN OTHERS THEN
806  	   -- log exception as we should not be already in exception state, only application error
807  	   -- do not raise again
808  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
809    END log_column_change; -- VARCHAR2
810  
811    PROCEDURE log_column_change( p_old_value     IN NUMBER
812  				  , p_new_value     IN NUMBER
813  				  , p_column_name   IN VARCHAR2
814  				  , p_caller	    IN VARCHAR2
815  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
816  				  )
817    IS
818  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
819  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change NUMBER';
820  	 l_log_category      sosl_server_log.log_category%TYPE;
821  	 l_caller	     sosl_server_log.caller%TYPE;
822    BEGIN
823  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
824  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
825  	   -- log parameter errors
826  	 IF p_column_name IS NULL
827  	 THEN
828  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
829  	 END IF;
830  	 IF p_caller IS NULL
831  	 THEN
832  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
833  	 END IF;
834  	 -- use TO_CHAR for comparing NULL values as there is no invalid number symbol
835  	 IF NVL(TO_CHAR(p_old_value), sosl_constants.GEN_NA_TYPE) != NVL(TO_CHAR(p_new_value), sosl_constants.GEN_NA_TYPE)
836  	 THEN
837  	   IF p_forbidden
838  	   THEN
839  	     sosl_log.minimal_warning_log( l_caller
840  					 , l_log_category
841  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(TO_CHAR(p_new_value), sosl_constants.GEN_NULL_TEXT)
842  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
843  					 )
844  	     ;
845  	   ELSE
846  	     sosl_log.minimal_info_log( l_caller
847  				      , l_log_category
848  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(TO_CHAR(p_old_value), sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(TO_CHAR(p_new_value), sosl_constants.GEN_NULL_TEXT)
849  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
850  				      )
851  	     ;
852  	   END IF;
853  	 END IF;
854    EXCEPTION
855  	 WHEN OTHERS THEN
856  	   -- log exception as we should not be already in exception state, only application error
857  	   -- do not raise again
858  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
859    END log_column_change; -- NUMBER
860  
861    PROCEDURE log_column_change( p_old_value     IN DATE
862  				  , p_new_value     IN DATE
863  				  , p_column_name   IN VARCHAR2
864  				  , p_caller	    IN VARCHAR2
865  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
866  				  )
867    IS
868  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
869  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change DATE';
870  	 l_log_category      sosl_server_log.log_category%TYPE;
871  	 l_caller	     sosl_server_log.caller%TYPE;
872    BEGIN
873  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
874  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
875  	   -- log parameter errors
876  	 IF p_column_name IS NULL
877  	 THEN
878  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
879  	 END IF;
880  	 IF p_caller IS NULL
881  	 THEN
882  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
883  	 END IF;
884  	 IF NVL(p_old_value, sosl_constants.GEN_NA_DATE_TYPE) != NVL(p_new_value, sosl_constants.GEN_NA_DATE_TYPE)
885  	 THEN
886  	   IF p_forbidden
887  	   THEN
888  	     sosl_log.minimal_warning_log( l_caller
889  					 , l_log_category
890  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_DATE_FORMAT), sosl_constants.GEN_NULL_TEXT)
891  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
892  					 )
893  	     ;
894  	   ELSE
895  	     sosl_log.minimal_info_log( l_caller
896  				      , l_log_category
897  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(TO_CHAR(p_old_value, sosl_constants.GEN_DATE_FORMAT), sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_DATE_FORMAT), sosl_constants.GEN_NULL_TEXT)
898  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
899  				      )
900  	     ;
901  	   END IF;
902  	 END IF;
903    EXCEPTION
904  	 WHEN OTHERS THEN
905  	   -- log exception as we should not be already in exception state, only application error
906  	   -- do not raise again
907  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
908    END log_column_change; -- DATE
909  
910    PROCEDURE log_column_change( p_old_value     IN TIMESTAMP
911  				  , p_new_value     IN TIMESTAMP
912  				  , p_column_name   IN VARCHAR2
913  				  , p_caller	    IN VARCHAR2
914  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
915  				  )
916    IS
917  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
918  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change TIMESTAMP';
919  	 l_log_category      sosl_server_log.log_category%TYPE;
920  	 l_caller	     sosl_server_log.caller%TYPE;
921    BEGIN
922  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
923  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
924  	   -- log parameter errors
925  	 IF p_column_name IS NULL
926  	 THEN
927  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
928  	 END IF;
929  	 IF p_caller IS NULL
930  	 THEN
931  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
932  	 END IF;
933  	 IF NVL(p_old_value, sosl_constants.GEN_NA_TIMESTAMP_TYPE) != NVL(p_new_value, sosl_constants.GEN_NA_TIMESTAMP_TYPE)
934  	 THEN
935  	   IF p_forbidden
936  	   THEN
937  	     sosl_log.minimal_warning_log( l_caller
938  					 , l_log_category
939  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_TIMESTAMP_FORMAT), sosl_constants.GEN_NULL_TEXT)
940  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
941  					 )
942  	     ;
943  	   ELSE
944  	     sosl_log.minimal_info_log( l_caller
945  				      , l_log_category
946  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(TO_CHAR(p_old_value, sosl_constants.GEN_TIMESTAMP_FORMAT), sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_TIMESTAMP_FORMAT), sosl_constants.GEN_NULL_TEXT)
947  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
948  				      )
949  	     ;
950  	   END IF;
951  	 END IF;
952    EXCEPTION
953  	 WHEN OTHERS THEN
954  	   -- log exception as we should not be already in exception state, only application error
955  	   -- do not raise again
956  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
957    END log_column_change; -- TIMESTAMP
958  
959  END;
960  /

Package body created.

SQL> -- util package
SQL> @@../sosl_ddl/packages/sosl_util.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic util package not using data objects of the Simple Oracle Script Loader, apart from sosl_sys and logging.
SQL> CREATE OR REPLACE PACKAGE sosl_util
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader that have minimal dependencies on
  5    * SOSL object. Provides logging.
  6    */
  7  
  8    /* PROCEDURE SOSL_UTIL.SPLIT_FUNCTION_NAME
  9    * Splits the given function name into its parts. Supposed delimiter is the point ".".
 10    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 11    * @param p_package OUT parameter, contains the package name if any or NULL.
 12    * @param p_function OUT parameter, contains the pure function name.
 13    */
 14    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
 15  				    , p_package       OUT VARCHAR2
 16  				    , p_function      OUT VARCHAR2
 17  				    )
 18    ;
 19  
 20    /* FUNCTION SOSL_UTIL.HAS_DB_USER
 21    * Checks if a given user is visible for SOSL by checking ALL_USERS. Users must be visible to SOSL to be able to dynamically
 22    * grant the necessary rights on the API for script execution.
 23    *
 24    * @param p_username The database user name to check.
 25    *
 26    * @return TRUE if the user is visible in ALL_USERS to SOSL, otherwise FALSE.
 27    */
 28    FUNCTION has_db_user(p_username IN VARCHAR2)
 29  	 RETURN BOOLEAN
 30    ;
 31  
 32    /* FUNCTION SOSL_UTIL.HAS_FUNCTION
 33    * Checks if a given function or package function name is visible for SOSL by checking ALL_ATTRIBUTES. Internal SOSL packages,
 34    * apart from SOSL_IF% packages, are excluded from the search to avoid self references.
 35    *
 36    * @param p_owner The owner of the function or package function name to check.
 37    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 38    * @param p_datatype The return datatype of the function expected, e.g. a valid Oracle datatype like NUMBER or VARCHAR2.
 39    *
 40    * @return TRUE if the function is visible in ALL_ATTRIBUTES to SOSL and has the required return datatype, otherwise FALSE.
 41    */
 42    FUNCTION has_function( p_owner	       IN VARCHAR2
 43  			    , p_function_name  IN VARCHAR2
 44  			    , p_datatype       IN VARCHAR2
 45  			    )
 46  	 RETURN BOOLEAN
 47    ;
 48  
 49    /*FUNCTION SOSL_UTIL.GET_COL_LENGTH
 50    * Returns the column length for a given table and column or -1 if table or column does not exist from USER_TAB_COLUMNS using
 51    * DATA_LENGTH. DATA_LENGTH is misleading if not a char type or CLOB, as CLOB types report 4000 which is definitely wrong.
 52    * The only types handled are NUMBER and CLOB. All other types return the DATA_LENGTH.
 53    *
 54    * Length for numbers is calculated by adding precision and scale.
 55    *
 56    * CLOB will return the PLSQL equation of a VARCHAR2/CLOB, which is 32767 and still wrong, but useful to see if a PLSQL can handle
 57    * the CLOB. Be careful with CLOB handling. If source is not a table column, PLSQL most likely limits it to 32767 cutting longer content.
 58    *
 59    * Objects not in the current schema will not be considered and return -1 AS USER_TAB_COLUMN is used.
 60    *
 61    * No handling for date and timestamp values, as their char representation has too much dependencies on NLS and formatting to get a
 62    * reliable length.
 63    *
 64    * Byte and char semantic is not considered only the effective chars that can be stored in CHAR or VARCHAR2 as defined by DATA_LENGTH.
 65    *
 66    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
 67    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
 68    *
 69    * @return The calculated length of the column. Fix PLSQL limit 32767 for CLOB types. DATA_LENGTH for data and timestamp types.
 70    */
 71    FUNCTION get_col_length( p_table  IN VARCHAR2
 72  			      , p_column IN VARCHAR2
 73  			      )
 74  	 RETURN INTEGER
 75    ;
 76  
 77    /* FUNCTION SOSL_UTIL.GET_COL_TYPE
 78    * Returns the type of a column from USER_TAB_COLUMNS as defined in DATA_TYPE or NA_TYPE if table or column doesn't exist.
 79    * Objects not in the current schema will not be considered and return NA_TYPE.
 80    *
 81    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
 82    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
 83    *
 84    * @return The type of the column as defined in DATA_TYPE or sosl_sys.NA_TYPE on errors or not found columns and tables.
 85    */
 86    FUNCTION get_col_type( p_table  IN VARCHAR2
 87  			    , p_column IN VARCHAR2
 88  			    )
 89  	 RETURN VARCHAR2
 90    ;
 91  
 92    /* FUNCTION SOSL_UTIL.CHECK_COL
 93    * This function can check NUMBER and VARCHAR2/CHAR columns for length and type. Passing a number for a char column type will result
 94    * in FALSE. Providing a P_VALUE with a length longer than the length calculated, will result in FALSE. It will not consider
 95    * implicite Oracle conversions. Expects type like defined.
 96    *
 97    * Number length is calculated by TO_CHAR string representation removing all delimiters and counting only numbers 0-9.
 98    * Passing a VARCHAR2 value is valid for CHAR and VARCHAR2 column types.
 99    *
100    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
101    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
102    * @param p_value The value for the table column to check against column definition.
103    *
104    * @return TRUE if value and column match in type and length, otherwise FALSE.
105    */
106    FUNCTION check_col( p_table  IN VARCHAR2
107  			 , p_column IN VARCHAR2
108  			 , p_value  IN VARCHAR2
109  			 )
110  	 RETURN BOOLEAN
111    ;
112    FUNCTION check_col( p_table  IN VARCHAR2
113  			 , p_column IN VARCHAR2
114  			 , p_value  IN NUMBER
115  			 )
116  	 RETURN BOOLEAN
117    ;
118  
119    /* FUNCTION SOSL_UTIL.HAS_ROLE
120    * This function determines if a given database user has the requested role granted. This will also include
121    * implicite roles granted by role hierarchy.
122    *
123    * @param p_db_user The database user to check. Has to be a valid database user.
124    * @param p_role The role to check. Limited to roles starting with SOSL. Must be a valid and existing role.
125    *
126    * @return Will return TRUE, if user has the role assigned, otherwise FALSE, also in case of errors which get logged.
127    */
128    FUNCTION has_role( p_db_user IN VARCHAR2
129  			, p_role    IN VARCHAR2
130  			)
131  	 RETURN BOOLEAN
132    ;
133  
134    /* FUNCTION SOSL_UTIL.GRANT_ROLE
135    * This function grants a given database user the given role.
136    *
137    * @param p_db_user The database user to get the role grant. Has to be a valid database user.
138    * @param p_role The role to grant. Limited to roles starting with SOSL. Must be a valid and existing role with ADMIN rights for SOSL schema.
139    *
140    * @return Will return TRUE, if user has the role or has been granted the role successfully, otherwise FALSE, also in case of errors which get logged.
141    */
142    FUNCTION grant_role( p_db_user IN VARCHAR2
143  			  , p_role    IN VARCHAR2
144  			  )
145  	 RETURN BOOLEAN
146    ;
147  
148    /* FUNCTION SOSL_UTIL.REVOKE_ROLE
149    * This function revoke a given role from a given database user.
150    *
151    * @param p_db_user The database user to remove the role grant. Has to be a valid database user.
152    * @param p_role The role to remove. Limited to roles starting with SOSL. Must be a valid and existing role with ADMIN rights for SOSL schema.
153    *
154    * @return Will return TRUE, if user has not the role or has been revoked the role successfully, otherwise FALSE, also in case of errors which get logged.
155    */
156    FUNCTION revoke_role( p_db_user IN VARCHAR2
157  			   , p_role    IN VARCHAR2
158  			   )
159  	 RETURN BOOLEAN
160    ;
161  
162    /* FUNCTION SOSL_UTIL.UTC_MAIL_DATE
163    * Returns the current date timestamp as a formatted string for date values in mail.
164    *
165    * @return A date string conform to RFC5322 for using mail or NULL on errors.
166    *
167    * @see https://datatracker.ietf.org/doc/html/rfc5322
168    */
169    FUNCTION utc_mail_date
170  	 RETURN VARCHAR2
171    ;
172  
173    /* FUNCTION SOSL_UTIL.FORMAT_MAIL
174    * This function formats a mail message conforming to RFC5322. The content of p_message is not checked against RFC. This is
175    * the repsonsibility of the user. This is for small messages that do not exceed 32k in total.
176    *
177    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
178    * @param p_recipients The semicolon separated list of mail recipient addresses.
179    * @param p_subject A preferablly short subject for the mail.
180    * @param p_message The correctly formatted mail message.
181    *
182    * @return A formatted string with complete mail message that can be used with RFC compliant mail servers or NULL on errors.
183    */
184    FUNCTION format_mail( p_sender	   IN VARCHAR2
185  			   , p_recipients  IN VARCHAR2
186  			   , p_subject	   IN VARCHAR2
187  			   , p_message	   IN VARCHAR2
188  			   )
189  	 RETURN VARCHAR2
190    ;
191  
192    /* FUNCTION SOSL_UTIL.CHECK_MAIL_ADDRESS
193    * Checks the format of an email address roughly. Does not check if this is a valid and working email address.
194    * Format checking based on a minimal email address like a@b.io, which requires a minimum length of six chars
195    * and having the @ and the . as domain separator in the email address. Errors will get logged.
196    *
197    * @param The email address to check, basic expected format is user@company.domain.
198    *
199    * @return Return TRUE if the address fulfills the minimum criteria for a mail address otherwise FALSE, including for errors.
200    */
201    FUNCTION check_mail_address_format(p_mail_address IN VARCHAR2)
202  	 RETURN BOOLEAN
203    ;
204  
205    /* FUNCTION SOSL_UTIL.DUMMY_MAIL
206    * This is a testing function that will NOT send any mail. It will log the mail message created in SOSL_SERVER_LOG using
207    * the field full_message, so output can be controlled.
208    *
209    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
210    * @param p_recipients The semicolon separated list of mail recipient addresses.
211    * @param p_subject A preferablly short subject for the mail.
212    * @param p_message The correctly formatted mail message.
213    *
214    * @return Will return 0 on success or -1 on errors.
215    */
216    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
217  			  , p_recipients  IN VARCHAR2
218  			  , p_subject	  IN VARCHAR2
219  			  , p_message	  IN VARCHAR2
220  			  )
221  	 RETURN NUMBER
222    ;
223  
224    /* FUNCTION SOSL_UTIL.TXT_BOOLEAN
225    * Provides text values to display instead of BOOLEAN or NUMBER values interpreted as BOOLEAN. Numbers are interpreted
226    * similar to Oracle SQL, where 0 is FALSE and 1 is TRUE. 1 is considered as TRUE, any other value as FALSE. NULL values
227    * are interpreted as sosl_sys.NA_TYPE. Maximum 10 characters for TRUE/FALSE equation.
228    *
229    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
230    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
231    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
232    *
233    * @return The text equation for the given p_bool value or sosl_constants.GEN_NA_TYPE on errors.
234    */
235    FUNCTION txt_boolean( p_bool   IN BOOLEAN
236  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
237  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
238  			   )
239  	 RETURN VARCHAR2
240  	 DETERMINISTIC
241  	 PARALLEL_ENABLE
242    ;
243    FUNCTION txt_boolean( p_bool   IN NUMBER
244  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
245  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
246  			   )
247  	 RETURN VARCHAR2
248  	 DETERMINISTIC
249  	 PARALLEL_ENABLE
250    ;
251  
252    /* FUNCTION SOSL_UTIL.YES_NO
253    * A simple wrapper for txt_boolean with YES/NO instead of TRUE/FALSE.
254    *
255    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
256    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
257    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
258    *
259    * @return The text equation for the given p_bool value or sosl_constants.GEN_NA_TYPE on errors.
260    */
261    FUNCTION yes_no( p_bool	 IN BOOLEAN
262  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
263  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
264  		      )
265  	 RETURN VARCHAR2
266  	 DETERMINISTIC
267  	 PARALLEL_ENABLE
268    ;
269    FUNCTION yes_no( p_bool	 IN NUMBER
270  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
271  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
272  		      )
273  	 RETURN VARCHAR2
274  	 DETERMINISTIC
275  	 PARALLEL_ENABLE
276    ;
277  
278    /* FUNCTION SOSL_UTIL.OBJECT_DATE
279    * Works only for objects in the current schema, using USER_OBJECTS. Will return the LAST_DDL_TIME or the NA date type
280    * from SOSL_CONSTANTS if the object could not be found. Object type has to conform to object types used in USER_OBJECTS.
281    *
282    * @param p_object_name The name of the object, will be transformed to UPPERCASE as SOSL does not use mixed case.
283    * @param p_object_type A valid object type for USER_OBJECTS, e.g. FUNCTION, PACKAGE, PACKAGE BODY, PROCEDURE.
284    *
285    * @return The LAST_DDL_TIME as noted in USER_OBJECTS or SOSL_CONSTANTS.GEN_NA_DATE_TYPE on errors or not found.
286    */
287    FUNCTION object_date( p_object_name IN VARCHAR2
288  			   , p_object_type IN VARCHAR2
289  			   )
290  	 RETURN DATE
291    ;
292  
293    /* FUNCTION SOSL_UTIL.GET_VALID_RUN_STATE
294    * Checks if given run state in valid and returns the valid run state or error state.
295    *
296    * @param The run state to check. See SOSL_CONSTANTS for defined run states.
297    *
298    * @return Either the given run state if valid or SOSL_CONSTANTS.RUN_STATE_ERROR.
299    */
300    FUNCTION get_valid_run_state(p_run_state IN NUMBER)
301  	 RETURN NUMBER
302    ;
303  
304    /** Function SOSL_UTIL.CREATE_EXECUTOR
305    * Creates a new executor definition if it did not exist already. Runs as autonomous transaction.
306    * The given interface functions must conform to the following declarations, must exist and be granted to SOSL_EXECUTOR role:
307    *
308    * fn_has_scripts: FUNCTION your_has_script RETURN NUMBER;
309    * @return A positive integer including 0 for amount of scripts waiting or -1 on errors.
310    * @task: Return the amount of waiting scripts.
311    *
312    * fn_get_next_script: FUNCTION your_get_next_script RETURN SOSL.SOSL_PAYLOAD;
313    * @return A valid and filled SOSL_PAYLOAD object containing EXECUTOR_ID, EXT_SCRIPT_ID and SCRIPT_FILE or NULL on errors.
314    * @task: Return the details of the next waiting script.
315    *
316    * fn_set_script_status: FUNCTION your_set_script_status(p_run_id IN NUMBER, p_status IN NUMBER) RETURN NUMBER;
317    * @return Execution indicator: 0 on success or -1 on errors.
318    * @task: Set the internal status of your scripts queued for execution.
319    *
320    * fn_send_db_mail: FUNCTION your_send_mail(p_run_id IN NUMBER, p_status IN NUMBER) RETURN NUMBER;
321    * @return Execution indicator: 0 on success or -1 on errors.
322    * @task: Prepare and send a mail based on script status.
323    *
324    * For examples see package SOSL_IF.
325    *
326    * @param p_executor_name The unique executor definition name.
327    * @param p_function_owner The existing and for SOSL visible database user that owns the interface functions.
328    * @param p_fn_has_scripts The fully qualified interface function for has_scripts. Must exist and be granted to SOSL_EXECUTOR.
329    * @param p_fn_get_next_script The fully qualified interface function for get_next_script. Must exist and be granted to SOSL_EXECUTOR.
330    * @param p_fn_set_script_status The fully qualified interface function for set_script_status. Must exist and be granted to SOSL_EXECUTOR.
331    * @param p_cfg_file The filename including relative or absolute path that contains the login for the executor.
332    * @param p_use_mail Defines if mail should be used (1) or not (0). Default is no mail usage.
333    * @param p_fn_send_db_mail The fully qualified interface function for send mail. If mail should be used the parameter is mandatory, must exist and be granted to SOSL_EXECUTOR.
334    * @param p_executor_description An optional description for the new executor.
335    *
336    * @return The new executor id or -1 on errors.
337    */
338    FUNCTION create_executor( p_executor_name	 IN VARCHAR2
339  			       , p_db_user		 IN VARCHAR2
340  			       , p_function_owner	 IN VARCHAR2
341  			       , p_fn_has_scripts	 IN VARCHAR2
342  			       , p_fn_get_next_script	 IN VARCHAR2
343  			       , p_fn_set_script_status  IN VARCHAR2
344  			       , p_cfg_file		 IN VARCHAR2
345  			       , p_use_mail		 IN NUMBER     DEFAULT 0
346  			       , p_fn_send_db_mail	 IN VARCHAR2   DEFAULT NULL
347  			       , p_executor_description  IN VARCHAR2   DEFAULT NULL
348  			       )
349  	 RETURN NUMBER
350    ;
351  
352    /** Function SOSL_UTIL.ACTIVE_STATE_EXECUTOR
353    * Sets the EXECUTOR_ACTIVE flag. Runs as autonomous transaction.
354    *
355    * @param p_executor_id The id of the executor that should be changed.
356    * @param p_active_state The desired active state of the executor. Either 0 - not activated (default) or 1 - activated.
357    *
358    * @return Execution indicator: 0 if successful otherwise -1.
359    */
360    FUNCTION active_state_executor( p_executor_id   IN NUMBER
361  				     , p_active_state  IN NUMBER DEFAULT 0
362  				     )
363  	 RETURN NUMBER
364    ;
365  
366    /** Function SOSL_UTIL.REVIEW_STATE_EXECUTOR
367    * Sets the EXECUTOR_REVIEWED flag. Runs as autonomous transaction.
368    *
369    * @param p_executor_id The id of the executor that should be changed.
370    * @param p_review_state The reviewed state of the executor. Either 0 - review not ok (default) or 1 - reviewed and accepted.
371    *
372    * @return Execution indicator: 0 if successful otherwise -1.
373    */
374    FUNCTION review_state_executor( p_executor_id   IN NUMBER
375  				     , p_review_state  IN NUMBER DEFAULT 0
376  				     )
377  	 RETURN NUMBER
378    ;
379  
380    /** Function SOSL_UTIL.DB_IN_TIME
381    * Checks if the database is within the defined start and stop time of the SOSL server. If the database time is
382    * not in sync with the local server time of the SOSL server, the result may be wrong. Sync the time of the database
383    * and the local server to get reliable results.
384    *
385    * @return TRUE if the current database time is within the server timeframe otherwise FALSE.
386    */
387    FUNCTION db_in_time
388  	 RETURN BOOLEAN
389    ;
390  
391    /** Function SOSL_UTIL.CLEANUP_LOGS
392    * Deletes old logs. The parameter cannot be lower than one day. The current day is always kept. Runs as autonomous transaction.
393    * Will cleanup SOSL_SERVER_LOG and SOSLERRORLOG tables.
394    *
395    * @param p_older_than The amount of days to keep data. Must be >= 1.
396    *
397    * @return Execution indicator: 0 if successful otherwise -1.
398    */
399    FUNCTION cleanup_logs(p_older_than IN NUMBER DEFAULT 7)
400  	 RETURN NUMBER
401    ;
402  
403    /** Function SOSL_UTIL.CLEANUP_QUEUE
404    * Deletes old queue entries with state FINISHED or ERROR. The parameter cannot be lower than one day. The current day is always kept.
405    * Runs as autonomous transaction. Will cleanup SOSL_RUN_QUEUE.
406    *
407    * @param p_older_than The amount of days to keep data. Must be >= 1.
408    *
409    * @return Execution indicator: 0 if successful otherwise -1.
410    */
411    FUNCTION cleanup_queue(p_older_than IN NUMBER DEFAULT 7)
412  	 RETURN NUMBER
413    ;
414  
415  END;
416  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_util.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_util
  2  AS
  3    -- for description see header file
  4    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
  5  				    , p_package       OUT VARCHAR2
  6  				    , p_function      OUT VARCHAR2
  7  				    )
  8    IS
  9  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
 10  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.split_function_name';
 11    BEGIN
 12  	 IF INSTR(p_function_name, '.') > 0
 13  	 THEN
 14  	   p_package   := TRIM(SUBSTR(p_function_name, 1, INSTR(p_function_name, '.') -1));
 15  	   p_function  := TRIM(SUBSTR(p_function_name, INSTR(p_function_name, '.') +1));
 16  	 ELSE
 17  	   p_package   := NULL;
 18  	   p_function  := TRIM(p_function_name);
 19  	 END IF;
 20    EXCEPTION
 21  	 WHEN OTHERS THEN
 22  	   -- log event and raise
 23  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 24  	   RAISE;
 25    END split_function_name;
 26  
 27    FUNCTION has_db_user(p_username IN VARCHAR2)
 28  	 RETURN BOOLEAN
 29    IS
 30  	 l_has_user	     NUMBER;
 31  	 l_return	     BOOLEAN;
 32  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
 33  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.has_db_user';
 34    BEGIN
 35  	 l_return := FALSE;
 36  	 SELECT COUNT(*) INTO l_has_user FROM all_users WHERE username = p_username;
 37  	 IF l_has_user != 0
 38  	 THEN
 39  	   l_return := TRUE;
 40  	 END IF;
 41  	 RETURN l_return;
 42    EXCEPTION
 43  	 WHEN OTHERS THEN
 44  	   -- log event instead of raise
 45  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 46  	   RETURN FALSE;
 47    END has_db_user;
 48  
 49    FUNCTION has_function( p_owner	       IN VARCHAR2
 50  			    , p_function_name  IN VARCHAR2
 51  			    , p_datatype       IN VARCHAR2
 52  			    )
 53  	 RETURN BOOLEAN
 54    IS
 55  	 l_has_function      NUMBER;
 56  	 l_package	     VARCHAR2(128);
 57  	 l_function	     VARCHAR2(128);
 58  	 l_return	     BOOLEAN;
 59  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
 60  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.has_function';
 61    BEGIN
 62  	 l_return := FALSE;
 63  	 split_function_name(p_function_name, l_package, l_function);
 64  	 SELECT COUNT(*)
 65  	   INTO l_has_function
 66  	   FROM all_arguments
 67  	  WHERE position		   = 0				     -- only functions
 68  	    AND argument_name		   IS NULL			     -- only functions
 69  	    AND data_type		   = p_datatype
 70  	    AND owner			   = UPPER(p_owner)
 71  	    AND NVL(package_name, 'N/A')   = NVL(UPPER(l_package), 'N/A')    -- may not contain a package name
 72  	    AND object_name		   = UPPER(l_function)
 73  	    AND package_name		   NOT IN ( 'SOSL_SYS'		     -- exclude internal packages that should never be referenced
 74  						  , 'SOSL_UTIL'
 75  						  , 'SOSL_LOG'
 76  						  , 'SOSL_CONSTANTS'
 77  						  , 'SOSL_API'
 78  						  )
 79  	 ;
 80  	 IF l_has_function != 0
 81  	 THEN
 82  	   l_return := TRUE;
 83  	 END IF;
 84  	 RETURN l_return;
 85    EXCEPTION
 86  	 WHEN OTHERS THEN
 87  	   -- log event instead of raise
 88  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 89  	   RETURN FALSE;
 90    END has_function;
 91  
 92    FUNCTION get_col_length( p_table  IN VARCHAR2
 93  			      , p_column IN VARCHAR2
 94  			      )
 95  	 RETURN INTEGER
 96    IS
 97  	 l_return	     INTEGER;
 98  	 l_has_column	     INTEGER;
 99  	 l_data_type	     user_tab_columns.data_type%TYPE;
100  	 l_data_length	     user_tab_columns.data_length%TYPE;
101  	 l_data_precision    user_tab_columns.data_precision%TYPE;
102  	 l_data_scale	     user_tab_columns.data_scale%TYPE;
103  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_UTIL';
104  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_util.get_col_length';
105    BEGIN
106  	 l_return := -1;
107  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
108  	 IF l_has_column = 1
109  	 THEN
110  	   -- column match calculate length
111  	   SELECT data_type
112  		, data_length
113  		, data_precision
114  		, data_scale
115  	     INTO l_data_type
116  		, l_data_length
117  		, l_data_precision
118  		, l_data_scale
119  	     FROM user_tab_columns
120  	    WHERE table_name  = UPPER(p_table)
121  	      AND column_name = UPPER(p_column)
122  	   ;
123  	   IF l_data_type = 'NUMBER'
124  	   THEN
125  	     IF l_data_scale != 0
126  	     THEN
127  	       -- consider delimiter
128  	       l_return := l_data_precision + l_data_scale;
129  	     ELSE
130  	       l_return := l_data_precision;
131  	     END IF;
132  	   ELSIF l_data_type = 'CLOB'
133  	   THEN
134  	     l_return := 32767;
135  	   ELSE
136  	     l_return := l_data_length;
137  	   END IF;
138  	 END IF;
139  	 RETURN l_return;
140    EXCEPTION
141  	 WHEN OTHERS THEN
142  	   -- log event instead of raise
143  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
144  	   RETURN sosl_constants.NUM_ERROR;
145    END get_col_length;
146  
147    FUNCTION get_col_type( p_table  IN VARCHAR2
148  			    , p_column IN VARCHAR2
149  			    )
150  	 RETURN VARCHAR2
151    IS
152  	 l_return	     VARCHAR2(128);
153  	 l_has_column	     INTEGER;
154  	 l_data_type	     user_tab_columns.data_type%TYPE;
155  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
156  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.get_col_type';
157    BEGIN
158  	 l_return := sosl_constants.GEN_NA_TYPE;
159  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
160  	 IF l_has_column = 1
161  	 THEN
162  	   -- column match get data type
163  	   SELECT data_type
164  	     INTO l_return
165  	     FROM user_tab_columns
166  	    WHERE table_name  = UPPER(p_table)
167  	      AND column_name = UPPER(p_column)
168  	   ;
169  	 END IF;
170  	 RETURN l_return;
171    EXCEPTION
172  	 WHEN OTHERS THEN
173  	   -- log event instead of raise
174  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
175  	   RETURN sosl_constants.GEN_NA_TYPE;
176    END get_col_type;
177  
178    FUNCTION check_col( p_table  IN VARCHAR2
179  			 , p_column IN VARCHAR2
180  			 , p_value  IN VARCHAR2
181  			 )
182  	 RETURN BOOLEAN
183    IS
184  	 l_return	     BOOLEAN;
185  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
186  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.check_col VARCHAR';
187    BEGIN
188  	 l_return := FALSE;
189  	 IF sosl_util.get_col_type(p_table, p_column) IN ('VARCHAR2', 'CHAR')
190  	 THEN
191  	   IF NVL(LENGTH(p_value), 0) <= sosl_util.get_col_length(p_table, p_column)
192  	   THEN
193  	     l_return := TRUE;
194  	   END IF;
195  	 END IF;
196  	 RETURN l_return;
197    EXCEPTION
198  	 WHEN OTHERS THEN
199  	   -- log event instead of raise
200  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
201  	   RETURN FALSE;
202    END check_col; -- VARCHAR2 variant
203  
204    FUNCTION check_col( p_table  IN VARCHAR2
205  			 , p_column IN VARCHAR2
206  			 , p_value  IN NUMBER
207  			 )
208  	 RETURN BOOLEAN
209    IS
210  	 l_return	     BOOLEAN;
211  	 l_number	     VARCHAR2(128);
212  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
213  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.check_col NUMBER';
214    BEGIN
215  	 l_return := FALSE;
216  	 IF sosl_util.get_col_type(p_table, p_column) = 'NUMBER'
217  	 THEN
218  	   l_number := REGEXP_REPLACE(TO_CHAR(p_value), '[^0-9]', '');
219  	   IF NVL(LENGTH(l_number), 0) <= sosl_util.get_col_length(p_table, p_column)
220  	   THEN
221  	     l_return := TRUE;
222  	   END IF;
223  	 END IF;
224  	 RETURN l_return;
225    EXCEPTION
226  	 WHEN OTHERS THEN
227  	   -- log event instead of raise
228  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
229  	   RETURN FALSE;
230    END check_col; -- NUMBER variant
231  
232    FUNCTION has_role( p_db_user IN VARCHAR2
233  			, p_role    IN VARCHAR2
234  			)
235  	 RETURN BOOLEAN
236    IS
237  	 l_count	     NUMBER;
238  	 l_return	     BOOLEAN;
239  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
240  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.has_role';
241    BEGIN
242  	 l_return := FALSE;
243  	 -- identify implicite roles first
244  	   WITH rol AS
245  		(SELECT DISTINCT granted_role
246  		   FROM sosl_role_privs_v
247  		  START WITH grantee = UPPER(p_db_user)
248  		CONNECT BY PRIOR granted_role = grantee
249  		)
250  	 SELECT COUNT(*)
251  	   INTO l_count
252  	   FROM rol
253  	  WHERE granted_role = UPPER(p_role)
254  	 ;
255  	 l_return := (l_count != 0);
256  	 RETURN l_return;
257    EXCEPTION
258  	 WHEN OTHERS THEN
259  	   -- log event instead of raise
260  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
261  	   RETURN FALSE;
262    END has_role;
263  
264    FUNCTION grant_role( p_db_user IN VARCHAR2
265  			  , p_role    IN VARCHAR2
266  			  )
267  	 RETURN BOOLEAN
268    IS
269  	 PRAGMA AUTONOMOUS_TRANSACTION;
270  	 l_return	     BOOLEAN;
271  	 l_statement	     VARCHAR2(1024);
272  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
273  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.grant_role';
274    BEGIN
275  	 l_return := FALSE;
276  	 IF has_role(p_db_user, p_role)
277  	 THEN
278  	   -- has grant everything is okay
279  	   l_return := TRUE;
280  	 ELSE
281  	   -- give grant
282  	   l_statement := 'GRANT ' || p_role || ' TO ' || p_db_user;
283  	   BEGIN
284  	     EXECUTE IMMEDIATE l_statement;
285  	     l_return := TRUE;
286  	   EXCEPTION
287  	     WHEN OTHERS THEN
288  	       -- log error
289  	       sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM || ' - Could not execute: ' || l_statement);
290  	       l_return := FALSE;
291  	   END;
292  	 END IF;
293  	 RETURN l_return;
294    EXCEPTION
295  	 WHEN OTHERS THEN
296  	   -- log event instead of raise
297  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
298  	   RETURN FALSE;
299    END grant_role;
300  
301    FUNCTION revoke_role( p_db_user IN VARCHAR2
302  			   , p_role    IN VARCHAR2
303  			   )
304  	 RETURN BOOLEAN
305    IS
306  	 PRAGMA AUTONOMOUS_TRANSACTION;
307  	 l_return	     BOOLEAN;
308  	 l_has_admin	     NUMBER;
309  	 l_schema	     VARCHAR2(128);
310  	 l_statement	     VARCHAR2(1024);
311  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
312  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.revoke_role';
313    BEGIN
314  	 l_return := FALSE;
315  	 SELECT config_value INTO l_schema FROM sosl_config WHERE config_name = 'SOSL_SCHEMA';
316  	 SELECT COUNT(*) INTO l_has_admin FROM user_role_privs WHERE granted_role = p_role AND admin_option = 'YES';
317  	 IF NOT has_role(p_db_user, p_role)
318  	     OR p_db_user   = l_schema
319  	     OR l_has_admin = 1
320  	 THEN
321  	   -- SOSL user, role admin or role not given
322  	   IF	p_db_user   = l_schema
323  	     OR l_has_admin = 1
324  	   THEN
325  	     sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, 'Roles will never be revoked from role admins and SOSL schema - user '|| p_db_user || ' role ' || p_role);
326  	   ELSE
327  	     sosl_log.minimal_info_log(l_self_caller, l_self_log_category, 'Role cannot be revoked, user '|| p_db_user || ' has no role ' || p_role);
328  	   END IF;
329  	   l_return := TRUE;
330  	 ELSE
331  	   -- give grant
332  	   l_statement := 'REVOKE ' || p_role || ' FROM ' || p_db_user;
333  	   BEGIN
334  	     EXECUTE IMMEDIATE l_statement;
335  	     l_return := TRUE;
336  	   EXCEPTION
337  	     WHEN OTHERS THEN
338  	       -- log error
339  	       sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM || ' - Could not execute: ' || l_statement);
340  	       l_return := FALSE;
341  	   END;
342  	 END IF;
343  	 RETURN l_return;
344    EXCEPTION
345  	 WHEN OTHERS THEN
346  	   -- log event instead of raise
347  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
348  	   RETURN FALSE;
349    END revoke_role;
350  
351    FUNCTION utc_mail_date
352  	 RETURN VARCHAR2
353    IS
354  	 l_date VARCHAR2(500);
355    BEGIN
356  	 l_date := TO_CHAR(SYSTIMESTAMP AT TIME ZONE SESSIONTIMEZONE, 'Dy, DD Mon YYYY HH24:MI:SS TZHTZM');
357  	 RETURN l_date;
358    EXCEPTION
359  	 WHEN OTHERS THEN
360  	   -- log event instead of raise
361  	   sosl_log.exception_log('sosl_util.utc_mail_date', 'SOSL_UTIL', SQLERRM);
362  	   RETURN NULL;
363    END utc_mail_date;
364  
365    FUNCTION format_mail( p_sender	   IN VARCHAR2
366  			   , p_recipients  IN VARCHAR2
367  			   , p_subject	   IN VARCHAR2
368  			   , p_message	   IN VARCHAR2
369  			   )
370  	 RETURN VARCHAR2
371    IS
372  	 l_crlf 	 VARCHAR2(2)	   := CHR(13) || CHR(10);
373  	 l_mail_message  VARCHAR2(32767);
374    BEGIN
375  	 l_mail_message := 'From: ' || p_sender || l_crlf ||
376  			   'To: ' || p_recipients || l_crlf ||
377  			   'Date: ' || sosl_util.utc_mail_date || l_crlf ||
378  			   'Subject: ' || p_subject || l_crlf ||
379  			   p_message
380  	 ;
381  	 RETURN l_mail_message;
382    EXCEPTION
383  	 WHEN OTHERS THEN
384  	   -- log event instead of raise
385  	   sosl_log.exception_log('sosl_util.format_mail', 'SOSL_UTIL', SQLERRM);
386  	   RETURN NULL;
387    END format_mail;
388  
389    FUNCTION check_mail_address_format(p_mail_address IN VARCHAR2)
390  	 RETURN BOOLEAN
391    IS
392  	 l_return	     BOOLEAN;
393  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
394  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.check_mail_address_format';
395    BEGIN
396  	 l_return := FALSE;
397  	 IF	 LENGTH(p_mail_address) > 5
398  	    AND  INSTR(p_mail_address, '@') > 0
399  	    AND  INSTR(p_mail_address, '.') > 0
400  	 THEN
401  	   l_return := TRUE;
402  	 END IF;
403  	 RETURN l_return;
404    EXCEPTION
405  	 WHEN OTHERS THEN
406  	   -- log event instead of raise
407  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
408  	   RETURN FALSE;
409    END check_mail_address_format;
410  
411    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
412  			  , p_recipients  IN VARCHAR2
413  			  , p_subject	  IN VARCHAR2
414  			  , p_message	  IN VARCHAR2
415  			  )
416  	 RETURN NUMBER
417    IS
418  	 l_message	     VARCHAR2(32767);
419  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'MAIL DUMMY';
420  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.dummy_mail';
421    BEGIN
422  	 l_message := sosl_util.format_mail(p_sender, p_recipients, p_subject, p_message);
423  	 sosl_log.minimal_info_log(l_self_caller, l_self_log_category, 'Fake mail with subject "' || p_subject || '" created in full_message. Check the results.', l_message);
424  	 RETURN 0;
425    EXCEPTION
426  	 WHEN OTHERS THEN
427  	   -- log the error instead of RAISE
428  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
429  	   RETURN -1;
430    END dummy_mail;
431  
432    FUNCTION txt_boolean( p_bool   IN BOOLEAN
433  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
434  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
435  			   )
436  	 RETURN VARCHAR2
437  	 DETERMINISTIC
438  	 PARALLEL_ENABLE
439    IS
440    BEGIN
441  	 IF p_bool
442  	 THEN
443  	   RETURN TRIM(SUBSTR(NVL(p_true, 'TRUE'), 1, 10));
444  	 ELSE
445  	   RETURN TRIM(SUBSTR(NVL(p_false, 'FALSE'), 1, 10));
446  	 END IF;
447    EXCEPTION
448  	 WHEN OTHERS THEN
449  	   sosl_log.exception_log('sosl_util.txt_boolean BOOLEAN', 'SOSL_UTIL', SQLERRM);
450  	   RETURN sosl_constants.GEN_NA_TYPE;
451    END txt_boolean; -- boolean input
452  
453    FUNCTION txt_boolean( p_bool   IN NUMBER
454  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
455  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
456  			   )
457  	 RETURN VARCHAR2
458  	 DETERMINISTIC
459  	 PARALLEL_ENABLE
460    IS
461    BEGIN
462  	 RETURN sosl_util.txt_boolean((p_bool = 1), p_true, p_false);
463    EXCEPTION
464  	 WHEN OTHERS THEN
465  	   sosl_log.exception_log('sosl_util.txt_boolean NUMBER', 'SOSL_UTIL', SQLERRM);
466  	   RETURN sosl_constants.GEN_NA_TYPE;
467    END txt_boolean; -- number input
468  
469    FUNCTION yes_no( p_bool	 IN BOOLEAN
470  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
471  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
472  		      )
473  	 RETURN VARCHAR2
474  	 DETERMINISTIC
475  	 PARALLEL_ENABLE
476    IS
477    BEGIN
478  	 RETURN sosl_util.txt_boolean(p_bool, p_true, p_false);
479    EXCEPTION
480  	 WHEN OTHERS THEN
481  	   sosl_log.exception_log('sosl_util.yes_no BOOLEAN', 'SOSL_UTIL', SQLERRM);
482  	   RETURN sosl_constants.GEN_NA_TYPE;
483    END yes_no;
484  
485    FUNCTION yes_no( p_bool	 IN NUMBER
486  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
487  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
488  		      )
489  	 RETURN VARCHAR2
490  	 DETERMINISTIC
491  	 PARALLEL_ENABLE
492    IS
493    BEGIN
494  	 RETURN sosl_util.txt_boolean((p_bool = 1), p_true, p_false);
495    EXCEPTION
496  	 WHEN OTHERS THEN
497  	   sosl_log.exception_log('sosl_util.yes_no NUMBER', 'SOSL_UTIL', SQLERRM);
498  	   RETURN sosl_constants.GEN_NA_TYPE;
499    END yes_no;
500  
501    FUNCTION object_date( p_object_name IN VARCHAR2
502  			   , p_object_type IN VARCHAR2
503  			   )
504  	 RETURN DATE
505    IS
506  	 l_has_object  NUMBER;
507  	 l_return      DATE;
508    BEGIN
509  	 l_return := sosl_constants.GEN_NA_DATE_TYPE;
510  	 SELECT COUNT(*)
511  	   INTO l_has_object
512  	   FROM user_objects
513  	  WHERE object_name = TRIM(UPPER(p_object_name))
514  	    AND object_type = TRIM(UPPER(p_object_type))
515  	 ;
516  	 -- only if we have exactly one object
517  	 IF l_has_object = 1
518  	 THEN
519  	   SELECT last_ddl_time
520  	     INTO l_return
521  	     FROM user_objects
522  	    WHERE object_name = TRIM(UPPER(p_object_name))
523  	      AND object_type = TRIM(UPPER(p_object_type))
524  	   ;
525  	 END IF;
526  	 RETURN l_return;
527    EXCEPTION
528  	 WHEN OTHERS THEN
529  	   sosl_log.exception_log('sosl_util.object_date', 'SOSL_UTIL', SQLERRM);
530  	   RETURN sosl_constants.GEN_NA_DATE_TYPE;
531    END object_date;
532  
533    FUNCTION get_valid_run_state(p_run_state IN NUMBER)
534  	 RETURN NUMBER
535    IS
536    BEGIN
537  	 IF p_run_state IN ( sosl_constants.RUN_STATE_WAITING
538  			   , sosl_constants.RUN_STATE_ENQUEUED
539  			   , sosl_constants.RUN_STATE_STARTED
540  			   , sosl_constants.RUN_STATE_RUNNING
541  			   , sosl_constants.RUN_STATE_FINISHED
542  			   , sosl_constants.RUN_STATE_ERROR
543  			   )
544  	 THEN
545  	   RETURN p_run_state;
546  	 ELSE
547  	   sosl_log.minimal_error_log('sosl_util.get_valid_run_state', 'SOSL_UTIL', 'Run state ' || p_run_state || ' not supported.');
548  	   RETURN sosl_constants.RUN_STATE_ERROR;
549  	 END IF;
550    EXCEPTION
551  	 WHEN OTHERS THEN
552  	   sosl_log.exception_log('sosl_util.get_valid_run_state', 'SOSL_UTIL', SQLERRM);
553  	   RETURN -1;
554    END get_valid_run_state;
555  
556    FUNCTION create_executor( p_executor_name	 IN VARCHAR2
557  			       , p_db_user		 IN VARCHAR2
558  			       , p_function_owner	 IN VARCHAR2
559  			       , p_fn_has_scripts	 IN VARCHAR2
560  			       , p_fn_get_next_script	 IN VARCHAR2
561  			       , p_fn_set_script_status  IN VARCHAR2
562  			       , p_cfg_file		 IN VARCHAR2
563  			       , p_use_mail		 IN NUMBER     DEFAULT 0
564  			       , p_fn_send_db_mail	 IN VARCHAR2   DEFAULT NULL
565  			       , p_executor_description  IN VARCHAR2   DEFAULT NULL
566  			       )
567  	 RETURN NUMBER
568    IS
569  	 PRAGMA AUTONOMOUS_TRANSACTION;
570  	 l_return	     NUMBER;
571  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
572  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.create_executor';
573    BEGIN
574  	 l_return := -1;
575  	 -- leave error checking to trigger
576  	 INSERT INTO sosl_executor_definition
577  	   ( executor_name
578  	   , db_user
579  	   , function_owner
580  	   , fn_has_scripts
581  	   , fn_get_next_script
582  	   , fn_set_script_status
583  	   , cfg_file
584  	   , use_mail
585  	   , fn_send_db_mail
586  	   , executor_description
587  	   )
588  	   VALUES ( p_executor_name
589  		  , p_db_user
590  		  , p_function_owner
591  		  , p_fn_has_scripts
592  		  , p_fn_get_next_script
593  		  , p_fn_set_script_status
594  		  , p_cfg_file
595  		  , p_use_mail
596  		  , p_fn_send_db_mail
597  		  , p_executor_description
598  		  )
599  	   RETURNING executor_id INTO l_return
600  	 ;
601  	 COMMIT;
602  	 sosl_log.minimal_info_log(l_self_caller, l_self_log_category, 'Created new executor: ' || p_executor_name || ' with ID: ' || l_return);
603  	 RETURN l_return;
604    EXCEPTION
605  	 WHEN OTHERS THEN
606  	   -- log the error instead of RAISE
607  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
608  	   RETURN -1;
609    END create_executor;
610  
611    FUNCTION active_state_executor( p_executor_id   IN NUMBER
612  				     , p_active_state  IN NUMBER DEFAULT 0
613  				     )
614  	 RETURN NUMBER
615    IS
616  	 PRAGMA AUTONOMOUS_TRANSACTION;
617  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
618  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.active_state_executor';
619    BEGIN
620  	 -- leave error checking to trigger
621  	 UPDATE sosl_executor_definition
622  	    SET executor_active = p_active_state
623  	  WHERE executor_id = p_executor_id
624  	 ;
625  	 COMMIT;
626  	 sosl_log.minimal_info_log(l_self_caller, l_self_log_category, 'Active state changed for executor id: ' || p_executor_id || ' to: ' || p_active_state);
627  	 RETURN 0;
628    EXCEPTION
629  	 WHEN OTHERS THEN
630  	   -- log the error instead of RAISE
631  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
632  	   RETURN -1;
633    END active_state_executor;
634  
635    FUNCTION review_state_executor( p_executor_id   IN NUMBER
636  				     , p_review_state  IN NUMBER DEFAULT 0
637  				     )
638  	 RETURN NUMBER
639    IS
640  	 PRAGMA AUTONOMOUS_TRANSACTION;
641  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
642  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.review_state_executor';
643    BEGIN
644  	 -- leave error checking to trigger
645  	 UPDATE sosl_executor_definition
646  	    SET executor_reviewed = p_review_state
647  	  WHERE executor_id = p_executor_id
648  	 ;
649  	 COMMIT;
650  	 sosl_log.minimal_info_log(l_self_caller, l_self_log_category, 'Review state changed for executor id: ' || p_executor_id || ' to: ' || p_review_state);
651  	 RETURN 0;
652    EXCEPTION
653  	 WHEN OTHERS THEN
654  	   -- log the error instead of RAISE
655  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
656  	   RETURN -1;
657    END review_state_executor;
658  
659    FUNCTION db_in_time
660  	 RETURN BOOLEAN
661    IS
662  	 l_return	     BOOLEAN;
663  	 l_time_from_cfg     VARCHAR2(4000);
664  	 l_time_to_cfg	     VARCHAR2(4000);
665  	 l_time_from	     DATE;
666  	 l_time_to	     DATE;
667  	 l_time_current      DATE;
668  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
669  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.db_in_time';
670    BEGIN
671  	 l_return := FALSE;
672  	 -- get configured times
673  	 SELECT config_value INTO l_time_from_cfg FROM sosl_config WHERE config_name = 'SOSL_START_JOBS';
674  	 SELECT config_value INTO l_time_to_cfg FROM sosl_config WHERE config_name = 'SOSL_STOP_JOBS';
675  	 l_time_from	 := TO_DATE(l_time_from_cfg, 'HH24:MI');
676  	 l_time_to	 := TO_DATE(l_time_to_cfg, 'HH24:MI');
677  	 l_time_current  := TO_DATE(TO_CHAR(SYSDATE, 'HH24:MI'), 'HH24:MI');
678  	 IF l_time_from > l_time_to
679  	 THEN
680  	   -- add a day if daybreak
681  	   l_time_to := l_time_to + 1;
682  	   -- check current, if lower than from add a day
683  	   IF l_time_current < l_time_from
684  	   THEN
685  	     l_time_current := l_time_current +1;
686  	   END IF;
687  	 END IF;
688  	 IF	l_time_current >= l_time_from
689  	    AND l_time_current <= l_time_to
690  	 THEN
691  	   l_return := TRUE;
692  	 ELSE
693  	   l_return := FALSE;
694  	 END IF;
695  	 RETURN l_return;
696    EXCEPTION
697  	 WHEN OTHERS THEN
698  	   -- log the error instead of RAISE
699  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
700  	   RETURN FALSE;
701    END db_in_time;
702  
703    FUNCTION cleanup_logs(p_older_than IN NUMBER DEFAULT 7)
704  	 RETURN NUMBER
705    IS
706    BEGIN
707  	 RETURN -1;
708    END cleanup_logs;
709  
710    FUNCTION cleanup_queue(p_older_than IN NUMBER DEFAULT 7)
711  	 RETURN NUMBER
712    IS
713    BEGIN
714  	 RETURN -1;
715    END cleanup_queue;
716  
717  END;
718  /

Package body created.

SQL> -- packages depending on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_sys.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- main package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl_sys
  2  AS
  3  
  4    /* FUNCTION SOSL_SYS.GET_VALID_EXECUTOR_CNT
  5    * Determines the count of all valid executors. A valid executor is defined as an executor that is
  6    * marked as active and reviewed.
  7    *
  8    * @return The total count of all valid executors or -1 on errors.
  9    */
 10    FUNCTION get_valid_executor_cnt
 11  	 RETURN NUMBER
 12    ;
 13  
 14    /* FUNCTION SOSL_SYS.GET_WAITING_CNT
 15    * Determines the count of all scripts in the run queue with status WAITING.
 16    *
 17    * @return The count of all waiting scripts in the run queue or -1 on errors.
 18    */
 19    FUNCTION get_waiting_cnt
 20  	 RETURN NUMBER
 21    ;
 22  
 23    /* FUNCTION SOSL_SYS.GET_WAITING_CNT
 24    * Determines the count of all scripts of an executor in the run queue with status WAITING.
 25    *
 26    * @param p_executor_id The executor id to get all scripts in the run queue with status WAITING.
 27    *
 28    * @return The count of all waiting scripts in the run queue or -1 on errors.
 29    */
 30    FUNCTION get_waiting_cnt(p_executor_id IN NUMBER)
 31  	 RETURN NUMBER
 32    ;
 33  
 34    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_HAS_SCRIPTS
 35    * Deactivates all executors using the given function owner and function for has_scripts.
 36    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 37    * that throw exceptions or errors on calling them. Errors will be logged. SOSL schema and role
 38    * admins are ignored.
 39    *
 40    * @param p_function_owner The owner of the has_scripts function definition.
 41    * @param p_fn_has_scripts The defined script call for has_scripts.
 42    * @param p_log_reason A detailed reason why executor has be deactivated.
 43    *
 44    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 45    */
 46    FUNCTION deactivate_by_fn_has_scripts( p_function_owner IN VARCHAR2
 47  					    , p_fn_has_scripts IN VARCHAR2
 48  					    , p_log_reason     IN VARCHAR2
 49  					    )
 50  	 RETURN BOOLEAN
 51    ;
 52  
 53    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_GET_NEXT_SCRIPT
 54    * Deactivates all executors using the given function owner and function for get_next_script.
 55    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 56    * that throw exceptions or errors on calling them. Errors will be logged. SOSL schema and role
 57    * admins are ignored.
 58    *
 59    * @param p_function_owner The owner of the get_next_script function definition.
 60    * @param p_fn_get_next_script The defined script call for get_next_script.
 61    * @param p_log_reason A detailed reason why executor has be deactivated.
 62    *
 63    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 64    */
 65    FUNCTION deactivate_by_fn_get_next_script( p_function_owner     IN VARCHAR2
 66  						, p_fn_get_next_script IN VARCHAR2
 67  						, p_log_reason	       IN VARCHAR2
 68  						)
 69  	 RETURN BOOLEAN
 70    ;
 71  
 72    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_SET_SCRIPT_STATUS
 73    * Deactivates all executors using the given function owner and function for set_script_status.
 74    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 75    * that throw exceptions or errors on calling them. Errors will be logged. SOSL schema and role
 76    * admins are ignored.
 77    *
 78    * @param p_function_owner The owner of the set_script_status function definition.
 79    * @param p_fn_set_script_status The defined script call for set_script_status.
 80    * @param p_log_reason A detailed reason why executor has be deactivated.
 81    *
 82    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 83    */
 84    FUNCTION deactivate_by_fn_set_script_status( p_function_owner	   IN VARCHAR2
 85  						  , p_fn_set_script_status IN VARCHAR2
 86  						  , p_log_reason	   IN VARCHAR2
 87  						  )
 88  	 RETURN BOOLEAN
 89    ;
 90  
 91    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_SEND_DB_MAIL
 92    * Deactivates all executors using the given function owner and function for send_db_mail.
 93    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 94    * that throw exceptions or errors on calling them. Errors will be logged. SOSL schema and role
 95    * admins are ignored.
 96    *
 97    * @param p_function_owner The owner of the send_db_mail function definition.
 98    * @param p_fn_send_db_mail The defined script call for send_db_mail.
 99    * @param p_log_reason A detailed reason why executor has be deactivated.
100    *
101    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
102    */
103    FUNCTION deactivate_by_fn_send_db_mail( p_function_owner  IN VARCHAR2
104  					     , p_fn_send_db_mail IN VARCHAR2
105  					     , p_log_reason	 IN VARCHAR2
106  					     )
107  	 RETURN BOOLEAN
108    ;
109  
110    /* FUNCTION SOSL_SYS.BUILD_SCRIPT_CALL
111    * Builds a SELECT FROM dual statement with the given function name and,
112    * if NOT NULL, function owner that can be executed dynamically. The return values and
113    * types are not checked and must be handled by the caller. By SOSL default the function
114    * owner is set and NOT NULL. Anyway this functions handles also NULL on function owner.
115    *
116    * WORKS ONLY FOR FUNCTION WITHOUT PARAMETER, e.g. has_scripts and get_next_script.
117    *
118    * BE AWARE that oracle cannot distinguish between package functions where the package is named
119    * like the schema, if names are equal, e.g. if a package exists, called SOSL, like the schema SOSL,
120    * Oracle would search with SOSL.myfunction not a function in the SOSL schema, it would search
121    * myfunction in the package SOSL if executed dynamically.
122    *
123    * @param p_function_owner If set, the function owner of the function. Will prefix the call.
124    * @param p_function_name The name of the function or package function.
125    *
126    * @return A statement to retrieve the function call e.g. SELECT owner.function FROM dual.
127    */
128    FUNCTION build_script_call( p_function_owner  IN VARCHAR2
129  				 , p_function_name   IN VARCHAR2
130  				 )
131  	 RETURN VARCHAR2
132    ;
133  
134    /* FUNCTION SOSL_SYS.BUILD_SIGNAL_CALL
135    * Builds a SELECT FROM dual statement with the given function name and, if NOT NULL, function owner that can be
136    * executed dynamically and the given parameter. The return values and
137    * types are not checked and must be handled by the caller. By SOSL default the function
138    * owner is set and NOT NULL. Anyway this functions handles also NULL on function owner.
139    *
140    * WORKS ONLY FOR FUNCTION WITH DEFINED PARAMETER, e.g. set_script_status and send_db_mail.
141    *
142    * BE AWARE that oracle cannot distinguish between package functions where the package is named
143    * like the schema, if names are equal, e.g. if a package exists, called SOSL, like the schema SOSL,
144    * Oracle would search with SOSL.myfunction not a function in the SOSL schema, it would search
145    * myfunction in the package SOSL if executed dynamically.
146    *
147    * @param p_function_owner If set, the function owner of the function. Will prefix the call.
148    * @param p_function_name The name of the function or package function.
149    * @param p_run_id The first function parameter representing the run id.
150    * @param p_status The second function parameter representing the status that should be set.
151    *
152    * @return A statement to retrieve the function call e.g. SELECT owner.function(1, 0) FROM dual.
153    */
154    FUNCTION build_signal_call( p_function_owner  IN VARCHAR2
155  				 , p_function_name   IN VARCHAR2
156  				 , p_run_id	     IN NUMBER
157  				 , p_status	     IN NUMBER
158  				 )
159  	 RETURN VARCHAR2
160    ;
161  
162    /* FUNCTION SOSL_SYS.GET_HAS_SCRIPT_CNT
163    * Determines the count result of the defined has_script functions for the given function
164    * owner and function name.
165    * Failures on specific executors are only considered, if none of the defined functions
166    * could be executed without errors. Defined scripts will be executed dynamically. Make
167    * sure that has_scripts executes fast, especially if more than one executor is active.
168    *
169    * ATTENTION Will deactivate all executors with scripts throwing execptions!
170    *
171    * @param p_function_name The function to execute for getting the payload. Package functions allowed.
172    * @param p_function_owner The function owner of the function to execute.
173    *
174    * @return The count result of the has_scripts function or -1 on severe errors.
175    */
176    FUNCTION get_has_script_cnt( p_function_name  IN VARCHAR2
177  				  , p_function_owner IN VARCHAR2
178  				  )
179  	 RETURN NUMBER
180    ;
181  
182    /* FUNCTION SOSL_SYS.GET_HAS_SCRIPT_CNT
183    * Determines the count result of all defined has_script functions of valid executors.
184    * Failures on specific executors are only considered, if none of the defined functions
185    * could be executed without errors. Defined scripts will be executed dynamically. Make
186    * sure that has_scripts executes fast, especially if more than one executor is active.
187    *
188    * Will only execute unique functions. If different executors share the same function owner
189    * and function definition, then the function is only executed once and not per executor.
190    * Call syntax is functionOwner.functionName where functionName can also be a package call.
191    *
192    * ATTENTION Will deactivate all executors with scripts throwing execptions!
193    *
194    * @return The total count of all defined has_scripts function or -1 on severe errors.
195    */
196    FUNCTION get_has_script_cnt
197  	 RETURN NUMBER
198    ;
199  
200    /* FUNCTION SOSL_SYS.IS_EXECUTOR_VALID
201    * Checks if the given executor id is valid in sense of active and reviewed. Errors will be logged.
202    *
203    * @param p_executor_id The id of the executor to check if the executor is active and reviewed.
204    *
205    * @return If executor exists, is reviewed and active, returns TRUE otherwise FALSE, also in case of errors.
206    */
207    FUNCTION is_executor_valid(p_executor_id IN NUMBER)
208  	 RETURN BOOLEAN
209    ;
210  
211    /* FUNCTION SOSL_SYS.IS_EXECUTOR
212    * Checks if the given executor id exists in SOSL_EXECUTOR_DEFINITION. Errors will be logged.
213    *
214    * @param p_executor_id The id of the executor to check.
215    *
216    * @return If executor exists returns TRUE otherwise FALSE, also in case of errors.
217    */
218    FUNCTION is_executor(p_executor_id IN NUMBER)
219  	 RETURN BOOLEAN
220    ;
221  
222    /**
223    * This package contains the main functions and procedures used by the Simple Oracle Script Loader to handle executors and scripts.
224    * It is not allowed to use this package for function assignments in SOSL_EXECUTOR_DEFINITION.
225    */
226  
227    /*FUNCTION SOSL_SYS.HAS_VALID_EXECUTORS
228    * Checks if any valid executor (active and reviewed) exists. Errors get logged, return on error is FALSE.
229    *
230    * @return Return TRUE if at least one active and reviewed executor exists, otherwise FALSE.
231    */
232    FUNCTION has_valid_executors
233  	 RETURN BOOLEAN
234    ;
235  
236    /* FUNCTION SOSL_SYS.HAS_SCRIPTS
237    * This function will be used by the wrapper function SOSL_SERVER.HAS_SCRIPTS.
238    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
239    * return a number greater or equal to 0 as well as messages waiting in SOSL_RUN_QUEUE to be processed. Errors will get logged.
240    *
241    * @return The total amount of scripts waiting for processing or -1 on unhandled exceptions/all functions have errors.
242    */
243    FUNCTION has_scripts
244  	 RETURN NUMBER
245    ;
246  
247    /* FUNCTION SOSL_SYS.HAS_RUN_ID
248    * Checks if a given run id exists. Errors get logged.
249    *
250    * @param p_run_id The run id to verify.
251    *
252    * @return TRUE if run id exists otherwise FALSE.
253    */
254    FUNCTION has_run_id(p_run_id IN NUMBER)
255  	 RETURN BOOLEAN
256    ;
257  
258    /* FUNCTION SOSL_SYS.GET_RUN_STATE
259    * Return the current run state for a given run id. Errors get logged.
260    *
261    * @param p_run_id The run id to get the run state for.
262    *
263    * @return On success the current run state or -1 on errors.
264    */
265    FUNCTION get_run_state(p_run_id IN NUMBER)
266  	 RETURN NUMBER
267    ;
268  
269    /* FUNCTION SOSL_SYS.GET_PAYLOAD
270    * Builds a SOSL_PAYLOAD object from the given run id.
271    *
272    * @param p_run_id The run id to get the SOSL_PAYLOAD object for.
273    *
274    * @return On success a valid SOSL_PAYLOAD object or NULL on errors.
275    */
276    FUNCTION get_payload(p_run_id IN NUMBER)
277  	 RETURN SOSL_PAYLOAD
278    ;
279  
280    /* FUNCTION SOSL_SYS.SIGNAL_STATUS_CHANGE
281    * Uses the defined executor from given run id to execute the defined interface function for set_script_status.
282    * The given run id must be valid, as well as the defined function for set_script_status. Otherwise the executor is deactivated.
283    * If mail is activated, will also call the mail functions, errors on mail are logged and ignored (will not lead to FALSE return value).
284    *
285    * @param p_run_id The valid run id to signal state changes.
286    * @param p_status A valid run state.
287    *
288    * @return TRUE if run state successfully signalled otherwise FALSE.
289    */
290    FUNCTION signal_status_change( p_run_id IN NUMBER
291  				    , p_status IN NUMBER
292  				    )
293  	 RETURN BOOLEAN
294    ;
295  
296    /* FUNCTION SOSL_SYS.SET_RUN_STATE
297    * Sets the given run state in SOSL_RUN_QUEUE.
298    *
299    * Run states must follow the state hierarchy: WAITING, ENQUEUED, STARTED, RUNNING, FINISHED. Every state allows to set the
300    * state to ERROR or to the following state. Wrong state hierarchy will lead to run state ERROR. If state is equal to current
301    * state, no change will take place.
302    *
303    * @param p_run_id The valid run id to update.
304    * @param p_status A valid run state.
305    *
306    * @return TRUE if run state successfully updated otherwise FALSE.
307    */
308    FUNCTION set_run_state( p_run_id IN NUMBER
309  			     , p_status IN NUMBER
310  			     )
311  	 RETURN BOOLEAN
312    ;
313  
314    /* FUNCTION SOSL_SYS.SET_SCRIPT_STATUS
315    * This function will be used by wrapper functions in SOSL_SERVER package. It will first set the status of the script
316    * associated to the given run id in SOSL_RUN_QUEUE and then signal the state to all defined set_script_status functions.
317    * Invalid status will lead to run state ERROR used. Errors will get logged. Invalid functions will deactivate the related
318    * executors. If at least one status could be set successfully, it will return success (0).
319    *
320    * Run states must follow the state hierarchy: WAITING, ENQUEUED, STARTED, RUNNING, FINISHED. Every state allows to set the
321    * state to ERROR or to the following state. Wrong state hierarchy will lead to run state ERROR. If state is equal to current
322    * state, no change will take place.
323    *
324    * @param p_run_id The valid run id of the script that should change run state.
325    * @param p_status A valid status as defined in SOSL_CONSTANTS for run states.
326    *
327    * @return Return 0 if successful executed otherwise -1.
328    */
329    FUNCTION set_script_status( p_run_id IN NUMBER
330  				 , p_status IN NUMBER
331  				 )
332  	 RETURN NUMBER
333    ;
334  
335    /* FUNCTION SOSL_SYS.REGISTER_NEXT_SCRIPT
336    * Fetches the PAYLOAD from a given configured function for SOSL_SERVER.GET_NEXT_SCRIPT and stores it in SOSL_RUN_QUEUE with the
337    * status WAITING. On errors, if sufficient data are available, the next script information is stored with status ERROR.
338    * All executors using a function with errors will get deactivated.
339    *
340    * @param p_function_name The function to execute for getting the payload. Package functions allowed.
341    * @param p_function_owner The function owner of the function to execute.
342    *
343    * @return TRUE if fetch was successful, otherwise FALSE.
344    */
345    FUNCTION register_next_script( p_function_name  IN VARCHAR2
346  				    , p_function_owner IN VARCHAR2
347  				    )
348  	 RETURN BOOLEAN
349    ;
350  
351    /* FUNCTION SOSL_SYS.REGISTER_WAITING
352    * Registers all waiting scripts available by defined GET_NEXT_SCRIPT function and persisting them in SOSL_RUN_QUEUE.
353    * State may be WAITING or ERROR, if errors occured and SOSL_PAYLOAD has usable values. Errors get logged.
354    *
355    * @return TRUE if successfully registered any waiting script, otherwise FALSE.
356    */
357    FUNCTION register_waiting
358  	 RETURN BOOLEAN
359    ;
360  
361    /* FUNCTION SOSL_SYS.FETCH_NEXT_RUN_ID
362    * Gets the next available RUN_ID from scripts with status WAITING in SOSL_RUN_QUEUE. Mainly sorted by create date but on
363    * similar create date randomly.
364    *
365    * @return The RUN_ID of the next script to execute or -1 on errors.
366    */
367    FUNCTION fetch_next_run_id
368  	 RETURN NUMBER
369    ;
370  
371    /* FUNCTION SOSL_SYS.GET_NEXT_SCRIPT
372    * This function will be used by the wrapper function SOSL_SERVER.GET_NEXT_SCRIPT.
373    * It collects from all executors the next script to execute, queues them in SOSL_RUN_QUEUE and then fetches the first script in the
374    * run queue as next script to execute. If no scripts are available or on errors, the function will return -1.
375    * Errors will be logged. From interface functions it excepts the return type SOSL_PAYLOAD.
376    *
377    * @return The next script reference as RUN_ID from SOSL_RUN_QUEUE, containing run id that can be related to executor, external script id and scriptfile.
378    */
379    FUNCTION get_next_script
380  	 RETURN NUMBER
381    ;
382  
383  END;
384  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_sys.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_sys
  2  AS
  3    -- for description see header file
  4    FUNCTION get_valid_executor_cnt
  5  	 RETURN NUMBER
  6    IS
  7  	 l_return NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*)
 10  	   INTO l_return
 11  	   FROM sosl_executor_definition
 12  	  WHERE executor_active   = sosl_constants.NUM_YES
 13  	    AND executor_reviewed = sosl_constants.NUM_YES
 14  	 ;
 15  	 RETURN l_return;
 16    EXCEPTION
 17  	 WHEN OTHERS THEN
 18  	   -- log the error instead of RAISE
 19  	   sosl_log.exception_log('sosl_sys.get_valid_executor_cnt', 'SOSL_SYS', SQLERRM);
 20  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 21  	   RETURN -1;
 22    END get_valid_executor_cnt;
 23  
 24    FUNCTION get_waiting_cnt
 25  	 RETURN NUMBER
 26    IS
 27  	 l_return NUMBER;
 28    BEGIN
 29  	 SELECT COUNT(*)
 30  	   INTO l_return
 31  	   FROM sosl_run_queue
 32  	  WHERE run_state = sosl_constants.RUN_STATE_WAITING
 33  	 ;
 34  	 RETURN l_return;
 35    EXCEPTION
 36  	 WHEN OTHERS THEN
 37  	   -- log the error instead of RAISE
 38  	   sosl_log.exception_log('sosl_sys.get_waiting_cnt', 'SOSL_SYS', SQLERRM);
 39  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 40  	   RETURN -1;
 41    END get_waiting_cnt;
 42  
 43    FUNCTION get_waiting_cnt(p_executor_id IN NUMBER)
 44  	 RETURN NUMBER
 45    IS
 46  	 l_return NUMBER;
 47    BEGIN
 48  	 SELECT COUNT(*)
 49  	   INTO l_return
 50  	   FROM sosl_run_queue
 51  	  WHERE run_state   = sosl_constants.RUN_STATE_WAITING
 52  	    AND executor_id = p_executor_id
 53  	 ;
 54  	 RETURN l_return;
 55    EXCEPTION
 56  	 WHEN OTHERS THEN
 57  	   -- log the error instead of RAISE
 58  	   sosl_log.exception_log('sosl_sys.get_waiting_cnt executor', 'SOSL_SYS', SQLERRM);
 59  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 60  	   RETURN -1;
 61    END get_waiting_cnt;
 62  
 63    FUNCTION deactivate_by_fn_has_scripts( p_function_owner IN VARCHAR2
 64  					    , p_fn_has_scripts IN VARCHAR2
 65  					    , p_log_reason     IN VARCHAR2
 66  					    )
 67  	 RETURN BOOLEAN
 68    IS
 69  	 PRAGMA AUTONOMOUS_TRANSACTION;
 70  	 l_return	     BOOLEAN;
 71  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
 72  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_has_scripts';
 73  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
 74  			      , cp_function_name  IN VARCHAR2
 75  			      )
 76  	 IS
 77  	   SELECT executor_id
 78  		, function_owner
 79  	     FROM sosl_executor_definition
 80  	    WHERE function_owner = cp_function_owner
 81  	      AND fn_has_scripts = cp_function_name
 82  	      -- always exclude current SOSL user
 83  	      AND function_owner NOT IN (SELECT config_value FROM sosl_config WHERE config_name = 'SOSL_SCHEMA')
 84  	 ;
 85    BEGIN
 86  	 l_return := TRUE;
 87  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
 88  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_has_scripts)
 89  	 LOOP
 90  	   -- disable executor
 91  	   UPDATE sosl_executor_definition
 92  	      SET executor_active    = sosl_constants.NUM_NO
 93  		, executor_reviewed  = sosl_constants.NUM_NO
 94  	    WHERE executor_id = rec.executor_id
 95  	   ;
 96  	   COMMIT;
 97  	   -- revoke grants for function owner
 98  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
 99  	   THEN
100  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
101  	     -- if one fails, it all is in error
102  	     l_return := FALSE;
103  	   END IF;
104  	 END LOOP;
105  	 RETURN l_return;
106    EXCEPTION
107  	 WHEN OTHERS THEN
108  	   -- log the error instead of RAISE
109  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
110  	   RETURN FALSE;
111    END deactivate_by_fn_has_scripts;
112  
113    FUNCTION deactivate_by_fn_get_next_script( p_function_owner     IN VARCHAR2
114  						, p_fn_get_next_script IN VARCHAR2
115  						, p_log_reason	       IN VARCHAR2
116  						)
117  	 RETURN BOOLEAN
118    IS
119  	 PRAGMA AUTONOMOUS_TRANSACTION;
120  	 l_return	     BOOLEAN;
121  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
122  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_get_next_script';
123  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
124  			      , cp_function_name  IN VARCHAR2
125  			      )
126  	 IS
127  	   SELECT executor_id
128  		, function_owner
129  	     FROM sosl_executor_definition
130  	    WHERE function_owner     = cp_function_owner
131  	      AND fn_get_next_script = cp_function_name
132  	      -- always exclude current SOSL user
133  	      AND function_owner NOT IN (SELECT config_value FROM sosl_config WHERE config_name = 'SOSL_SCHEMA')
134  	 ;
135    BEGIN
136  	 l_return := TRUE;
137  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
138  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_get_next_script)
139  	 LOOP
140  	   -- disable executor
141  	   UPDATE sosl_executor_definition
142  	      SET executor_active    = sosl_constants.NUM_NO
143  		, executor_reviewed  = sosl_constants.NUM_NO
144  	    WHERE executor_id = rec.executor_id
145  	   ;
146  	   COMMIT;
147  	   -- revoke grants for function owner
148  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
149  	   THEN
150  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
151  	     -- if one fails, it all is in error
152  	     l_return := FALSE;
153  	   END IF;
154  	 END LOOP;
155  	 RETURN l_return;
156    EXCEPTION
157  	 WHEN OTHERS THEN
158  	   -- log the error instead of RAISE
159  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
160  	   RETURN FALSE;
161    END deactivate_by_fn_get_next_script;
162  
163    FUNCTION deactivate_by_fn_set_script_status( p_function_owner	   IN VARCHAR2
164  						  , p_fn_set_script_status IN VARCHAR2
165  						  , p_log_reason	   IN VARCHAR2
166  						  )
167  	 RETURN BOOLEAN
168    IS
169  	 PRAGMA AUTONOMOUS_TRANSACTION;
170  	 l_return	     BOOLEAN;
171  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
172  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_set_script_status';
173  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
174  			      , cp_function_name  IN VARCHAR2
175  			      )
176  	 IS
177  	   SELECT executor_id
178  		, function_owner
179  	     FROM sosl_executor_definition
180  	    WHERE function_owner       = cp_function_owner
181  	      AND fn_set_script_status = cp_function_name
182  	      -- always exclude current SOSL user
183  	      AND function_owner NOT IN (SELECT config_value FROM sosl_config WHERE config_name = 'SOSL_SCHEMA')
184  	 ;
185    BEGIN
186  	 l_return := TRUE;
187  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
188  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_set_script_status)
189  	 LOOP
190  	   -- disable executor
191  	   UPDATE sosl_executor_definition
192  	      SET executor_active    = sosl_constants.NUM_NO
193  		, executor_reviewed  = sosl_constants.NUM_NO
194  	    WHERE executor_id = rec.executor_id
195  	   ;
196  	   COMMIT;
197  	   -- revoke grants for function owner
198  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
199  	   THEN
200  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
201  	     -- if one fails, it all is in error
202  	     l_return := FALSE;
203  	   END IF;
204  	 END LOOP;
205  	 RETURN l_return;
206    EXCEPTION
207  	 WHEN OTHERS THEN
208  	   -- log the error instead of RAISE
209  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
210  	   RETURN FALSE;
211    END deactivate_by_fn_set_script_status;
212  
213    FUNCTION deactivate_by_fn_send_db_mail( p_function_owner  IN VARCHAR2
214  					     , p_fn_send_db_mail IN VARCHAR2
215  					     , p_log_reason	 IN VARCHAR2
216  					     )
217  	 RETURN BOOLEAN
218    IS
219  	 PRAGMA AUTONOMOUS_TRANSACTION;
220  	 l_return	     BOOLEAN;
221  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
222  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_send_db_mail';
223  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
224  			      , cp_function_name  IN VARCHAR2
225  			      )
226  	 IS
227  	   SELECT executor_id
228  		, function_owner
229  	     FROM sosl_executor_definition
230  	    WHERE function_owner  = cp_function_owner
231  	      AND fn_send_db_mail = cp_function_name
232  	      -- always exclude current SOSL user
233  	      AND function_owner NOT IN (SELECT config_value FROM sosl_config WHERE config_name = 'SOSL_SCHEMA')
234  	 ;
235    BEGIN
236  	 l_return := TRUE;
237  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
238  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_send_db_mail)
239  	 LOOP
240  	   -- disable executor
241  	   UPDATE sosl_executor_definition
242  	      SET executor_active    = sosl_constants.NUM_NO
243  		, executor_reviewed  = sosl_constants.NUM_NO
244  	    WHERE executor_id = rec.executor_id
245  	   ;
246  	   COMMIT;
247  	   -- revoke grants for function owner
248  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
249  	   THEN
250  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
251  	     -- if one fails, it all is in error
252  	     l_return := FALSE;
253  	   END IF;
254  	 END LOOP;
255  	 RETURN l_return;
256    EXCEPTION
257  	 WHEN OTHERS THEN
258  	   -- log the error instead of RAISE
259  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
260  	   RETURN FALSE;
261    END deactivate_by_fn_send_db_mail;
262  
263    FUNCTION build_script_call( p_function_owner  IN VARCHAR2
264  				 , p_function_name   IN VARCHAR2
265  				 )
266  	 RETURN VARCHAR2
267    IS
268  	 l_statement VARCHAR2(1024);
269    BEGIN
270  	 IF p_function_owner IS NOT NULL
271  	 THEN
272  	   l_statement := 'SELECT ' || p_function_owner || '.' || p_function_name || ' FROM dual';
273  	 ELSE
274  	   l_statement := 'SELECT ' || p_function_name || ' FROM dual';
275  	 END IF;
276  	 RETURN l_statement;
277    EXCEPTION
278  	 WHEN OTHERS THEN
279  	   -- log the error instead of RAISE
280  	   sosl_log.exception_log('sosl_sys.build_script_call', 'SOSL_SYS', SQLERRM);
281  	   RETURN 'SELECT -1 FROM dual';
282    END build_script_call;
283  
284    FUNCTION build_signal_call( p_function_owner  IN VARCHAR2
285  				 , p_function_name   IN VARCHAR2
286  				 , p_run_id	     IN NUMBER
287  				 , p_status	     IN NUMBER
288  				 )
289  	 RETURN VARCHAR2
290    IS
291  	 l_statement VARCHAR2(4000);
292    BEGIN
293  	 IF p_function_owner IS NOT NULL
294  	 THEN
295  	   l_statement := 'SELECT ' || p_function_owner || '.' || p_function_name || '(' ||
296  			  TRIM(TO_CHAR(p_run_id)) || ', ' || TRIM(TO_CHAR(p_status)) || ')' ||
297  			  ' FROM dual'
298  	   ;
299  	 ELSE
300  	   l_statement := 'SELECT ' || p_function_name || '(' ||
301  			  TRIM(TO_CHAR(p_run_id)) || ', ' || TRIM(TO_CHAR(p_status)) || ')' ||
302  			  ' FROM dual';
303  	 END IF;
304  	 RETURN l_statement;
305    EXCEPTION
306  	 WHEN OTHERS THEN
307  	   -- log the error instead of RAISE
308  	   sosl_log.exception_log('sosl_sys.build_signal_call', 'SOSL_SYS', SQLERRM);
309  	   RETURN 'SELECT -1 FROM dual';
310    END build_signal_call;
311  
312    FUNCTION get_has_script_cnt( p_function_name  IN VARCHAR2
313  				  , p_function_owner IN VARCHAR2
314  				  )
315  	 RETURN NUMBER
316    IS
317  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
318  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_has_script_cnt function';
319  	 l_count	     NUMBER;
320  	 l_success	     BOOLEAN;
321  	 l_statement	     VARCHAR2(1024);
322    BEGIN
323  	 -- flag to determine if at least one execution was successful
324  	 l_count     := 0;
325  	 l_statement := sosl_sys.build_script_call(p_function_owner, p_function_name);
326  	 BEGIN
327  	   EXECUTE IMMEDIATE l_statement INTO l_count;
328  	 EXCEPTION
329  	   WHEN OTHERS THEN
330  	     sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
331  	     l_count := -1;
332  	 END;
333  	 IF l_count < 0
334  	 THEN
335  	   -- we have errors with this function disable executors using this function
336  	   IF NOT sosl_sys.deactivate_by_fn_has_scripts(p_function_owner, p_function_name, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
337  	   THEN
338  	     -- error situation
339  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || p_function_name || ' function owner ' || p_function_owner);
340  	   END IF;
341  	 END IF;
342  	 RETURN l_count;
343    EXCEPTION
344  	 WHEN OTHERS THEN
345  	   -- log the error instead of RAISE
346  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
347  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
348  	   RETURN -1;
349    END get_has_script_cnt;
350  
351    FUNCTION get_has_script_cnt
352  	 RETURN NUMBER
353    IS
354  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
355  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_has_script_cnt';
356  	 l_total	     NUMBER;
357  	 l_count	     NUMBER;
358  	 l_success	     BOOLEAN;
359  	 l_statement	     VARCHAR2(1024);
360  	 CURSOR cur_fn_has_scripts
361  	 IS
362  	   SELECT function_owner
363  		, fn_has_scripts
364  	     FROM sosl_executor_definition
365  	    WHERE executor_active   = sosl_constants.NUM_YES
366  	      AND executor_reviewed = sosl_constants.NUM_YES
367  	    GROUP BY function_owner
368  		   , fn_has_scripts
369  	 ;
370    BEGIN
371  	 -- flag to determine if at least one execution was successful
372  	 l_success := FALSE;
373  	 l_total   := 0;
374  	 l_count   := 0;
375  	 -- loop through functions
376  	 FOR rec IN cur_fn_has_scripts
377  	 LOOP
378  	   l_statement := sosl_sys.build_script_call(rec.function_owner, rec.fn_has_scripts);
379  	   BEGIN
380  	     EXECUTE IMMEDIATE l_statement INTO l_count;
381  	   EXCEPTION
382  	     WHEN OTHERS THEN
383  	       sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
384  	       l_count := -1;
385  	   END;
386  	   IF l_count < 0
387  	   THEN
388  	     -- we have errors with this function disable executors using this function
389  	     IF NOT sosl_sys.deactivate_by_fn_has_scripts(rec.function_owner, rec.fn_has_scripts, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
390  	     THEN
391  	       -- error situation
392  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || rec.fn_has_scripts || ' function owner ' || rec.function_owner);
393  	     END IF;
394  	   ELSE
395  	     l_success := TRUE;
396  	     l_total   := l_total + l_count;
397  	   END IF;
398  	 END LOOP;
399  	 -- now check if we have at least one function executed with success
400  	 IF NOT l_success
401  	 THEN
402  	   -- we should report the error situation
403  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'No defined has_scripts function is working. Disabled executors.');
404  	   l_total := -1;
405  	 END IF;
406  	 RETURN l_total;
407    EXCEPTION
408  	 WHEN OTHERS THEN
409  	   -- log the error instead of RAISE
410  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
411  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
412  	   RETURN -1;
413    END get_has_script_cnt;
414  
415    FUNCTION is_executor_valid(p_executor_id IN NUMBER)
416  	 RETURN BOOLEAN
417    IS
418  	 l_valid_count NUMBER;
419  	 l_return      BOOLEAN;
420    BEGIN
421  	 l_return := FALSE;
422  	 SELECT COUNT(*)
423  	   INTO l_valid_count
424  	   FROM sosl_executor_definition
425  	  WHERE executor_id	   = p_executor_id
426  	    AND executor_active    = sosl_constants.NUM_YES
427  	    AND executor_reviewed  = sosl_constants.NUM_YES
428  	 ;
429  	 l_return := (l_valid_count != 0);
430  	 RETURN l_return;
431    EXCEPTION
432  	 WHEN OTHERS THEN
433  	   sosl_log.exception_log('sosl_sys.is_executor_valid', 'SOSL_SYS', SQLERRM);
434  	   RETURN FALSE;
435    END is_executor_valid;
436  
437    FUNCTION is_executor(p_executor_id IN NUMBER)
438  	 RETURN BOOLEAN
439    IS
440  	 l_valid_count NUMBER;
441  	 l_return      BOOLEAN;
442    BEGIN
443  	 l_return := FALSE;
444  	 SELECT COUNT(*)
445  	   INTO l_valid_count
446  	   FROM sosl_executor_definition
447  	  WHERE executor_id	   = p_executor_id
448  	 ;
449  	 l_return := (l_valid_count != 0);
450  	 RETURN l_return;
451    EXCEPTION
452  	 WHEN OTHERS THEN
453  	   sosl_log.exception_log('sosl_sys.is_executor', 'SOSL_SYS', SQLERRM);
454  	   RETURN FALSE;
455    END is_executor;
456  
457    FUNCTION has_valid_executors
458  	 RETURN BOOLEAN
459    IS
460  	 l_return	     BOOLEAN;
461  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
462  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.has_valid_executors';
463    BEGIN
464  	 l_return := (sosl_sys.get_valid_executor_cnt > 0);
465  	 RETURN l_return;
466    EXCEPTION
467  	 WHEN OTHERS THEN
468  	   -- log the error instead of RAISE
469  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
470  	   RETURN FALSE;
471    END has_valid_executors;
472  
473    FUNCTION has_scripts
474  	 RETURN NUMBER
475    IS
476  	 l_return	     NUMBER;
477  	 l_waiting	     NUMBER;
478  	 l_defined	     NUMBER;
479  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
480  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.has_scripts';
481    BEGIN
482  	 l_return      := -1;
483  	 IF sosl_sys.has_valid_executors
484  	 THEN
485  	   -- initialize the total count
486  	   l_return := 0;
487  	   -- get count of waiting scripts
488  	   l_waiting := sosl_sys.get_waiting_cnt;
489  	   l_defined := sosl_sys.get_has_script_cnt;
490  	   IF	   l_waiting >= 0
491  	      AND  l_defined >= 0
492  	   THEN
493  	     -- build total
494  	     l_return := l_waiting + l_defined;
495  	   ELSE
496  	     -- report error
497  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Defined functions or run queue in error. Fix problems before expecting valid results');
498  	     l_return := -1;
499  	   END IF;
500  	 ELSE
501  	   -- log no valid executors
502  	   sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, 'Nothing to do, no valid executors. Return 0 scripts available');
503  	   l_return := 0;
504  	 END IF;
505  	 RETURN l_return;
506    EXCEPTION
507  	 WHEN OTHERS THEN
508  	   -- log the error instead of RAISE
509  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
510  	   RETURN -1;
511    END has_scripts;
512  
513    FUNCTION has_run_id(p_run_id IN NUMBER)
514  	 RETURN BOOLEAN
515    IS
516  	 l_return  BOOLEAN;
517  	 l_count   NUMBER;
518    BEGIN
519  	 l_return := FALSE;
520  	 SELECT COUNT(*)
521  	   INTO l_count
522  	   FROM sosl_run_queue
523  	  WHERE run_id = p_run_id
524  	 ;
525  	 l_return := (l_count = 1);
526  	 RETURN l_return;
527    EXCEPTION
528  	 WHEN OTHERS THEN
529  	   -- log the error instead of RAISE
530  	   sosl_log.exception_log('sosl_sys.has_run_id', 'SOSL_SYS', SQLERRM);
531  	   RETURN FALSE;
532    END has_run_id;
533  
534    FUNCTION get_run_state(p_run_id IN NUMBER)
535  	 RETURN NUMBER
536    IS
537  	 l_run_state NUMBER;
538    BEGIN
539  	 IF sosl_sys.has_run_id(p_run_id)
540  	 THEN
541  	   SELECT run_state
542  	     INTO l_run_state
543  	     FROM sosl_run_queue
544  	    WHERE run_id = p_run_id
545  	   ;
546  	 ELSE
547  	   l_run_state := sosl_constants.RUN_STATE_ERROR;
548  	 END IF;
549  	 RETURN l_run_state;
550    EXCEPTION
551  	 WHEN OTHERS THEN
552  	   -- log the error instead of RAISE
553  	   sosl_log.exception_log('sosl_sys.get_run_state', 'SOSL_SYS', SQLERRM);
554  	   RETURN -1;
555    END get_run_state;
556  
557    FUNCTION get_payload(p_run_id IN NUMBER)
558  	 RETURN SOSL_PAYLOAD
559    IS
560  	 l_payload	     SOSL_PAYLOAD;
561  	 l_executor_id	     sosl_run_queue.executor_id%TYPE;
562  	 l_ext_script_id     sosl_run_queue.ext_script_id%TYPE;
563  	 l_script_file	     sosl_run_queue.script_file%TYPE;
564  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
565  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_payload';
566    BEGIN
567  	 l_payload := NULL;
568  	 IF sosl_sys.has_run_id(p_run_id)
569  	 THEN
570  	   SELECT executor_id
571  		, ext_script_id
572  		, script_file
573  	     INTO l_executor_id
574  		, l_ext_script_id
575  		, l_script_file
576  	     FROM sosl_run_queue
577  	    WHERE run_id = p_run_id
578  	   ;
579  	   l_payload := SOSL_PAYLOAD(l_executor_id, l_ext_script_id, l_script_file);
580  	 ELSE
581  	   l_payload := NULL;
582  	   -- log error
583  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid run id ' || p_run_id);
584  	 END IF;
585  	 RETURN l_payload;
586    EXCEPTION
587  	 WHEN OTHERS THEN
588  	   -- log the error instead of RAISE
589  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
590  	   RETURN NULL;
591    END get_payload;
592  
593    FUNCTION signal_status_change( p_run_id IN NUMBER
594  				    , p_status IN NUMBER
595  				    )
596  	 RETURN BOOLEAN
597    IS
598  	 l_return		 BOOLEAN;
599  	 l_num_result		 NUMBER;
600  	 l_function_owner	 sosl_executor_definition.function_owner%TYPE;
601  	 l_fn_set_script_status  sosl_executor_definition.fn_set_script_status%TYPE;
602  	 l_fn_send_db_mail	 sosl_executor_definition.fn_send_db_mail%TYPE;
603  	 l_use_mail		 sosl_executor_definition.use_mail%TYPE;
604  	 l_statement		 VARCHAR2(4000);
605  	 l_self_log_category	 sosl_server_log.log_category%TYPE := 'SOSL_SYS';
606  	 l_self_caller		 sosl_server_log.caller%TYPE	   := 'sosl_sys.signal_status_change';
607    BEGIN
608  	 l_return := FALSE;
609  	 IF sosl_sys.has_run_id(p_run_id)
610  	 THEN
611  	   -- get the defined function to signal the status change
612  	   SELECT sed.function_owner
613  		, sed.fn_set_script_status
614  		, sed.fn_send_db_mail
615  		, sed.use_mail
616  	     INTO l_function_owner
617  		, l_fn_set_script_status
618  		, l_fn_send_db_mail
619  		, l_use_mail
620  	     FROM sosl_run_queue srqu
621  	    INNER JOIN sosl_executor_definition sed
622  	       ON srqu.executor_id = sed.executor_id
623  	    WHERE srqu.run_id = p_run_id
624  	   ;
625  	   l_statement := sosl_sys.build_signal_call(l_function_owner, l_fn_set_script_status, p_run_id, p_status);
626  	   BEGIN
627  	     EXECUTE IMMEDIATE l_statement INTO l_num_result;
628  	     IF l_num_result = sosl_constants.NUM_SUCCESS
629  	     THEN
630  	       l_return := TRUE;
631  	     END IF;
632  	   EXCEPTION
633  	     WHEN OTHERS THEN
634  	       sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
635  	   END;
636  	   IF l_return
637  	   THEN
638  	     -- if mail activated execute also the defined mail function
639  	     IF l_use_mail = sosl_constants.NUM_YES
640  	     THEN
641  	       l_statement := sosl_sys.build_signal_call(l_function_owner, l_fn_send_db_mail, p_run_id, p_status);
642  	       BEGIN
643  		 EXECUTE IMMEDIATE l_statement INTO l_num_result;
644  	       EXCEPTION
645  		 WHEN OTHERS THEN
646  		   sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
647  		   l_num_result := sosl_constants.NUM_ERROR;
648  	       END;
649  	       IF l_num_result = sosl_constants.NUM_ERROR
650  	       THEN
651  		 IF NOT sosl_sys.deactivate_by_fn_send_db_mail(l_function_owner, l_fn_send_db_mail, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
652  		 THEN
653  		   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || l_fn_send_db_mail || ' function owner ' || l_function_owner);
654  		 END IF;
655  	       END IF;
656  	     END IF;
657  	   ELSE
658  	     -- deactivate executors using the set_script_status function
659  	     IF NOT sosl_sys.deactivate_by_fn_set_script_status(l_function_owner, l_fn_set_script_status, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
660  	     THEN
661  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || l_fn_set_script_status || ' function owner ' || l_function_owner);
662  	     END IF;
663  	   END IF;
664  	 END IF;
665  	 RETURN l_return;
666    EXCEPTION
667  	 WHEN OTHERS THEN
668  	   -- log the error instead of RAISE
669  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
670  	   RETURN FALSE;
671    END signal_status_change;
672  
673    FUNCTION set_run_state( p_run_id IN NUMBER
674  			     , p_status IN NUMBER
675  			     )
676  	 RETURN BOOLEAN
677    IS
678  	 PRAGMA AUTONOMOUS_TRANSACTION;
679  	 l_return	     BOOLEAN;
680  	 l_run_state	     INTEGER;
681  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
682  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.set_script_status';
683    BEGIN
684  	 l_return := FALSE;
685  	 l_run_state := sosl_util.get_valid_run_state(p_status);
686  	 IF sosl_sys.has_run_id(p_run_id)
687  	 THEN
688  	   UPDATE sosl_run_queue
689  	      SET run_state = l_run_state
690  	    WHERE run_id = p_run_id
691  	   ;
692  	   COMMIT;
693  	   -- check that state was set successfully
694  	   l_return := (l_run_state = sosl_sys.get_run_state(p_run_id));
695  	 END IF;
696  	 RETURN l_return;
697    EXCEPTION
698  	 WHEN OTHERS THEN
699  	   -- log the error instead of RAISE
700  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
701  	   RETURN FALSE;
702    END set_run_state;
703  
704    FUNCTION set_script_status( p_run_id IN NUMBER
705  				 , p_status IN NUMBER
706  				 )
707  	 RETURN NUMBER
708    IS
709  	 l_return	     NUMBER;
710  	 l_run_state	     INTEGER;
711  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
712  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.set_script_status';
713    BEGIN
714  	 l_return := -1;
715  	 -- check status
716  	 l_run_state := sosl_util.get_valid_run_state(p_status);
717  	 -- check run id
718  	 IF sosl_sys.has_run_id(p_run_id)
719  	 THEN
720  	   -- first set own status, then signal changes
721  	   IF	  sosl_sys.set_run_state(p_run_id, p_status)
722  	      AND sosl_sys.signal_status_change(p_run_id, p_status)
723  	   THEN
724  	     l_return := 0;
725  	   ELSE
726  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not set the run state to ' || p_status || ' for run id ' || p_run_id);
727  	   END IF;
728  	 END IF;
729  	 RETURN l_return;
730    EXCEPTION
731  	 WHEN OTHERS THEN
732  	   -- log the error instead of RAISE
733  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
734  	   RETURN -1;
735    END set_script_status;
736  
737    FUNCTION register_next_script( p_function_name  IN VARCHAR2
738  				    , p_function_owner IN VARCHAR2
739  				    )
740  	 RETURN BOOLEAN
741    IS
742  	 PRAGMA AUTONOMOUS_TRANSACTION;
743  	 l_return	     BOOLEAN;
744  	 l_total	     NUMBER;
745  	 l_count	     NUMBER;
746  	 l_payload	     SOSL_PAYLOAD;
747  	 l_statement	     VARCHAR2(1024);
748  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
749  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.register_next_script';
750  	 -- there might exist more than one associated has_scripts function for get_next_script
751  	 CURSOR cur_get_has_scripts( cp_function_name  IN VARCHAR2
752  				   , cp_function_owner IN VARCHAR2
753  				   )
754  	 IS
755  	   SELECT function_owner
756  		, fn_has_scripts
757  	     FROM sosl_executor_definition
758  	    WHERE executor_active    = sosl_constants.NUM_YES
759  	      AND executor_reviewed  = sosl_constants.NUM_YES
760  	      AND function_owner     = cp_function_owner
761  	      AND fn_get_next_script = cp_function_name
762  	    GROUP BY function_owner
763  		   , fn_has_scripts
764  	 ;
765    BEGIN
766  	 l_return := FALSE;
767  	 -- first check if we have specific results from the associated has_scripts functions
768  	 l_total := 0;
769  	 l_count := 0;
770  	 FOR rec IN cur_get_has_scripts(p_function_name, p_function_owner)
771  	 LOOP
772  	   l_count := sosl_sys.get_has_script_cnt(rec.fn_has_scripts, rec.function_owner);
773  	   IF l_count = -1
774  	   THEN
775  	     l_total := -1;
776  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid has_script function "' || rec.fn_has_scripts || '" for owner "' || rec.function_owner || '".');
777  	   END IF;
778  	   -- make sure that errors are kept
779  	   IF l_count != -1 AND l_total != -1
780  	   THEN
781  	     l_total := l_total + l_count;
782  	   END IF;
783  	 END LOOP;
784  	 -- if the associated has_scripts have available scripts
785  	 IF l_total = -1
786  	 THEN
787  	   -- we have an error already logged
788  	   l_return := FALSE;
789  	 ELSIF l_total > 0
790  	 THEN
791  	   -- we have scripts waiting
792  	   l_statement := sosl_sys.build_script_call(p_function_owner, p_function_name);
793  	   BEGIN
794  	     EXECUTE IMMEDIATE l_statement INTO l_payload;
795  	     IF      sosl_sys.is_executor_valid(l_payload.executor_id)
796  		AND  l_payload.ext_script_id IS NOT NULL
797  		AND  l_payload.script_file   IS NOT NULL
798  	     THEN
799  	       -- valid payload
800  	       INSERT INTO sosl_run_queue
801  		 (executor_id, ext_script_id, script_file)
802  		 VALUES
803  		 (l_payload.executor_id, l_payload.ext_script_id, l_payload.script_file)
804  	       ;
805  	       COMMIT;
806  	       l_return := TRUE;
807  	     ELSE
808  	       -- invalid payload, check if usable and save with error state if possible
809  	       IF     sosl_sys.is_executor(l_payload.executor_id)
810  		  AND l_payload.ext_script_id IS NOT NULL
811  		  AND l_payload.script_file   IS NOT NULL
812  	       THEN
813  		 -- insert the record with error state
814  		 INSERT INTO sosl_run_queue
815  		   (executor_id, ext_script_id, script_file, run_state)
816  		   VALUES
817  		   (l_payload.executor_id, l_payload.ext_script_id, l_payload.script_file, sosl_constants.RUN_STATE_ERROR)
818  		 ;
819  		 COMMIT;
820  	       END IF;
821  	       -- log the error
822  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'SOSL_PAYLOAD has invalid content, either the executor "' || l_payload.executor_id || '" is not valid or payload fields are NULL. External script id "' || l_payload.ext_script_id || '" script file "' || l_payload.script_file || '".');
823  	       l_return := FALSE;
824  	     END IF;
825  	   EXCEPTION
826  	     WHEN OTHERS THEN
827  	       sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
828  	       l_return := FALSE;
829  	   END;
830  	 ELSE
831  	   -- do not care, not having scripts is okay, maybe queue or other executor
832  	   l_return := TRUE;
833  	 END IF;
834  	 -- if we have FALSE return value, deactivate the executors for the given function
835  	 IF NOT l_return
836  	 THEN
837  	   IF NOT sosl_sys.deactivate_by_fn_get_next_script(p_function_owner, p_function_name, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
838  	   THEN
839  	     -- log error
840  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || p_function_name || ' function owner ' || p_function_owner);
841  	   END IF;
842  	 END IF;
843  	 RETURN l_return;
844    EXCEPTION
845  	 WHEN OTHERS THEN
846  	   -- log the error instead of RAISE
847  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
848  	   RETURN FALSE;
849    END register_next_script;
850  
851    FUNCTION register_waiting
852  	 RETURN BOOLEAN
853    IS
854  	 l_return	     BOOLEAN;
855  	 l_success	     BOOLEAN;
856  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
857  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.register_waiting';
858  	 CURSOR cur_fn_get_next_script
859  	 IS
860  	   SELECT function_owner
861  		, fn_get_next_script
862  	     FROM sosl_executor_definition
863  	    WHERE executor_active   = sosl_constants.NUM_YES
864  	      AND executor_reviewed = sosl_constants.NUM_YES
865  	    GROUP BY function_owner
866  		   , fn_get_next_script
867  	 ;
868    BEGIN
869  	 l_return  := FALSE;
870  	 l_success := FALSE;
871  	 FOR rec IN cur_fn_get_next_script
872  	 LOOP
873  	   IF sosl_sys.register_next_script(rec.fn_get_next_script, rec.function_owner)
874  	   THEN
875  	     l_success := TRUE;
876  	   END IF;
877  	 END LOOP;
878  	 -- if at least one script was registered successfully, errors may be seen in the logs of register_next_script
879  	 IF l_success
880  	 THEN
881  	   l_return := TRUE;
882  	 ELSE
883  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Error fetching get_next_script functions. No defined function works correctly.');
884  	   l_return := FALSE;
885  	 END IF;
886  	 RETURN l_return;
887    EXCEPTION
888  	 WHEN OTHERS THEN
889  	   -- log the error instead of RAISE
890  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
891  	   RETURN FALSE;
892    END register_waiting;
893  
894    FUNCTION fetch_next_run_id
895  	 RETURN NUMBER
896    IS
897  	 l_run_id	     NUMBER;
898  	 l_count	     NUMBER;
899  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
900  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.fetch_next_run_id';
901  	 -- get waiting run id, oldest first
902  	 CURSOR cur_run_id
903  	 IS
904  	   SELECT run_id
905  	     FROM sosl_run_queue
906  	    WHERE run_state = sosl_constants.RUN_STATE_WAITING
907  	    ORDER BY created
908  	 ;
909    BEGIN
910  	 l_run_id := -1;
911  	 SELECT COUNT(*) INTO l_count FROM sosl_run_queue WHERE run_state = sosl_constants.RUN_STATE_WAITING;
912  	 IF l_count > 0
913  	 THEN
914  	   OPEN cur_run_id;
915  	   FETCH cur_run_id INTO l_run_id;
916  	   CLOSE cur_run_id;
917  	 END IF;
918  	 RETURN l_run_id;
919    EXCEPTION
920  	 WHEN OTHERS THEN
921  	   -- log the error instead of RAISE
922  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
923  	   RETURN -1;
924    END fetch_next_run_id;
925  
926    FUNCTION get_next_script
927  	 RETURN NUMBER
928    IS
929  	 l_run_id	     NUMBER;
930  	 l_state_result      NUMBER;
931  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
932  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_next_script';
933    BEGIN
934  	 l_run_id := -1;
935  	 -- if we have scripts
936  	 IF sosl_sys.has_scripts > 0
937  	 THEN
938  	   -- select all valid executors and get their results, store results in SOSL_RUN_QUEUE.
939  	   IF NOT sosl_sys.register_waiting
940  	   THEN
941  	     -- probably an error with defined functions, log the error
942  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Defined functions in error, not registered any new script.');
943  	   END IF;
944  	   -- as we should have scripts, the run queue still may have scripts even if register failed
945  	   l_run_id := sosl_sys.fetch_next_run_id;
946  	   IF l_run_id = sosl_constants.NUM_ERROR
947  	   THEN
948  	     -- log the error
949  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to fetch next run id.');
950  	   ELSE
951  	     -- mark run id as enqueued
952  	     l_state_result := sosl_sys.set_script_status(l_run_id, sosl_constants.RUN_STATE_ENQUEUED);
953  	     IF l_state_result = sosl_constants.NUM_ERROR
954  	     THEN
955  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not update run state to ENQUEUED for run id: ' || l_run_id);
956  	     END IF;
957  	   END IF;
958  	 END IF;
959  	 RETURN l_run_id;
960    EXCEPTION
961  	 WHEN OTHERS THEN
962  	   -- log the error instead of RAISE
963  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
964  	   RETURN -1;
965    END get_next_script;
966  
967  END;
968  /

Package body created.

SQL> @@../sosl_ddl/packages/sosl_server.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- server interface package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl_server
  2  AS
  3    /**
  4    * This package contains the server interface used by the Simple Oracle Script Loader.
  5    * All server scripts depend on this package. The default error return value is -1, either
  6    * as number or as string. The SOSL server can only deal with this two types of return
  7    * values: NUMBER or VARCHAR2. And it can only deal with functions usable in a SELECT statement.
  8    * All interpreted values are read in as COLUMN variables, it makes no difference, if -1 or '-1'
  9    * is delivered as error code.
 10    */
 11  
 12    /*====================================== start internal functions made visible for testing ======================================*/
 13    -- SOSL server will not call this functions directly, so return type can be different from NUMBER or VARCHAR2
 14  
 15    /* FUNCTION SOSL_SERVER.HAS_CONFIG_NAME
 16    * Checks if a given case sensitive configuration name exists. Errors get logged.
 17    *
 18    * @param p_config_name The config name of the configuration item.
 19    *
 20    * @return Either TRUE if the configuration name exists or FALSE, including FALSE on error.
 21    */
 22    FUNCTION has_config_name(p_config_name IN VARCHAR2)
 23  	 RETURN BOOLEAN
 24    ;
 25    /* FUNCTION SOSL_SERVER.SET_GUID
 26    * Sets the GUID of the SOSL server, used during script execution, in SOSL_RUN_QUEUE. The GUID will be
 27    * a generic identifier for this script execution. All identifiers in SOSLERRLOG will start with this GUID
 28    * for a specific script execution.
 29    *
 30    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
 31    * @param p_guid The GUID used by the SOSL server for this script execution.
 32    *
 33    * @return Exit code, either 0 = successful or -1 on error.
 34    */
 35    FUNCTION set_guid( p_run_id IN NUMBER
 36  			, p_guid   IN VARCHAR2
 37  			)
 38  	 RETURN NUMBER
 39    ;
 40    /* FUNCTION SOSL_SERVER.SET_IDENTIFIER
 41    * Sets the exact SOSL IDENTIFIER of the SOSL server, used during main script execution, in SOSL_RUN_QUEUE. The identifier
 42    * will exactly match SOSLERRLOG.IDENTIFIER in case of errors for a specific script execution. It will start with the GUID
 43    * for the whole script execution process.
 44    *
 45    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
 46    * @param p_identifier The exact identifier used by the SOSL server for the main part of the script execution.
 47    *
 48    * @return Exit code, either 0 = successful or -1 on error.
 49    */
 50    FUNCTION set_identifier( p_run_id     IN NUMBER
 51  			      , p_identifier IN VARCHAR2
 52  			      )
 53  	 RETURN NUMBER
 54    ;
 55    /*====================================== end internal functions made visible for testing ======================================*/
 56  
 57    /** Function SOSL_SERVER.SET_CONFIG
 58    * Sets an existing configuration value for a given and existing case sensitive configuration name. Invalid
 59    * config names get logged. Invalid config values for SOSL_RUNMODE and SOSL_SERVER_STATE are ignored and will
 60    * not change the config value. Errors get logged.
 61    * SOSL_RUNMODE values: RUN, WAIT, STOP
 62    * SOSL_SERVER_STATE values: ACTIVE, INACTIVE, PAUSE
 63    *
 64    * @param p_config_name The valid config name of the configuration item.
 65    * @param p_config_value The value to assign to the configuration item.
 66    *
 67    * @return Exit code, either 0 = successful or -1 on error.
 68    */
 69    FUNCTION set_config( p_config_name  IN VARCHAR2
 70  			  , p_config_value IN VARCHAR2
 71  			  )
 72  	 RETURN NUMBER
 73    ;
 74  
 75    /** Function SOSL_SERVER.GET_CONFIG
 76    * Gets an existing configuration value for a given and existing case sensitive configuration name. Errors get logged.
 77    *
 78    * @param p_config_name The config name of the configuration item.
 79    *
 80    * @return The configured value as VARCHAR2 or '-1' string on error.
 81    */
 82    FUNCTION get_config(p_config_name IN VARCHAR2)
 83  	 RETURN VARCHAR2
 84    ;
 85  
 86    /* FUNCTION SOSL_SERVER.SET_SERVER_STATE
 87    * A shortcut function using sosl_server.set_config for SOSL_SERVER_STATE. Errors get logged.
 88    *
 89    * @param p_server_state A valid server state: ACTIVE, INACTIVE, PAUSE.
 90    *
 91    * @return Exit code, either 0 = successful or -1 on error.
 92    */
 93    FUNCTION set_server_state(p_server_state IN VARCHAR2)
 94  	 RETURN NUMBER
 95    ;
 96  
 97  
 98    /* FUNCTION SOSL_SERVER.SET_RUNMODE
 99    * A shortcut function using sosl_server.set_config for SOSL_RUNMODE. Errors get logged.
100    *
101    * @param p_server_state A valid run mode: RUN, WAIT, STOP.
102    *
103    * @return Exit code, either 0 = successful or -1 on error.
104    */
105    FUNCTION set_runmode(p_runmode IN VARCHAR2)
106  	 RETURN NUMBER
107    ;
108  
109    /* FUNCTION SOSL_SERVER.GET_EXECUTOR_CFG
110    * Retrieves the config login file to use for a specific executor by a given run id. Errors get logged.
111    *
112    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
113    *
114    * @return The configuration login filename including relative/absolute path or '-1' on errors.
115    */
116    FUNCTION get_executor_cfg(p_run_id IN NUMBER)
117  	 RETURN VARCHAR2
118    ;
119  
120    /* FUNCTION SOSL_SERVER.GET_SCRIPT_FILE
121    * Retrieves the script filename including relative or full path by a given run id. Errors get logged.
122    *
123    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
124    *
125    * @return The script filename including relative/absolute path or '-1' on errors.
126    */
127    FUNCTION get_script_file(p_run_id IN NUMBER)
128  	 RETURN VARCHAR2
129    ;
130  
131    /* FUNCTION SOSL_SERVER.GET_SCRIPT_SCHEMA
132    * Retrieves the schema a given script should run in by a given run id. Uses FUNCTION_OWNER as defined
133    * for the executor of this script. Errors get logged.
134    *
135    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
136    *
137    * @return The schema to use for the script associated with the run id or the current schema of this package as fallback on errors.
138    */
139    FUNCTION get_script_schema(p_run_id IN NUMBER)
140  	 RETURN VARCHAR2
141    ;
142  
143    /* FUNCTION SOSL_SERVER.GET_SOSL_SCHEMA
144    * Retrieves the current SOSL schema from table SOSL_CONFIG. Used for prefixing SOSL packages and functions when executing
145    * scripts for an executor. Errors get logged. Fix any issue on SOSL schema before running the server component locally.
146    *
147    * @return The SOSL schema as defined on installation. On errors will return PUBLIC, so any package prefixed with this virtual schema will fail.
148    */
149    FUNCTION get_sosl_schema
150  	 RETURN VARCHAR2
151    ;
152  
153    /* FUNCTION SOSL_SERVER.SET_SCRIPT_STARTED
154    * Short cut function for sosl_sys.set_run_state to guarantee correct run states. On errors the script state will
155    * be set to error. Before calling this function at least GUID should be set for the current script.
156    * Wrapper function for SOSL_SYS.SET_SCRIPT_STATUS.
157    *
158    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
159    *
160    * @return Exit code, either 0 = successful or -1 on error.
161    */
162    FUNCTION set_script_started(p_run_id IN NUMBER)
163  	 RETURN NUMBER
164    ;
165  
166    /* FUNCTION SOSL_SERVER.SET_SCRIPT_RUNNING
167    * Short cut function for sosl_sys.set_run_state to guarantee correct run states. On errors the script state will
168    * be set to error. Before calling this function the exact SOSL identifier should be set for the current script.
169    * Wrapper function for SOSL_SYS.SET_SCRIPT_STATUS.
170    *
171    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
172    *
173    * @return Exit code, either 0 = successful or -1 on error.
174    */
175    FUNCTION set_script_running(p_run_id IN NUMBER)
176  	 RETURN NUMBER
177    ;
178  
179    /* FUNCTION SOSL_SERVER.SET_SCRIPT_FINISHED
180    * Short cut function for sosl_sys.set_run_state to guarantee correct run states. On errors the script state will
181    * be set to error. Wrapper function for SOSL_SYS.SET_SCRIPT_STATUS.
182    *
183    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
184    *
185    * @return Exit code, either 0 = successful or -1 on error.
186    */
187    FUNCTION set_script_finished(p_run_id IN NUMBER)
188  	 RETURN NUMBER
189    ;
190  
191    /* FUNCTION SOSL_SERVER.SET_SCRIPT_RUNNING
192    * Short cut function for sosl_sys.set_run_state to guarantee correct run states. On errors the script state will
193    * be set to error. Before calling this function the GUID and exact SOSL identifier should be set for the current script.
194    * Wrapper function for SOSL_SYS.SET_SCRIPT_STATUS.
195    *
196    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
197    *
198    * @return Exit code, either 0 = successful or -1 on error.
199    */
200    FUNCTION set_script_error(p_run_id IN NUMBER)
201  	 RETURN NUMBER
202    ;
203  
204    /* FUNCTION SOSL_SERVER.MAIN_LOG
205    * Provides a possibility to output content for a local log as well as logging it to SOSL_SERVER_LOG. Can be
206    * be called within every SELECT statement. On success log category will always be SOSL_SERVER.
207    *
208    * @param p_srv_caller The script calling this function.
209    * @param p_srv_message The message to use for the local log as well as to the SOSL_SERVER_LOG.
210    * @param p_log_type The log type to use for the logging.
211    * @param p_identifier In almost all cases scripts called from the server have an identifier, that they use for SOSLERRORLOG. NULL by default.
212    * @param p_local_log In almost all cases scripts called from the server have a log file, that they use. NULL by default.
213    * @param p_srv_run_id Scripts issued by executors will have a run id which is retrieved from the SOSL server. If a run id is given, the log is also enhanced with executor details for this script. NULL by default.
214    * @param p_srv_guid For cases scripts called from the server have also the GUID, that they use. NULL by default.
215    *
216    * @return Will return p_message or error information.
217    */
218    FUNCTION main_log( p_srv_caller	 IN VARCHAR2
219  			, p_srv_message  IN VARCHAR2
220  			, p_log_type	 IN VARCHAR2
221  			, p_identifier	 IN VARCHAR2 DEFAULT NULL
222  			, p_local_log	 IN VARCHAR2 DEFAULT NULL
223  			, p_srv_run_id	 IN NUMBER   DEFAULT NULL
224  			, p_srv_guid	 IN VARCHAR2 DEFAULT NULL
225  			)
226  	 RETURN VARCHAR2
227    ;
228  
229    /* FUNCTION SOSL_SERVER.INFO_LOG
230    * Provides a possibility to output content for a local log as well as logging it to SOSL_SERVER_LOG. Can be
231    * be called within every SELECT statement. On success log category will always be SOSL_SERVER, log type INFO.
232    *
233    * @param p_srv_caller The script calling this function.
234    * @param p_srv_message The message to use for the local log as well as to the SOSL_SERVER_LOG.
235    * @param p_identifier In almost all cases scripts called from the server have an identifier, that they use for SOSLERRORLOG. NULL by default.
236    * @param p_local_log In almost all cases scripts called from the server have a log file, that they use. NULL by default.
237    * @param p_srv_run_id Scripts issued by executors will have a run id which is retrieved from the SOSL server. If a run id is given, the log is also enhanced with executor details for this script. NULL by default.
238    * @param p_srv_guid For cases scripts called from the server have also the GUID, that they use. NULL by default.
239    *
240    * @return Will return p_message or error information.
241    */
242    FUNCTION info_log( p_srv_caller	 IN VARCHAR2
243  			, p_srv_message  IN VARCHAR2
244  			, p_identifier	 IN VARCHAR2 DEFAULT NULL
245  			, p_local_log	 IN VARCHAR2 DEFAULT NULL
246  			, p_srv_run_id	 IN NUMBER   DEFAULT NULL
247  			, p_srv_guid	 IN VARCHAR2 DEFAULT NULL
248  			)
249  	 RETURN VARCHAR2
250    ;
251  
252    /* FUNCTION SOSL_SERVER.SUCCESS_LOG
253    * Provides a possibility to output content for a local log as well as logging it to SOSL_SERVER_LOG. Can be
254    * be called within every SELECT statement. On success log category will always be SOSL_SERVER, log type SUCCESS.
255    *
256    * @param p_srv_caller The script calling this function.
257    * @param p_srv_message The message to use for the local log as well as to the SOSL_SERVER_LOG.
258    * @param p_identifier In almost all cases scripts called from the server have an identifier, that they use for SOSLERRORLOG. NULL by default.
259    * @param p_local_log In almost all cases scripts called from the server have a log file, that they use. NULL by default.
260    * @param p_srv_run_id Scripts issued by executors will have a run id which is retrieved from the SOSL server. If a run id is given, the log is also enhanced with executor details for this script. NULL by default.
261    * @param p_srv_guid For cases scripts called from the server have also the GUID, that they use. NULL by default.
262    *
263    * @return Will return p_message or error information.
264    */
265    FUNCTION success_log( p_srv_caller   IN VARCHAR2
266  			   , p_srv_message  IN VARCHAR2
267  			   , p_identifier   IN VARCHAR2 DEFAULT NULL
268  			   , p_local_log    IN VARCHAR2 DEFAULT NULL
269  			   , p_srv_run_id   IN NUMBER	DEFAULT NULL
270  			   , p_srv_guid     IN VARCHAR2 DEFAULT NULL
271  			   )
272  	 RETURN VARCHAR2
273    ;
274  
275    /* FUNCTION SOSL_SERVER.WARNING_LOG
276    * Provides a possibility to output content for a local log as well as logging it to SOSL_SERVER_LOG. Can be
277    * be called within every SELECT statement. On success log category will always be SOSL_SERVER, log type WARNING.
278    *
279    * @param p_srv_caller The script calling this function.
280    * @param p_srv_message The message to use for the local log as well as to the SOSL_SERVER_LOG.
281    * @param p_identifier In almost all cases scripts called from the server have an identifier, that they use for SOSLERRORLOG. NULL by default.
282    * @param p_local_log In almost all cases scripts called from the server have a log file, that they use. NULL by default.
283    * @param p_srv_run_id Scripts issued by executors will have a run id which is retrieved from the SOSL server. If a run id is given, the log is also enhanced with executor details for this script. NULL by default.
284    * @param p_srv_guid For cases scripts called from the server have also the GUID, that they use. NULL by default.
285    *
286    * @return Will return p_message or error information.
287    */
288    FUNCTION warning_log( p_srv_caller   IN VARCHAR2
289  			   , p_srv_message  IN VARCHAR2
290  			   , p_identifier   IN VARCHAR2 DEFAULT NULL
291  			   , p_local_log    IN VARCHAR2 DEFAULT NULL
292  			   , p_srv_run_id   IN NUMBER	DEFAULT NULL
293  			   , p_srv_guid     IN VARCHAR2 DEFAULT NULL
294  			   )
295  	 RETURN VARCHAR2
296    ;
297  
298    /* FUNCTION SOSL_SERVER.ERROR_LOG
299    * Provides a possibility to output content for a local log as well as logging it to SOSL_SERVER_LOG. Can be
300    * be called within every SELECT statement. On success log category will always be SOSL_SERVER, log type ERROR.
301    *
302    * @param p_srv_caller The script calling this function.
303    * @param p_srv_message The message to use for the local log as well as to the SOSL_SERVER_LOG.
304    * @param p_identifier In almost all cases scripts called from the server have an identifier, that they use for SOSLERRORLOG. NULL by default.
305    * @param p_local_log In almost all cases scripts called from the server have a log file, that they use. NULL by default.
306    * @param p_srv_run_id Scripts issued by executors will have a run id which is retrieved from the SOSL server. If a run id is given, the log is also enhanced with executor details for this script. NULL by default.
307    * @param p_srv_guid For cases scripts called from the server have also the GUID, that they use. NULL by default.
308    *
309    * @return Will return p_message or error information.
310    */
311    FUNCTION error_log( p_srv_caller   IN VARCHAR2
312  			 , p_srv_message  IN VARCHAR2
313  			 , p_identifier   IN VARCHAR2 DEFAULT NULL
314  			 , p_local_log	  IN VARCHAR2 DEFAULT NULL
315  			 , p_srv_run_id   IN NUMBER   DEFAULT NULL
316  			 , p_srv_guid	  IN VARCHAR2 DEFAULT NULL
317  			 )
318  	 RETURN VARCHAR2
319    ;
320  
321    /* FUNCTION SOSL_SERVER.HAS_SCRIPTS
322    * Wrapper function for SOSL_SYS.HAS_SCRIPTS.
323    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
324    * return a number greater or equal to 0 as well as messages waiting in SOSL_RUN_QUEUE to be processed. Errors will get logged.
325    * If the SOSL server is set to STOP or PAUSE, will always return 0 and not check available scripts.
326    *
327    * @return The total amount of scripts waiting for processing or -1 on unhandled exceptions/all functions have errors.
328    */
329    FUNCTION has_scripts
330  	 RETURN NUMBER
331    ;
332  
333    /* FUNCTION SOSL_SERVER.GET_NEXT_SCRIPT
334    * Wrapper function for SOSL_SYS.GET_NEXT_SCRIPT.
335    * It collects from all executors the next script to execute, queues them in SOSL_RUN_QUEUE and then fetches the first script in the
336    * run queue as next script to execute. If no scripts are available or on errors, the function will return -1.
337    * Errors will be logged. From interface functions it excepts the return type SOSL_PAYLOAD.
338    *
339    * @return The next script reference as RUN_ID from SOSL_RUN_QUEUE, containing run id that can be related to executor, external script id and scriptfile.
340    */
341    FUNCTION get_next_script
342  	 RETURN NUMBER
343    ;
344  
345    /* FUNCTION SOSL_SERVER.UPDATE_RUN_ID
346    * Updates the run id with details from the server. Errors get logged.
347    *
348    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
349    * @param p_identifier The exact identifier used by the SOSL server for the main part of the script execution.
350    * @param p_guid The (optional) GUID used by the SOSL server for this script execution.
351    *
352    * @return Exit code, either 0 = successful or -1 on error.
353    */
354    FUNCTION update_run_id( p_run_id      IN NUMBER
355  			     , p_identifier  IN VARCHAR2
356  			     , p_guid	     IN VARCHAR2 DEFAULT NULL
357  			     )
358  	 RETURN NUMBER
359    ;
360  
361    /* FUNCTION SOSL_SERVER.DUMMY_MAIL
362    * This is a testing function that will NOT send any mail. It will log the mail message created in SOSL_SERVER_LOG using
363    * the field full_message, so output can be controlled.
364    *
365    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
366    * @param p_recipients The semicolon separated list of mail recipient addresses.
367    * @param p_subject A preferablly short subject for the mail.
368    * @param p_message The correctly formatted mail message.
369    *
370    * @return Will return TRUE on success or FALSE on errors.
371    */
372    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
373  			  , p_recipients  IN VARCHAR2
374  			  , p_subject	  IN VARCHAR2
375  			  , p_message	  IN VARCHAR2
376  			  )
377  	 RETURN BOOLEAN
378    ;
379  
380    /* FUNCTION SOSL_SERVER.HAS_RUN_ID
381    * Checks if a given run id exists. Errors get logged.
382    *
383    * @param p_run_id The run id to verify.
384    *
385    * @return TRUE if run id exists otherwise FALSE.
386    */
387    FUNCTION has_run_id(p_run_id IN NUMBER)
388  	 RETURN BOOLEAN
389    ;
390  
391    /* FUNCTION SOSL_SERVER.GET_PAYLOAD
392    * Builds a SOSL_PAYLOAD object from the given run id. Wrapper for SOSL_SYS.
393    *
394    * @param p_run_id The run id to get the SOSL_PAYLOAD object for.
395    *
396    * @return On success a valid SOSL_PAYLOAD object or NULL on errors.
397    */
398    FUNCTION get_payload(p_run_id IN NUMBER)
399  	 RETURN SOSL_PAYLOAD
400    ;
401  
402  END;
403  /

Package created.

SQL> -- grants
SQL> GRANT EXECUTE ON sosl_server TO sosl_executor;

Grant succeeded.

SQL> @@../sosl_ddl/packages/sosl_server.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_server
  2  AS
  3    -- for description see header file
  4    /*====================================== start internal functions made visible for testing ======================================*/
  5    FUNCTION has_config_name(p_config_name IN VARCHAR2)
  6  	 RETURN BOOLEAN
  7    IS
  8  	 l_return	     BOOLEAN;
  9  	 l_count	     NUMBER;
 10  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
 11  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.has_config_name';
 12    BEGIN
 13  	 SELECT COUNT(*)
 14  	   INTO l_count
 15  	   FROM sosl_config
 16  	  WHERE config_name = p_config_name
 17  	 ;
 18  	 l_return := (l_count = 1);
 19  	 RETURN l_return;
 20    EXCEPTION
 21  	 WHEN OTHERS THEN
 22  	   -- log the error instead of RAISE
 23  	   sosl_log.exception_log('sosl_server.has_config_name', 'SOSL_SERVER', SQLERRM);
 24  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 25  	   RETURN FALSE;
 26    END has_config_name;
 27  
 28  
 29    FUNCTION set_guid( p_run_id IN NUMBER
 30  			, p_guid   IN VARCHAR2
 31  			)
 32  	 RETURN NUMBER
 33    IS
 34  	 PRAGMA AUTONOMOUS_TRANSACTION;
 35  	 l_return	     NUMBER;
 36  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
 37  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.set_guid';
 38    BEGIN
 39  	 l_return := -1;
 40  	 IF sosl_sys.has_run_id(p_run_id)
 41  	 THEN
 42  	   UPDATE sosl_run_queue
 43  	      SET script_guid = p_guid
 44  	    WHERE run_id = p_run_id
 45  	   ;
 46  	   COMMIT;
 47  	   l_return := 0;
 48  	 ELSE
 49  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
 50  	   l_return := -1;
 51  	 END IF;
 52  	 RETURN l_return;
 53    EXCEPTION
 54  	 WHEN OTHERS THEN
 55  	   -- log the error instead of RAISE
 56  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 57  	   RETURN -1;
 58    END set_guid;
 59  
 60    FUNCTION set_identifier( p_run_id     IN NUMBER
 61  			      , p_identifier IN VARCHAR2
 62  			      )
 63  	 RETURN NUMBER
 64    IS
 65  	 PRAGMA AUTONOMOUS_TRANSACTION;
 66  	 l_return	     NUMBER;
 67  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
 68  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.set_identifier';
 69    BEGIN
 70  	 l_return := -1;
 71  	 IF sosl_sys.has_run_id(p_run_id)
 72  	 THEN
 73  	   UPDATE sosl_run_queue
 74  	      SET sosl_identifier = p_identifier
 75  	    WHERE run_id = p_run_id
 76  	   ;
 77  	   COMMIT;
 78  	   l_return := 0;
 79  	 ELSE
 80  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
 81  	   l_return := -1;
 82  	 END IF;
 83  	 RETURN l_return;
 84    EXCEPTION
 85  	 WHEN OTHERS THEN
 86  	   -- log the error instead of RAISE
 87  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 88  	   RETURN -1;
 89    END set_identifier;
 90    /*====================================== end internal functions made visible for testing ======================================*/
 91  
 92    FUNCTION set_config( p_config_name  IN VARCHAR2
 93  			  , p_config_value IN VARCHAR2
 94  			  )
 95  	 RETURN NUMBER
 96    IS
 97  	 PRAGMA AUTONOMOUS_TRANSACTION;
 98  	 l_return	     NUMBER;
 99  	 l_set_value	     BOOLEAN;
100  	 l_check	     NUMBER;
101  	 l_config_value      sosl_config.config_value%TYPE;
102  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
103  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.set_config';
104    BEGIN
105  	 l_return := -1;
106  	 IF sosl_server.has_config_name(p_config_name)
107  	 THEN
108  	   l_set_value	  := TRUE;
109  	   l_config_value := TRIM(p_config_value);
110  	   -- do some extra checks on config name SOSL_RUNMODE and SOSL_SERVER_STATE
111  	   IF p_config_name IN ('SOSL_RUNMODE', 'SOSL_SERVER_STATE', 'SOSL_START_JOBS', 'SOSL_STOP_JOBS')
112  	   THEN
113  	     -- make commands uppercase
114  	     l_config_value := UPPER(l_config_value);
115  	     IF     p_config_name      = 'SOSL_RUNMODE'
116  		AND l_config_value NOT IN ('RUN', 'WAIT', 'STOP')
117  	     THEN
118  	       -- log the error and do not change the config value
119  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid run mode: ' || l_config_value || '. Configuration not changed');
120  	       l_set_value := FALSE;
121  	     END IF;
122  	     IF      p_config_name = 'SOSL_SERVER_STATE'
123  		AND  l_config_value NOT IN ('ACTIVE', 'INACTIVE', 'PAUSE')
124  	     THEN
125  	       -- log the error and do not change the config value
126  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid server state: ' || l_config_value || '. Configuration not changed');
127  	       l_set_value := FALSE;
128  	     END IF;
129  	     IF p_config_name IN ('SOSL_START_JOBS', 'SOSL_STOP_JOBS')
130  	     THEN
131  	       -- exclude -1 value to disable timeframe
132  	       IF l_config_value != '-1'
133  	       THEN
134  		 -- check format
135  		 IF SUBSTR(l_config_value, 3, 1) != ':'
136  		 THEN
137  		   -- log the error and do not change the config value
138  		   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid ' || p_config_name || ': ' || l_config_value || ' - missing : delimiter. Configuration not changed');
139  		   l_set_value := FALSE;
140  		 END IF;
141  		 -- check hours
142  		 IF NOT REGEXP_LIKE(SUBSTR(l_config_value, 1, 2), '^[0-9][0-9]')
143  		 THEN
144  		   -- log the error and do not change the config value
145  		   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid ' || p_config_name || ': ' || l_config_value || ' - invalid hour string. Configuration not changed');
146  		   l_set_value := FALSE;
147  		 ELSE
148  		   l_check := TO_NUMBER(SUBSTR(l_config_value, 1, 2));
149  		   IF l_check > 23
150  		   THEN
151  		     -- log the error and do not change the config value
152  		     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid ' || p_config_name || ': ' || l_config_value || ' - invalid hour 00 - 23 allowed. Configuration not changed');
153  		     l_set_value := FALSE;
154  		   END IF;
155  		 END IF;
156  		 -- check minutes
157  		 IF NOT REGEXP_LIKE(SUBSTR(l_config_value, 4, 5), '^[0-9][0-9]')
158  		 THEN
159  		   -- log the error and do not change the config value
160  		   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid ' || p_config_name || ': ' || l_config_value || ' - invalid minute string. Configuration not changed');
161  		   l_set_value := FALSE;
162  		 ELSE
163  		   l_check := TO_NUMBER(SUBSTR(l_config_value, 4, 5));
164  		   IF l_check > 59
165  		   THEN
166  		     -- log the error and do not change the config value
167  		     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid ' || p_config_name || ': ' || l_config_value || ' - invalid minute 00 - 59 allowed. Configuration not changed');
168  		     l_set_value := FALSE;
169  		   END IF;
170  		 END IF;
171  	       END IF;
172  	     END IF;
173  	   END IF;
174  	   IF l_set_value
175  	   THEN
176  	     UPDATE sosl_config
177  		SET config_value = p_config_value
178  	      WHERE config_name = p_config_name
179  	     ;
180  	     COMMIT;
181  	     l_return := 0;
182  	   END IF;
183  	 ELSE
184  	   -- log error wrong config name
185  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested config name "' || p_config_name || '" does not exist.');
186  	 END IF;
187  	 RETURN l_return;
188    EXCEPTION
189  	 WHEN OTHERS THEN
190  	   -- log the error instead of RAISE
191  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
192  	   RETURN -1;
193    END set_config;
194  
195    FUNCTION get_config(p_config_name IN VARCHAR2)
196  	 RETURN VARCHAR2
197    IS
198  	 l_config_value      sosl_config.config_value%TYPE;
199  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
200  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.get_config';
201    BEGIN
202  	 l_config_value := '-1';
203  	 IF sosl_server.has_config_name(p_config_name)
204  	 THEN
205  	   SELECT config_value
206  	     INTO l_config_value
207  	     FROM sosl_config
208  	    WHERE config_name = p_config_name
209  	   ;
210  	 ELSE
211  	   -- log error wrong config name
212  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested config name "' || p_config_name || '" does not exist.');
213  	   l_config_value := '-1';
214  	 END IF;
215  	 RETURN l_config_value;
216    EXCEPTION
217  	 WHEN OTHERS THEN
218  	   -- log the error instead of RAISE
219  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
220  	   RETURN '-1';
221    END get_config;
222  
223    FUNCTION set_server_state(p_server_state IN VARCHAR2)
224  	 RETURN NUMBER
225    IS
226  	 l_return  NUMBER;
227    BEGIN
228  	 l_return := sosl_server.set_config('SOSL_SERVER_STATE', p_server_state);
229  	 RETURN l_return;
230    EXCEPTION
231  	 WHEN OTHERS THEN
232  	   -- log the error instead of RAISE
233  	   sosl_log.exception_log('sosl_server.set_server_state', 'SOSL_SERVER', SQLERRM);
234  	   RETURN -1;
235    END set_server_state;
236  
237    FUNCTION set_runmode(p_runmode IN VARCHAR2)
238  	 RETURN NUMBER
239    IS
240  	 l_return  NUMBER;
241    BEGIN
242  	 l_return := sosl_server.set_config('SOSL_RUNMODE', p_runmode);
243  	 RETURN l_return;
244    EXCEPTION
245  	 WHEN OTHERS THEN
246  	   -- log the error instead of RAISE
247  	   sosl_log.exception_log('sosl_server.set_runmode', 'SOSL_SERVER', SQLERRM);
248  	   RETURN -1;
249    END set_runmode;
250  
251    FUNCTION get_executor_cfg(p_run_id IN NUMBER)
252  	 RETURN VARCHAR2
253    IS
254  	 l_executor_cfg      sosl_executor_definition.cfg_file%TYPE;
255  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
256  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.get_executor_cfg';
257    BEGIN
258  	 l_executor_cfg := '-1';
259  	 IF sosl_sys.has_run_id(p_run_id)
260  	 THEN
261  	   SELECT sed.cfg_file
262  	     INTO l_executor_cfg
263  	     FROM sosl_run_queue srq
264  	     LEFT OUTER JOIN sosl_executor_definition sed
265  	       ON srq.executor_id = sed.executor_id
266  	    WHERE srq.run_id = p_run_id
267  	   ;
268  	 ELSE
269  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
270  	   l_executor_cfg := '-1';
271  	 END IF;
272  	 RETURN l_executor_cfg;
273    EXCEPTION
274  	 WHEN OTHERS THEN
275  	   -- log the error instead of RAISE
276  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
277  	   RETURN '-1';
278    END get_executor_cfg;
279  
280    FUNCTION get_script_file(p_run_id IN NUMBER)
281  	 RETURN VARCHAR2
282    IS
283  	 l_script_file	     sosl_run_queue.script_file%TYPE;
284  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
285  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.get_script_file';
286    BEGIN
287  	 l_script_file := '-1';
288  	 IF sosl_sys.has_run_id(p_run_id)
289  	 THEN
290  	   SELECT script_file
291  	     INTO l_script_file
292  	     FROM sosl_run_queue
293  	    WHERE run_id = p_run_id
294  	   ;
295  	 ELSE
296  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
297  	   l_script_file := '-1';
298  	 END IF;
299  	 RETURN l_script_file;
300    EXCEPTION
301  	 WHEN OTHERS THEN
302  	   -- log the error instead of RAISE
303  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
304  	   RETURN '-1';
305    END get_script_file;
306  
307    FUNCTION get_script_schema(p_run_id IN NUMBER)
308  	 RETURN VARCHAR2
309    IS
310  	 l_script_schema     sosl_executor_definition.function_owner%TYPE;
311  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
312  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.get_script_schema';
313    BEGIN
314  	 l_script_schema := TRIM(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'));
315  	 IF sosl_sys.has_run_id(p_run_id)
316  	 THEN
317  	   SELECT sed.function_owner
318  	     INTO l_script_schema
319  	     FROM sosl_run_queue srq
320  	     LEFT OUTER JOIN sosl_executor_definition sed
321  	       ON srq.executor_id = sed.executor_id
322  	    WHERE srq.run_id = p_run_id
323  	   ;
324  	 ELSE
325  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
326  	   l_script_schema := TRIM(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'));
327  	 END IF;
328  	 RETURN l_script_schema;
329    EXCEPTION
330  	 WHEN OTHERS THEN
331  	   -- log the error instead of RAISE
332  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
333  	   RETURN TRIM(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'));
334    END get_script_schema;
335  
336    FUNCTION get_sosl_schema
337  	 RETURN VARCHAR2
338    IS
339  	 l_sosl_schema	     VARCHAR2(128);
340    BEGIN
341  	 SELECT config_value
342  	   INTO l_sosl_schema
343  	   FROM sosl_config
344  	  WHERE config_name = 'SOSL_SCHEMA'
345  	 ;
346  	 RETURN l_sosl_schema;
347    EXCEPTION
348  	 WHEN OTHERS THEN
349  	   -- log the error instead of RAISE
350  	   sosl_log.exception_log('sosl_server.get_sosl_schema', 'SOSL_SERVER', SQLERRM);
351  	   -- return PUBLIC to guarantee errors if used as schema prefix. Issues must be fixed before.
352  	   RETURN 'PUBLIC';
353    END get_sosl_schema;
354  
355    FUNCTION set_script_started(p_run_id IN NUMBER)
356  	 RETURN NUMBER
357    IS
358  	 l_return	     NUMBER;
359    BEGIN
360  	 l_return := sosl_sys.set_script_status(p_run_id, sosl_constants.RUN_STATE_STARTED);
361  	 RETURN l_return;
362    EXCEPTION
363  	 WHEN OTHERS THEN
364  	   -- log the error instead of RAISE
365  	   sosl_log.exception_log('sosl_server.set_script_started', 'SOSL_SERVER', SQLERRM);
366  	   RETURN -1;
367    END set_script_started;
368  
369    FUNCTION set_script_running(p_run_id IN NUMBER)
370  	 RETURN NUMBER
371    IS
372  	 l_return	     NUMBER;
373    BEGIN
374  	 l_return := sosl_sys.set_script_status(p_run_id, sosl_constants.RUN_STATE_RUNNING);
375  	 RETURN l_return;
376    EXCEPTION
377  	 WHEN OTHERS THEN
378  	   -- log the error instead of RAISE
379  	   sosl_log.exception_log('sosl_server.set_script_running', 'SOSL_SERVER', SQLERRM);
380  	   RETURN -1;
381    END set_script_running;
382  
383    FUNCTION set_script_finished(p_run_id IN NUMBER)
384  	 RETURN NUMBER
385    IS
386  	 l_return	     NUMBER;
387    BEGIN
388  	 l_return := sosl_sys.set_script_status(p_run_id, sosl_constants.RUN_STATE_FINISHED);
389  	 RETURN l_return;
390    EXCEPTION
391  	 WHEN OTHERS THEN
392  	   -- log the error instead of RAISE
393  	   sosl_log.exception_log('sosl_server.set_script_finished', 'SOSL_SERVER', SQLERRM);
394  	   RETURN -1;
395    END set_script_finished;
396  
397    FUNCTION set_script_error(p_run_id IN NUMBER)
398  	 RETURN NUMBER
399    IS
400  	 l_return	     NUMBER;
401    BEGIN
402  	 l_return := sosl_sys.set_script_status(p_run_id, sosl_constants.RUN_STATE_ERROR);
403  	 RETURN l_return;
404    EXCEPTION
405  	 WHEN OTHERS THEN
406  	   -- log the error instead of RAISE
407  	   sosl_log.exception_log('sosl_server.set_script_error', 'SOSL_SERVER', SQLERRM);
408  	   RETURN -1;
409    END set_script_error;
410  
411    FUNCTION main_log( p_srv_caller	 IN VARCHAR2
412  			, p_srv_message  IN VARCHAR2
413  			, p_log_type	 IN VARCHAR2
414  			, p_identifier	 IN VARCHAR2 DEFAULT NULL
415  			, p_local_log	 IN VARCHAR2 DEFAULT NULL
416  			, p_srv_run_id	 IN NUMBER   DEFAULT NULL
417  			, p_srv_guid	 IN VARCHAR2 DEFAULT NULL
418  			)
419  	 RETURN VARCHAR2
420    IS
421  	 l_message   VARCHAR2(32767);
422  	 l_payload   SOSL_PAYLOAD;
423  	 l_log_type  sosl_server_log.log_type%TYPE;
424    BEGIN
425  	 l_log_type := sosl_log.get_valid_log_type(p_log_type);
426  	 IF p_local_log IS NOT NULL
427  	 THEN
428  	   l_message := p_srv_message || ' local log file: ' || p_local_log;
429  	 ELSE
430  	   l_message := p_srv_message;
431  	 END IF;
432  	 IF p_srv_run_id IS NOT NULL
433  	 THEN
434  	   l_payload := sosl_sys.get_payload(p_srv_run_id);
435  	 ELSE
436  	   l_payload := SOSL_PAYLOAD(NULL, NULL, NULL);
437  	 END IF;
438  	 sosl_log.full_log( p_message => l_message
439  			  , p_log_type => l_log_type
440  			  , p_log_category => 'SOSL_SERVER'
441  			  , p_caller => p_srv_caller
442  			  , p_guid => p_srv_guid
443  			  , p_sosl_identifier => p_identifier
444  			  , p_executor_id => l_payload.executor_id
445  			  , p_ext_script_id => l_payload.ext_script_id
446  			  , p_script_file => l_payload.script_file
447  			  , p_run_id => p_srv_run_id
448  			  )
449  	 ;
450  	 RETURN p_srv_message;
451    EXCEPTION
452  	 WHEN OTHERS THEN
453  	   -- log the error instead of RAISE
454  	   sosl_log.exception_log('sosl_server.main_log', 'SOSL_SERVER', SQLERRM);
455  	   RETURN SUBSTR(SQLERRM, 1, 4000);
456    END main_log;
457  
458  
459    FUNCTION info_log( p_srv_caller	 IN VARCHAR2
460  			, p_srv_message  IN VARCHAR2
461  			, p_identifier	 IN VARCHAR2 DEFAULT NULL
462  			, p_local_log	 IN VARCHAR2 DEFAULT NULL
463  			, p_srv_run_id	 IN NUMBER   DEFAULT NULL
464  			, p_srv_guid	 IN VARCHAR2 DEFAULT NULL
465  			)
466  	 RETURN VARCHAR2
467    IS
468  	 l_message   VARCHAR2(32767);
469    BEGIN
470  	 l_message := main_log(p_srv_caller, p_srv_message, sosl_constants.LOG_INFO_TYPE, p_identifier, p_local_log, p_srv_run_id, p_srv_guid);
471  	 RETURN l_message;
472    EXCEPTION
473  	 WHEN OTHERS THEN
474  	   -- log the error instead of RAISE
475  	   sosl_log.exception_log('sosl_server.info_log', 'SOSL_SERVER', SQLERRM);
476  	   RETURN SUBSTR(SQLERRM, 1, 4000);
477    END info_log;
478  
479    FUNCTION success_log( p_srv_caller   IN VARCHAR2
480  			   , p_srv_message  IN VARCHAR2
481  			   , p_identifier   IN VARCHAR2 DEFAULT NULL
482  			   , p_local_log    IN VARCHAR2 DEFAULT NULL
483  			   , p_srv_run_id   IN NUMBER	DEFAULT NULL
484  			   , p_srv_guid     IN VARCHAR2 DEFAULT NULL
485  			   )
486  	 RETURN VARCHAR2
487    IS
488  	 l_message   VARCHAR2(32767);
489    BEGIN
490  	 l_message := main_log(p_srv_caller, p_srv_message, sosl_constants.LOG_SUCCESS_TYPE, p_identifier, p_local_log, p_srv_run_id, p_srv_guid);
491  	 RETURN l_message;
492    EXCEPTION
493  	 WHEN OTHERS THEN
494  	   -- log the error instead of RAISE
495  	   sosl_log.exception_log('sosl_server.success_log', 'SOSL_SERVER', SQLERRM);
496  	   RETURN SUBSTR(SQLERRM, 1, 4000);
497    END success_log;
498  
499    FUNCTION warning_log( p_srv_caller   IN VARCHAR2
500  			   , p_srv_message  IN VARCHAR2
501  			   , p_identifier   IN VARCHAR2 DEFAULT NULL
502  			   , p_local_log    IN VARCHAR2 DEFAULT NULL
503  			   , p_srv_run_id   IN NUMBER	DEFAULT NULL
504  			   , p_srv_guid     IN VARCHAR2 DEFAULT NULL
505  			   )
506  	 RETURN VARCHAR2
507    IS
508  	 l_message   VARCHAR2(32767);
509    BEGIN
510  	 l_message := main_log(p_srv_caller, p_srv_message, sosl_constants.LOG_WARNING_TYPE, p_identifier, p_local_log, p_srv_run_id, p_srv_guid);
511  	 RETURN l_message;
512    EXCEPTION
513  	 WHEN OTHERS THEN
514  	   -- log the error instead of RAISE
515  	   sosl_log.exception_log('sosl_server.warning_log', 'SOSL_SERVER', SQLERRM);
516  	   RETURN SUBSTR(SQLERRM, 1, 4000);
517    END warning_log;
518  
519    FUNCTION error_log( p_srv_caller   IN VARCHAR2
520  			 , p_srv_message  IN VARCHAR2
521  			 , p_identifier   IN VARCHAR2 DEFAULT NULL
522  			 , p_local_log	  IN VARCHAR2 DEFAULT NULL
523  			 , p_srv_run_id   IN NUMBER   DEFAULT NULL
524  			 , p_srv_guid	  IN VARCHAR2 DEFAULT NULL
525  			 )
526  	 RETURN VARCHAR2
527    IS
528  	 l_message   VARCHAR2(32767);
529    BEGIN
530  	 l_message := main_log(p_srv_caller, p_srv_message, sosl_constants.LOG_ERROR_TYPE, p_identifier, p_local_log, p_srv_run_id, p_srv_guid);
531  	 RETURN l_message;
532    EXCEPTION
533  	 WHEN OTHERS THEN
534  	   -- log the error instead of RAISE
535  	   sosl_log.exception_log('sosl_server.error_log', 'SOSL_SERVER', SQLERRM);
536  	   RETURN SUBSTR(SQLERRM, 1, 4000);
537    END error_log;
538  
539    FUNCTION has_scripts
540  	 RETURN NUMBER
541    IS
542  	 l_return NUMBER;
543  	 l_mode   VARCHAR2(128);
544    BEGIN
545  	 -- check config
546  	 l_mode := get_config('SOSL_RUNMODE');
547  	 IF l_mode = 'RUN'
548  	 THEN
549  	   l_return := sosl_sys.has_scripts;
550  	 ELSE
551  	   l_return := 0;
552  	 END IF;
553  	 RETURN l_return;
554    EXCEPTION
555  	 WHEN OTHERS THEN
556  	   -- log the error instead of RAISE
557  	   sosl_log.exception_log('sosl_server.has_scripts', 'SOSL_SERVER', SQLERRM);
558  	   RETURN -1;
559    END has_scripts;
560  
561    FUNCTION get_next_script
562  	 RETURN NUMBER
563    IS
564  	 l_return NUMBER;
565    BEGIN
566  	 l_return := sosl_sys.get_next_script;
567  	 RETURN l_return;
568    EXCEPTION
569  	 WHEN OTHERS THEN
570  	   -- log the error instead of RAISE
571  	   sosl_log.exception_log('sosl_server.get_next_script', 'SOSL_SERVER', SQLERRM);
572  	   RETURN -1;
573    END get_next_script;
574  
575    FUNCTION update_run_id( p_run_id      IN NUMBER
576  			     , p_identifier  IN VARCHAR2
577  			     , p_guid	     IN VARCHAR2 DEFAULT NULL
578  			     )
579  	 RETURN NUMBER
580    IS
581  	 l_return  NUMBER;
582  	 l_result  NUMBER;
583    BEGIN
584  	 l_return := -1;
585  	 l_result := sosl_server.set_identifier(p_run_id, p_identifier);
586  	 IF l_result = 0
587  	 THEN
588  	   l_return := 0;
589  	 END IF;
590  	 IF p_guid IS NOT NULL
591  	 THEN
592  	   l_result := sosl_server.set_guid(p_run_id, p_guid);
593  	   IF l_result != 0
594  	   THEN
595  	     l_return := -1;
596  	   END IF;
597  	 END IF;
598  	 RETURN l_return;
599    EXCEPTION
600  	 WHEN OTHERS THEN
601  	   -- log the error instead of RAISE
602  	   sosl_log.exception_log('sosl_server.update_run_id', 'SOSL_SERVER', SQLERRM);
603  	   RETURN -1;
604    END update_run_id;
605  
606    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
607  			  , p_recipients  IN VARCHAR2
608  			  , p_subject	  IN VARCHAR2
609  			  , p_message	  IN VARCHAR2
610  			  )
611  	 RETURN BOOLEAN
612    IS
613  	 l_result  NUMBER;
614  	 l_return  BOOLEAN;
615    BEGIN
616  	 l_result  := sosl_util.dummy_mail(p_sender, p_recipients, p_subject, p_message);
617  	 l_return  := (l_result = 0);
618  	 RETURN l_return;
619    EXCEPTION
620  	 WHEN OTHERS THEN
621  	   -- log the error instead of RAISE
622  	   sosl_log.exception_log('sosl_server.dummy_mail', 'SOSL_SERVER', SQLERRM);
623  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
624  	   RETURN FALSE;
625    END dummy_mail;
626  
627    FUNCTION has_run_id(p_run_id IN NUMBER)
628  	 RETURN BOOLEAN
629    IS
630  	 l_return BOOLEAN;
631    BEGIN
632  	 l_return := sosl_sys.has_run_id(p_run_id);
633  	 RETURN l_return;
634    EXCEPTION
635  	 WHEN OTHERS THEN
636  	   -- log the error instead of RAISE
637  	   sosl_log.exception_log('sosl_server.has_run_id', 'SOSL_SERVER', SQLERRM);
638  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
639  	   RETURN FALSE;
640    END has_run_id;
641  
642    FUNCTION get_payload(p_run_id IN NUMBER)
643  	 RETURN SOSL_PAYLOAD
644    IS
645  	 l_sosl_payload  SOSL_PAYLOAD;
646    BEGIN
647  	 l_sosl_payload := sosl_sys.get_payload(p_run_id);
648  	 RETURN l_sosl_payload;
649    EXCEPTION
650  	 WHEN OTHERS THEN
651  	   -- log the error instead of RAISE
652  	   sosl_log.exception_log('sosl_server.get_payload', 'SOSL_SERVER', SQLERRM);
653  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
654  	   RETURN NULL;
655    END get_payload;
656  
657  END;
658  /

Package body created.

SQL> -- table trigger using packages and tables defined
SQL> @@../sosl_ddl/trigger/sosl_server_log_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_server_log_ins_trg
  2    BEFORE INSERT ON sosl_server_log
  3    FOR EACH ROW
  4  DECLARE
  5    l_split		   BOOLEAN;
  6    l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_TRIGGER';
  7    l_self_caller	   sosl_server_log.caller%TYPE		 := 'sosl_server_log_ins_trg';
  8  BEGIN
  9    -- first set default value if not set, as Oracle does not support default values from package variables
 10    IF :NEW.log_type = sosl_constants.GEN_NA_TYPE
 11    THEN
 12  	 :NEW.log_type := sosl_constants.LOG_INFO_TYPE;
 13    END IF;
 14    -- instead of check constraint to get package support
 15    IF NOT sosl_log.log_type_valid(:NEW.log_type)
 16    THEN
 17  	 -- do not block logging, log the error instead, move message to full message
 18  	 :NEW.full_message := :NEW.message || :NEW.full_message;
 19  	 :NEW.message	   := 'Invalid log type. Not supported by package SOSL_SYS. Given log type: ' || NVL(:NEW.log_type, sosl_constants.GEN_NULL_TEXT);
 20  	 :NEW.log_type	   := sosl_constants.LOG_FATAL_TYPE;
 21    ELSE
 22  	 :NEW.log_type := sosl_log.get_valid_log_type(:NEW.log_type);
 23    END IF;
 24    :NEW.exec_timestamp := SYSTIMESTAMP;
 25    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'SESSION_USER');
 26    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 27    -- split messages
 28    IF NOT sosl_log.distribute(:NEW.message, :NEW.full_message, 4000)
 29    THEN
 30  	 -- do not block logging, log the error instead, if :NEW.message contains error information leave it there
 31  	 IF :NEW.message IS NULL AND :NEW.full_message IS NULL
 32  	 THEN
 33  	   :NEW.message := 'Full message must be given, if message is NULL or vice versa.';
 34  	 END IF;
 35  	 :NEW.log_type := sosl_constants.LOG_FATAL_TYPE;
 36    END IF;
 37  EXCEPTION
 38    WHEN OTHERS THEN
 39  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 40  	 RAISE;
 41  END;
 42  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_upd_trg
  2    BEFORE UPDATE ON sosl_server_log
  3  BEGIN
  4    sosl_log.minimal_error_log( 'sosl_server_log_upd_trg'
  5  				 , 'SOSL_TRIGGER'
  6  				 , '-20000 No updates allowed on a log table.'
  7  				 , 'Forbidden UPDATE on log table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
  8  				 )
  9    ;
 10    RAISE_APPLICATION_ERROR(-20000, 'No updates allowed on a log table.');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_del_trg
  2    BEFORE DELETE ON sosl_server_log
  3  BEGIN
  4    IF NOT sosl_util.has_role(SYS_CONTEXT('USERENV', 'SESSION_USER'), 'SOSL_ADMIN')
  5    THEN
  6  	 sosl_log.minimal_error_log( 'sosl_server_log_del_trg'
  7  				   , 'SOSL_TRIGGER'
  8  				   , '-20001 Delete records from a log table is not allowed. This is an admin job which needs sufficient rights and usage of the SOSL API.'
  9  				   , 'Forbidden DELETE on log table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 10  				   )
 11  	 ;
 12  	 RAISE_APPLICATION_ERROR(-20001, 'Delete records from a log table is not allowed. This is an admin job which needs sufficient rights and usage of the SOSL API.');
 13    END IF;
 14  END;
 15  /

Trigger created.

SQL> @@../sosl_ddl/trigger/sosl_config_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_config_ins_trg
  2    BEFORE INSERT ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok		   BOOLEAN;
  6    l_date		   DATE;
  7    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_CONFIG';
  8    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_config_ins_trg';
  9  BEGIN
 10    -- remove any leading and trailing blanks from config_value
 11    :NEW.config_value   := TRIM(:NEW.config_value);
 12    :NEW.created	   := SYSDATE;
 13    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'SESSION_USER');
 14    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 15    -- check max length if defined
 16    IF :NEW.config_type = 'CHAR'
 17    THEN
 18  	 IF :NEW.config_max_length > 0
 19  	 THEN
 20  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 21  	   THEN
 22  	     sosl_log.minimal_error_log( l_self_caller
 23  				       , l_self_log_category
 24  				       , '-20010 The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value)
 25  				       , 'Wrong length of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 26  				       )
 27  	     ;
 28  	     RAISE_APPLICATION_ERROR(-20010, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 29  	   END IF;
 30  	 END IF;
 31    END IF;
 32    -- check number type
 33    IF :NEW.config_type = 'NUMBER'
 34    THEN
 35  	 l_ok := TRUE;
 36  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 37  	 BEGIN
 38  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 39  	 EXCEPTION
 40  	   WHEN OTHERS THEN
 41  	     sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 42  	     l_ok := FALSE;
 43  	 END;
 44  	 IF NOT l_ok
 45  	 THEN
 46  	   sosl_log.minimal_error_log( l_self_caller
 47  				     , l_self_log_category
 48  				     , '-20011 The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.'
 49  				     , 'Wrong type of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 50  				     )
 51  	   ;
 52  	   RAISE_APPLICATION_ERROR(-20011, 'The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.');
 53  	 END IF;
 54    END IF;
 55  END;
 56  /

Trigger created.

SQL> 
SQL> CREATE OR REPLACE TRIGGER sosl_config_upd_trg
  2    BEFORE UPDATE ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok		   BOOLEAN;
  6    l_date		   DATE;
  7    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_CONFIG';
  8    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_config_upd_trg';
  9  BEGIN
 10    -- remove any leading and trailing blanks from config_value
 11    :NEW.config_value   := TRIM(:NEW.config_value);
 12    -- report intended changes on columns not allowed to change and reset values to OLD
 13    sosl_log.log_column_change(:OLD.created, :NEW.created, 'SOSL_CONFIG.CREATED', l_self_caller, TRUE);
 14    :NEW.created	   := :OLD.created;
 15    sosl_log.log_column_change(:OLD.created_by, :NEW.created_by, 'SOSL_CONFIG.CREATED_BY', l_self_caller, TRUE);
 16    :NEW.created_by	   := :OLD.created_by;
 17    sosl_log.log_column_change(:OLD.created_by_os, :NEW.created_by_os, 'SOSL_CONFIG.CREATED_BY_OS', l_self_caller, TRUE);
 18    :NEW.created_by_os  := :OLD.created_by_os;
 19    -- check changes on config_name for protected values
 20    IF     :OLD.config_name != :NEW.config_name
 21  	  AND :OLD.config_name IN ( 'SOSL_PATH_CFG'
 22  				  , 'SOSL_PATH_TMP'
 23  				  , 'SOSL_PATH_LOG'
 24  				  , 'SOSL_START_LOG'
 25  				  , 'SOSL_BASE_LOG'
 26  				  , 'SOSL_EXT_LOG'
 27  				  , 'SOSL_EXT_TMP'
 28  				  , 'SOSL_EXT_LOCK'
 29  				  , 'SOSL_EXT_ERROR'
 30  				  , 'SOSL_MAX_PARALLEL'
 31  				  , 'SOSL_RUNMODE'
 32  				  , 'SOSL_DEFAULT_WAIT'
 33  				  , 'SOSL_NOJOB_WAIT'
 34  				  , 'SOSL_PAUSE_WAIT'
 35  				  , 'SOSL_SERVER_STATE'
 36  				  , 'SOSL_START_JOBS'
 37  				  , 'SOSL_STOP_JOBS'
 38  				  , 'SOSL_SCHEMA'
 39  				  )
 40    THEN
 41  	 sosl_log.log_column_change(:OLD.config_name, :NEW.config_name, 'SOSL_CONFIG.CONFIG_NAME', l_self_caller, TRUE);
 42  	 sosl_log.minimal_error_log( l_self_caller
 43  				   , l_self_log_category
 44  				   , '-20012 The given system config_name ' || :OLD.config_name || ' cannot be changed.'
 45  				   , 'Tried to change a system config name for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 46  				   )
 47  	 ;
 48  	 RAISE_APPLICATION_ERROR(-20012, 'The given system config_name ' || :OLD.config_name || ' cannot be changed.');
 49    END IF;
 50    IF      :OLD.config_name   = 'SOSL_SCHEMA'
 51  	  AND  :OLD.config_value != :NEW.config_value
 52    THEN
 53  	 sosl_log.log_column_change(:OLD.config_value, :NEW.config_value, 'SOSL_CONFIG.CONFIG_VALUE', l_self_caller, TRUE);
 54  	 sosl_log.minimal_error_log( l_self_caller
 55  				   , l_self_log_category
 56  				   , '-20014 The SOSL_SCHEMA value ' || :OLD.config_value || ' cannot be changed.'
 57  				   , 'Tried to change SOSL_SCHEMA in SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 58  				   )
 59  	 ;
 60  	 RAISE_APPLICATION_ERROR(-20014, 'The SOSL_SCHEMA value ' || :OLD.config_value || ' cannot be changed.');
 61    END IF;
 62    -- report value changes allowed
 63    sosl_log.log_column_change(:OLD.config_value, :NEW.config_value, :OLD.config_name, l_self_caller, FALSE);
 64    -- set updated
 65    :NEW.updated	   := SYSDATE;
 66    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'SESSION_USER');
 67    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 68    -- check max length if defined
 69    IF :NEW.config_type = 'CHAR'
 70    THEN
 71  	 IF :NEW.config_max_length > 0
 72  	 THEN
 73  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 74  	   THEN
 75  	     sosl_log.minimal_error_log( l_self_caller
 76  				       , l_self_log_category
 77  				       , '-20010 The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value)
 78  				       , 'Wrong length of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 79  				       )
 80  	     ;
 81  	     RAISE_APPLICATION_ERROR(-20010, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 82  	   END IF;
 83  	 END IF;
 84    END IF;
 85    -- check number type
 86    IF :NEW.config_type = 'NUMBER'
 87    THEN
 88  	 l_ok := TRUE;
 89  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 90  	 BEGIN
 91  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 92  	 EXCEPTION
 93  	   WHEN OTHERS THEN
 94  	     sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 95  	     l_ok := FALSE;
 96  	 END;
 97  	 IF NOT l_ok
 98  	 THEN
 99  	   sosl_log.minimal_error_log( l_self_caller
100  				     , l_self_log_category
101  				     , '-20011 The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.'
102  				     , 'Wrong type of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
103  				     )
104  	   ;
105  	   RAISE_APPLICATION_ERROR(-20011, 'The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.');
106  	 END IF;
107    END IF;
108    -- check run mode
109    IF     :OLD.config_name	     = 'SOSL_RUNMODE'
110  	  AND :OLD.config_value     != :NEW.config_value
111  	  AND :NEW.config_value NOT IN (sosl_constants.SERVER_RUN_MODE, sosl_constants.SERVER_PAUSE_MODE, sosl_constants.SERVER_STOP_MODE)
112    THEN
113  	   sosl_log.minimal_error_log( l_self_caller
114  				     , l_self_log_category
115  				     , '-20015 The given runmode "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" is not supported, only RUN, PAUSE or STOP accepted.'
116  				     , 'Wrong type of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
117  				     )
118  	   ;
119  	 RAISE_APPLICATION_ERROR(-20015, 'The given runmode "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" is not supported, only RUN, PAUSE or STOP accepted.');
120    END IF;
121    -- check server state
122    IF     :OLD.config_name	     = 'SOSL_SERVER_STATE'
123  	  AND :OLD.config_value     != :NEW.config_value
124  	  AND :NEW.config_value NOT IN ('ACTIVE', 'INACTIVE')
125    THEN
126  	   sosl_log.minimal_error_log( l_self_caller
127  				     , l_self_log_category
128  				     , '-20016 The given server state "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" is not supported, only ACTIVE or INACTIVE accepted.'
129  				     , 'Wrong type of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
130  				     )
131  	   ;
132  	 RAISE_APPLICATION_ERROR(-20016, 'The given server state "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" is not supported, only ACTIVE or INACTIVE accepted.');
133    END IF;
134    -- check start and stop times
135    IF     :OLD.config_name	    IN ('SOSL_START_JOBS', 'SOSL_STOP_JOBS')
136  	  AND :OLD.config_value     != :NEW.config_value
137    THEN
138  	 IF    SUBSTR(:NEW.config_value, 3, 1) != ':'
139  	    OR NOT REGEXP_LIKE(SUBSTR(:NEW.config_value, 1, 2), '^[0-9][0-9]')
140  	    OR NOT REGEXP_LIKE(SUBSTR(:NEW.config_value, 4, 5), '^[0-9][0-9]')
141  	 THEN
142  	   sosl_log.minimal_error_log( l_self_caller
143  				     , l_self_log_category
144  				     , '-20017 The given time frame "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" for start and stop times is not supported. Format is HH24:MI with leading zeros, e.g. 05:04 and must be a valid time.'
145  				     , 'Wrong type of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
146  				     )
147  	   ;
148  	   RAISE_APPLICATION_ERROR(-20017, 'The given time frame "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" for start and stop times is not supported. Format is HH24:MI with leading zeros, e.g. 05:04 and must be a valid time.');
149  	 END IF;
150  	 -- check times
151  	 IF    TO_NUMBER(SUBSTR(:NEW.config_value, 1, 2)) > 23
152  	    OR TO_NUMBER(SUBSTR(:NEW.config_value, 4, 5)) > 59
153  	 THEN
154  	   sosl_log.minimal_error_log( l_self_caller
155  				     , l_self_log_category
156  				     , '-20017 The given time frame "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" for start and stop times is not supported. Format is HH24:MI with leading zeros, e.g. 05:04 and must be a valid time.'
157  				     , 'Wrong type of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
158  				     )
159  	   ;
160  	   RAISE_APPLICATION_ERROR(-20017, 'The given time frame "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" for start and stop times is not supported. Format is HH24:MI with leading zeros, e.g. 05:04 and must be a valid time.');
161  	 END IF;
162    END IF;
163  END;
164  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_config_del_trg
  2    BEFORE DELETE ON sosl_config
  3    FOR EACH ROW
  4  BEGIN
  5    -- protect system parameters from delete
  6    IF :OLD.config_name IN ( 'SOSL_PATH_CFG'
  7  			      , 'SOSL_PATH_TMP'
  8  			      , 'SOSL_PATH_LOG'
  9  			      , 'SOSL_START_LOG'
 10  			      , 'SOSL_BASE_LOG'
 11  			      , 'SOSL_EXT_LOG'
 12  			      , 'SOSL_EXT_TMP'
 13  			      , 'SOSL_EXT_LOCK'
 14  			      , 'SOSL_EXT_ERROR'
 15  			      , 'SOSL_MAX_PARALLEL'
 16  			      , 'SOSL_RUNMODE'
 17  			      , 'SOSL_DEFAULT_WAIT'
 18  			      , 'SOSL_NOJOB_WAIT'
 19  			      , 'SOSL_PAUSE_WAIT'
 20  			      , 'SOSL_SERVER_STATE'
 21  			      , 'SOSL_START_JOBS'
 22  			      , 'SOSL_STOP_JOBS'
 23  			      , 'SOSL_SCHEMA'
 24  			      )
 25    THEN
 26  	 sosl_log.minimal_error_log( 'sosl_config_del_trg'
 27  				   , 'SOSL_CONFIG'
 28  				   , '-20013 The given system config_name "' || :OLD.config_name || '" cannot be deleted.'
 29  				   , 'Forbidden delete of config name for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 30  				   )
 31  	 ;
 32  	 RAISE_APPLICATION_ERROR(-20013, 'The given system config_name "' || :OLD.config_name || '" cannot be deleted.');
 33    END IF;
 34  END;
 35  /

Trigger created.

SQL> 
SQL> @@../sosl_ddl/trigger/sosl_executor_definition_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_executor_definition_ins_trg
  2    BEFORE INSERT ON sosl_executor_definition
  3    FOR EACH ROW
  4  DECLARE
  5    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_EXECUTOR_DEFINITION';
  6    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_executor_definition_ins_trg';
  7  BEGIN
  8    :NEW.created	       := SYSDATE;
  9    :NEW.created_by	       := SYS_CONTEXT('USERENV', 'SESSION_USER');
 10    :NEW.created_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 11    :NEW.updated	       := SYSDATE;
 12    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'SESSION_USER');
 13    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 14    :NEW.executor_active    := 0;
 15    :NEW.executor_reviewed  := 0;
 16    -- transform users and functions to UPPERCASE, no support currently for special mix-case.
 17    :NEW.function_owner	 := UPPER(:NEW.function_owner);
 18    :NEW.db_user		 := UPPER(:NEW.db_user);
 19    :NEW.fn_has_scripts	 := UPPER(:NEW.fn_has_scripts);
 20    :NEW.fn_get_next_script	 := UPPER(:NEW.fn_get_next_script);
 21    :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 22    :NEW.fn_send_db_mail	 := UPPER(:NEW.fn_send_db_mail);
 23    -- check user
 24    IF NOT sosl_util.has_db_user(:NEW.db_user)
 25    THEN
 26  	 sosl_log.minimal_error_log( l_self_caller
 27  				   , l_self_log_category
 28  				   , '-20020 The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 29  				   , 'Wrong database user for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 30  				   )
 31  	 ;
 32  	 RAISE_APPLICATION_ERROR(-20020, 'The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 33    END IF;
 34    IF NOT sosl_util.has_db_user(:NEW.function_owner)
 35    THEN
 36  	 sosl_log.minimal_error_log( l_self_caller
 37  				   , l_self_log_category
 38  				   , '-20021 The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 39  				   , 'Wrong function owner for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 40  				   )
 41  	 ;
 42  	 RAISE_APPLICATION_ERROR(-20021, 'The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 43    END IF;
 44    -- check configured functions
 45    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 46    THEN
 47  	 sosl_log.minimal_error_log( l_self_caller
 48  				   , l_self_log_category
 49  				   , '-20022 The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 50  				   , 'Wrong function has_scripts for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 51  				   )
 52  	 ;
 53  	 RAISE_APPLICATION_ERROR(-20022, 'The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 54    END IF;
 55    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'OBJECT')
 56    THEN
 57  	 sosl_log.minimal_error_log( l_self_caller
 58  				   , l_self_log_category
 59  				   , '-20023 The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 60  				   , 'Wrong function get_next_script for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 61  				   )
 62  	 ;
 63  	 RAISE_APPLICATION_ERROR(-20023, 'The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 64    END IF;
 65    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
 66    THEN
 67  	 sosl_log.minimal_error_log( l_self_caller
 68  				   , l_self_log_category
 69  				   , '-20024 The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 70  				   , 'Wrong function set_script_status for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 71  				   )
 72  	 ;
 73  	 RAISE_APPLICATION_ERROR(-20024, 'The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 74    END IF;
 75    -- check mail
 76    IF :NEW.use_mail = 1
 77    THEN
 78  	 IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
 79  	 THEN
 80  	   sosl_log.minimal_error_log( l_self_caller
 81  				     , l_self_log_category
 82  				     , '-20025 The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 83  				     , 'Wrong function send_db_mail for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 84  				     )
 85  	   ;
 86  	   RAISE_APPLICATION_ERROR(-20025, 'The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 87  	 END IF;
 88    END IF;
 89    -- log the insert
 90    sosl_log.minimal_info_log( l_self_caller
 91  				, l_self_log_category
 92  				, 'A new executor named ' || :NEW.executor_name || ' for DB user: ' || :NEW.db_user || ' with function owner: ' || :NEW.function_owner || ' is about to be created.'
 93  				)
 94    ;
 95  EXCEPTION
 96    WHEN OTHERS THEN
 97  	 -- catch and log all undefined exceptions
 98  	 IF SQLCODE NOT IN (-20005, -20006, -20007, -20008, -20009, -20010)
 99  	 THEN
100  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
101  	 END IF;
102  	 -- raise all errors
103  	 RAISE;
104  END;
105  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_executor_definition_upd_trg
  2    BEFORE UPDATE ON sosl_executor_definition
  3    FOR EACH ROW
  4  DECLARE
  5    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_EXECUTOR_DEFINITION';
  6    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_executor_definition_upd_trg';
  7  BEGIN
  8    :NEW.updated	   := SYSDATE;
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'SESSION_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11    -- no overwrite for this values, log changes
 12    sosl_log.log_column_change(:OLD.created, :NEW.created, 'SOSL_EXECUTOR_DEFINITION.CREATED', l_self_caller);
 13    :NEW.created := :OLD.created;
 14    sosl_log.log_column_change(:OLD.created_by, :NEW.created_by, 'SOSL_EXECUTOR_DEFINITION.CREATED_BY', l_self_caller);
 15    :NEW.created_by := :OLD.created_by;
 16    sosl_log.log_column_change(:OLD.created_by_os, :NEW.created_by_os, 'SOSL_EXECUTOR_DEFINITION.CREATED_BY_OS', l_self_caller);
 17    :NEW.created_by_os := :OLD.created_by_os;
 18    sosl_log.log_column_change(:OLD.function_owner, :NEW.function_owner, 'SOSL_EXECUTOR_DEFINITION.FUNCTION_OWNER', l_self_caller);
 19    :NEW.function_owner := :OLD.function_owner;
 20    sosl_log.log_column_change(:OLD.db_user, :NEW.db_user, 'SOSL_EXECUTOR_DEFINITION.DB_USER', l_self_caller);
 21    :NEW.db_user := :OLD.db_user;
 22    -- prepare possibly modified values
 23    sosl_log.log_column_change(:OLD.executor_active, :NEW.executor_active, 'SOSL_EXECUTOR_DEFINITION.EXECUTOR_ACTIVE', l_self_caller, FALSE);
 24    sosl_log.log_column_change(:OLD.executor_reviewed, :NEW.executor_reviewed, 'SOSL_EXECUTOR_DEFINITION.EXECUTOR_REVIEWED', l_self_caller, FALSE);
 25    sosl_log.log_column_change(:OLD.use_mail, :NEW.use_mail, 'SOSL_EXECUTOR_DEFINITION.USE_MAIL', l_self_caller, FALSE);
 26    sosl_log.log_column_change(:OLD.fn_has_scripts, :NEW.fn_has_scripts, 'SOSL_EXECUTOR_DEFINITION.FN_HAS_SCRIPTS', l_self_caller, FALSE);
 27    :NEW.fn_has_scripts := UPPER(:NEW.fn_has_scripts);
 28    sosl_log.log_column_change(:OLD.fn_get_next_script, :NEW.fn_get_next_script, 'SOSL_EXECUTOR_DEFINITION.FN_GET_NEXT_SCRIPT', l_self_caller, FALSE);
 29    :NEW.fn_get_next_script := UPPER(:NEW.fn_get_next_script);
 30    sosl_log.log_column_change(:OLD.fn_set_script_status, :NEW.fn_set_script_status, 'SOSL_EXECUTOR_DEFINITION.FN_SET_SCRIPT_STATUS', l_self_caller, FALSE);
 31    :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 32    sosl_log.log_column_change(:OLD.fn_send_db_mail, :NEW.fn_send_db_mail, 'SOSL_EXECUTOR_DEFINITION.FN_SEND_DB_MAIL', l_self_caller, FALSE);
 33    :NEW.fn_send_db_mail := UPPER(:NEW.fn_send_db_mail);
 34    -- do all checks again including user
 35    -- check user
 36    IF NOT sosl_util.has_db_user(:NEW.db_user)
 37    THEN
 38  	 sosl_log.minimal_error_log( l_self_caller
 39  				   , l_self_log_category
 40  				   , '-20020 The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 41  				   , 'Wrong database user for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 42  				   )
 43  	 ;
 44  	 RAISE_APPLICATION_ERROR(-20020, 'The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 45    END IF;
 46    IF NOT sosl_util.has_db_user(:NEW.function_owner)
 47    THEN
 48  	 sosl_log.minimal_error_log( l_self_caller
 49  				   , l_self_log_category
 50  				   , '-20021 The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 51  				   , 'Wrong function owner for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 52  				   )
 53  	 ;
 54  	 RAISE_APPLICATION_ERROR(-20021, 'The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 55    END IF;
 56    -- check configured functions
 57    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 58    THEN
 59  	 sosl_log.minimal_error_log( l_self_caller
 60  				   , l_self_log_category
 61  				   , '-20022 The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 62  				   , 'Wrong function has_scripts for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 63  				   )
 64  	 ;
 65  	 RAISE_APPLICATION_ERROR(-20022, 'The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 66    END IF;
 67    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'OBJECT')
 68    THEN
 69  	 sosl_log.minimal_error_log( l_self_caller
 70  				   , l_self_log_category
 71  				   , '-20023 The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 72  				   , 'Wrong function get_next_script for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 73  				   )
 74  	 ;
 75  	 RAISE_APPLICATION_ERROR(-20023, 'The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 76    END IF;
 77    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
 78    THEN
 79  	 sosl_log.minimal_error_log( l_self_caller
 80  				   , l_self_log_category
 81  				   , '-20024 The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 82  				   , 'Wrong function set_script_status for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 83  				   )
 84  	 ;
 85  	 RAISE_APPLICATION_ERROR(-20024, 'The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 86    END IF;
 87    -- check mail
 88    IF :NEW.use_mail = 1
 89    THEN
 90  	 IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
 91  	 THEN
 92  	   sosl_log.minimal_error_log( l_self_caller
 93  				     , l_self_log_category
 94  				     , '-20025 The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 95  				     , 'Wrong function send_db_mail for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 96  				     )
 97  	   ;
 98  	   RAISE_APPLICATION_ERROR(-20025, 'The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 99  	 END IF;
100    END IF;
101    -- check grants if active and reviewed
102    IF      :NEW.executor_active    = sosl_constants.NUM_YES
103  	  AND  :NEW.executor_reviewed  = sosl_constants.NUM_YES
104    THEN
105  	 IF    NOT sosl_util.grant_role(:NEW.db_user, 'SOSL_USER')
106  	    OR NOT sosl_util.grant_role(:NEW.function_owner, 'SOSL_EXECUTOR')
107  	 THEN
108  	   -- could not check or grant role to database user or function owner
109  	   sosl_log.minimal_error_log( l_self_caller
110  				     , l_self_log_category
111  				     , '-20026 Error granting necessary roles to db user (SOSL_USER) or function owner (SOSL_EXECUTOR). Check setup and roles. Probably grant the roles manually before trying update again.'
112  				     , 'Failed granting necessary roles for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'SESSION_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
113  				     )
114  	   ;
115  	   RAISE_APPLICATION_ERROR(-20026, 'Error granting necessary roles to db user (SOSL_USER) or function owner (SOSL_EXECUTOR). Check setup and roles. Probably grant the roles manually before trying update again.');
116  	 END IF;
117    END IF;
118    -- log the update
119    sosl_log.minimal_info_log( l_self_caller
120  				, l_self_log_category
121  				, 'The configuration for executor ID: ' || :OLD.executor_id || ' named ' || :OLD.executor_name || ' is ready to be updated.'
122  				)
123    ;
124  EXCEPTION
125    WHEN OTHERS THEN
126  	 -- catch and log all undefined exceptions
127  	 IF SQLCODE NOT IN (-20005, -20006, -20007, -20008, -20009, -20010, -20011)
128  	 THEN
129  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
130  	 END IF;
131  	 -- raise all errors
132  	 RAISE;
133  END;
134  /

Trigger created.

SQL> @@../sosl_ddl/trigger/sosl_run_queue_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_run_queue_ins_trg
  2    BEFORE INSERT ON sosl_run_queue
  3    FOR EACH ROW
  4  DECLARE
  5    l_executor_valid    NUMBER;
  6    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_RUN_QUEUE';
  7    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_run_queue_ins_trg';
  8  BEGIN
  9    -- check executor, if not accepted and reviewed, set run state to error, else waiting
 10    IF sosl_sys.is_executor_valid(:NEW.executor_id)
 11    THEN
 12  	 :NEW.run_state      := sosl_constants.RUN_STATE_WAITING;
 13  	 :NEW.waiting	     := SYSTIMESTAMP;
 14  	 :NEW.waiting_by     := SYS_CONTEXT('USERENV', 'SESSION_USER');
 15  	 :NEW.waiting_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 16  	 :NEW.finished	     := NULL;
 17  	 :NEW.finished_by    := NULL;
 18  	 :NEW.finished_by_os := NULL;
 19    ELSE
 20  	 -- log error
 21  	 sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Given executor id ' || :NEW.executor_id || ' is not active and reviewed. Script execution not allowed.');
 22  	 :NEW.run_state      := sosl_constants.RUN_STATE_ERROR;
 23  	 :NEW.waiting	     := NULL;
 24  	 :NEW.waiting_by     := NULL;
 25  	 :NEW.waiting_by_os  := NULL;
 26  	 :NEW.finished	     := SYSTIMESTAMP;
 27  	 :NEW.finished_by    := SYS_CONTEXT('USERENV', 'SESSION_USER');
 28  	 :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 29    END IF;
 30    -- set basic timestamps
 31    :NEW.created	   := SYSTIMESTAMP;
 32    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'SESSION_USER');
 33    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 34    -- overwrite any other injected dates and user on insert
 35    :NEW.enqueued	   := NULL;
 36    :NEW.enqueued_by    := NULL;
 37    :NEW.enqueued_by_os := NULL;
 38    :NEW.started	   := NULL;
 39    :NEW.started_by	   := NULL;
 40    :NEW.started_by_os  := NULL;
 41    :NEW.running_since  := NULL;
 42    :NEW.running_by	   := NULL;
 43    :NEW.running_by_os  := NULL;
 44    -- log the insert
 45    sosl_log.minimal_info_log( l_self_caller
 46  				, l_self_log_category
 47  				, 'A new script with run id ' || :NEW.run_id || ' is prepared to be added to the run queue created by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 48  				)
 49    ;
 50  EXCEPTION
 51    WHEN OTHERS THEN
 52  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 53  	 -- raise all errors
 54  	 RAISE;
 55  END;
 56  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_run_queue_upd_trg
  2    BEFORE UPDATE ON sosl_run_queue
  3    FOR EACH ROW
  4  DECLARE
  5    l_executor_valid    NUMBER;
  6    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_RUN_QUEUE';
  7    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_run_queue_upd_trg';
  8  BEGIN
  9    -- make sure created and basics are not changed
 10    sosl_log.log_column_change(:NEW.created, :OLD.created, 'SOSL_RUN_QUEUE.CREATED', l_self_caller);
 11    :NEW.created	   := :OLD.created;
 12    sosl_log.log_column_change(:NEW.created_by, :OLD.created_by, 'SOSL_RUN_QUEUE.CREATED_BY', l_self_caller);
 13    :NEW.created_by	   := :OLD.created_by;
 14    sosl_log.log_column_change(:NEW.created_by_os, :OLD.created_by_os, 'SOSL_RUN_QUEUE.CREATED_BY_OS', l_self_caller);
 15    :NEW.created_by_os  := :OLD.created_by_os;
 16    sosl_log.log_column_change(:NEW.executor_id, :OLD.executor_id, 'SOSL_RUN_QUEUE.EXECUTOR_ID', l_self_caller);
 17    :NEW.executor_id    := :OLD.executor_id;
 18    sosl_log.log_column_change(:NEW.ext_script_id, :OLD.ext_script_id, 'SOSL_RUN_QUEUE.EXT_SCRIPT_ID', l_self_caller);
 19    :NEW.ext_script_id  := :OLD.ext_script_id;
 20    sosl_log.log_column_change(:NEW.script_file, :OLD.script_file, 'SOSL_RUN_QUEUE.SCRIPT_FILE', l_self_caller);
 21    :NEW.script_file    := :OLD.script_file;
 22    -- check run state order, error can always be set
 23    IF :NEW.run_state != sosl_constants.RUN_STATE_ERROR
 24    THEN
 25  	 -- only if run state has changed
 26  	 IF :NEW.run_state != :OLD.run_state
 27  	 THEN
 28  	   -- normal transitions, organized as ordered sequence numbers 0 to 4
 29  	   -- WAITING -> ENQUEUED, ENQUEUED -> STARTED, STARTED -> RUNNING, RUNNING -> FINISHED
 30  	   IF	  (   :OLD.run_state = sosl_constants.RUN_STATE_ERROR
 31  		   OR :OLD.run_state = sosl_constants.RUN_STATE_FINISHED
 32  		  )
 33  	   THEN
 34  	     -- log it
 35  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Final run states cannot be changed: ' || sosl_constants.run_state_text(:OLD.run_state) || ' not allowed to change to ' || sosl_constants.run_state_text(:NEW.run_state) || '. State left unchanged.');
 36  	     -- ignore invalid run state, leave state unchanged
 37  	     :NEW.run_state := :OLD.run_state;
 38  	   ELSE
 39  	     -- next state must be exactly old run state +1
 40  	     IF :NEW.run_state != (:OLD.run_state + 1)
 41  	     THEN
 42  	       -- log it
 43  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Wrong state transition: ' || sosl_constants.run_state_text(:OLD.run_state) || ' not allowed to change to ' || sosl_constants.run_state_text(:NEW.run_state) || '. State set to ERROR.');
 44  	       -- ignore invalid run state, set state to error
 45  	       :NEW.run_state := sosl_constants.RUN_STATE_ERROR;
 46  	     END IF;
 47  	   END IF;
 48  	 END IF;
 49    END IF;
 50    -- check executor and prevent updates on run state if not valid, set run state to error if executor not valid
 51    IF sosl_sys.is_executor_valid(:NEW.executor_id)
 52    THEN
 53  	-- update dates and user by run state
 54  	 CASE :NEW.run_state
 55  	   WHEN sosl_constants.RUN_STATE_WAITING THEN
 56  	     :NEW.waiting	 := SYSTIMESTAMP;
 57  	     :NEW.waiting_by	 := SYS_CONTEXT('USERENV', 'SESSION_USER');
 58  	     :NEW.waiting_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 59  	   WHEN sosl_constants.RUN_STATE_ENQUEUED THEN
 60  	     :NEW.enqueued	 := SYSTIMESTAMP;
 61  	     :NEW.enqueued_by	 := SYS_CONTEXT('USERENV', 'SESSION_USER');
 62  	     :NEW.enqueued_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 63  	   WHEN sosl_constants.RUN_STATE_STARTED THEN
 64  	     :NEW.started	 := SYSTIMESTAMP;
 65  	     :NEW.started_by	 := SYS_CONTEXT('USERENV', 'SESSION_USER');
 66  	     :NEW.started_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 67  	   WHEN sosl_constants.RUN_STATE_RUNNING THEN
 68  	     :NEW.running_since  := SYSTIMESTAMP;
 69  	     :NEW.running_by	 := SYS_CONTEXT('USERENV', 'SESSION_USER');
 70  	     :NEW.running_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 71  	   WHEN sosl_constants.RUN_STATE_FINISHED THEN
 72  	     :NEW.finished	 := SYSTIMESTAMP;
 73  	     :NEW.finished_by	 := SYS_CONTEXT('USERENV', 'SESSION_USER');
 74  	     :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 75  	   ELSE
 76  	     -- any other state is an error state
 77  	     :NEW.finished	 := SYSTIMESTAMP;
 78  	     :NEW.finished_by	 := SYS_CONTEXT('USERENV', 'SESSION_USER');
 79  	     :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 80  	     :NEW.run_state	 := sosl_constants.RUN_STATE_ERROR;
 81  	 END CASE;
 82    ELSE
 83  	 -- log error
 84  	 sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Current executor id ' || :NEW.executor_id || ' is not longer active and reviewed. Script execution not allowed.');
 85  	 -- set run state to error in any case
 86  	 :NEW.run_state      := sosl_constants.RUN_STATE_ERROR;
 87  	 :NEW.enqueued	     := :OLD.enqueued;
 88  	 :NEW.enqueued_by    := :OLD.enqueued_by;
 89  	 :NEW.enqueued_by_os := :OLD.enqueued_by_os;
 90  	 :NEW.started	     := :OLD.started;
 91  	 :NEW.started_by     := :OLD.started_by;
 92  	 :NEW.started_by_os  := :OLD.started_by_os;
 93  	 :NEW.running_since  := :OLD.running_since;
 94  	 :NEW.running_by     := :OLD.running_by;
 95  	 :NEW.running_by_os  := :OLD.running_by_os;
 96  	 :NEW.finished	     := :OLD.finished;
 97  	 :NEW.finished_by    := :OLD.finished_by;
 98  	 :NEW.finished_by_os := :OLD.finished_by_os;
 99    END IF;
100    -- log the update
101    sosl_log.minimal_info_log( l_self_caller
102  				, l_self_log_category
103  				, 'Prepared the update for run id ' || :OLD.run_id || ' by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
104  				)
105    ;
106  EXCEPTION
107    WHEN OTHERS THEN
108  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
109  	 -- raise all errors
110  	 RAISE;
111  END;
112  /

Trigger created.

SQL> @@../sosl_ddl/trigger/sosl_if_script_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_if_script_ins_trg
  2    BEFORE INSERT ON sosl_if_script
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := NULL;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'SESSION_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := NULL;
 10    :NEW.updated_by_os  := NULL;
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_if_script_upd_trg
  2    BEFORE UPDATE ON sosl_if_script
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    :NEW.updated	   := SYSDATE;
 10    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'SESSION_USER');
 11    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12  END;
 13  /

Trigger created.

SQL> -- load basic config data
SQL> @@sosl_config_defaults.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- load default values that can be configured in the database (mandatory)
SQL> -- basic configuration
SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_RUNMODE', 'RUN', 'CHAR', 5, 'Determines if the server should RUN, PAUSE or STOP. Read by the SOSL server. RUN will cause the SOSL server, if started to run as long as it does not get a STOP signal from the database. Set it to STOP to stop the SOSL server. Set to PAUSE if the server should not call any script apart the check for the run mode. Can be locally overwritten.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAX_PARALLEL', '8', 'NUMBER', 'The maximum of parallel started scripts. Read by the SOSL server. After this amount if scripts is started, next scripts are only loaded, if the run count is below this value.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_DEFAULT_WAIT', '1', 'NUMBER', 'Determines the normal sleep time in seconds the sosl server has between calls if scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_NOJOB_WAIT', '120', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if no scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_PAUSE_WAIT', '3600', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if run mode is set to wait. This wait time is also used, if the server detects that it is running out of the given timeframe.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_SERVER_STATE', 'INACTIVE', 'Information only. SOSL server sets this flag to ACTIVE if started, INACTIVE if stopped and PAUSE if waiting. If server is broken, the state is probably not reflecting the real server state.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_START_JOBS', '00:00', 5, 'Defines the hour:minutes (24 hour format with leading zeros) where SOSL should start running scripts. If set to -1 this parameter is ignored and SOSL server runs until stopped. Otherwise the server will not start to request scripts before this hour. Either both hours are given for start and stop or -1 on one value deactivates the time frame.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_STOP_JOBS', '23:59', 5, 'Defines the hour:minutes (24 hour format with leading zeros) where SOSL should stop running scripts. If set to -1 this parameter is ignored and SOSL server runs until stopped. Otherwise the server will stop to request scripts after this hour. Either both hours are given for start and stop or -1 on one value deactivates the time frame.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_CFG', '..\..\sosl_cfg\', 4000, 'Information only. The relative path with delimiter at path end to configuration files the SOSL server uses for SOSL logins. Set by SOSL server. As configuration files contain credentials and secrets the path should be in a safe space with controlled user rights.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_TMP', '..\..\sosl_tmp\', 239, 'Information only. The relative path with delimiter at path end to temporary files the SOSL server uses. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_LOG', '..\..\sosl_log\', 239, 'Information only. The relative path with delimiter at path end to log files the SOSL server creates. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_START_LOG', 'sosl_server', 'Information only. The log filename for start and end of SOSL server CMD. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_BASE_LOG', 'sosl_job_', 'Information only. The base log filename for single job runs. Will be extended by GUID. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOG', 'log', 'Information only. The log file extension to use. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_TMP', 'tmp', 'Information only. The log file extension for temporary logs to use. On error those file extension will be renamed to SOSL_EXT_ERROR extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOCK', 'lock', 'Information only. The default process lock file extension. Lock files will always get deleted either on service start or after a run. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_ERROR', 'err', 'Information only. The default process error file extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_SCHEMA', TRIM(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')), 128, 'Information only. The schema SOSL uses. Defined on setup. No update or delete allowed.')
  5  ;

1 row created.

SQL> COMMIT;

Commit complete.

SQL> -- internal interface definition for simple script execution
SQL> @@../sosl_ddl/packages/sosl_if.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- interface package of the Simple Oracle Script Loader
SQL> -- As this package depends on the schema SOSL is installed, getting fully qualified calls must be determined
SQL> -- dynamically using SQLPlus variable SOSL_SCHEMA. Fully qualifying is only used for example code of interfacing.
SQL> COLUMN SOSL_SCHEMA NEW_VAL SOSL_SCHEMA
SQL> SELECT config_value AS SOSL_SCHEMA FROM sosl_config WHERE config_name = 'SOSL_SCHEMA';
SOSL

1 row selected.

SQL> 
SQL> CREATE OR REPLACE PACKAGE sosl_if
  2  AS
  3    /**
  4    * This package contains the internal interface to SOSL used by the Simple Oracle Script Loader.
  5    * Can be seen as tutorial and implementation hint for own interfaces.
  6    */
  7  
  8    /** Function SOSL_IF.HAS_SCRIPTS
  9    * Determines if script ids are available to be executed. To be defined in SOSL_EXECUTOR_DEFINITION.
 10    *
 11    * @return The number of script ids waiting for execution.
 12    */
 13    FUNCTION has_scripts
 14  	 RETURN NUMBER
 15    ;
 16  
 17    /** Function SOSL_IF.GET_NEXT_SCRIPT
 18    * Returns the details of the next script to execute. SOSL_PAYLOAD contains the EXECUTOR_ID from SOSL_EXECUTOR_DEFINITION,
 19    * the EXT_SCRIPT_ID as used in SOSL_IF_SCRIPT.SCRIPT_ID and the SCRIPT_FILE as defined in SOSL_IF_SCRIPT.SCRIPT_NAME.
 20    * To be defined in SOSL_EXECUTOR_DEFINITION.
 21    *
 22    * @return The details of the next script to execute as SOSL_PAYLOAD object or NULL on errors.
 23    */
 24    FUNCTION get_next_script
 25  	 RETURN &SOSL_SCHEMA..SOSL_PAYLOAD
 26    ;
 27  
 28    /** Function SOSL_IF.SET_SCRIPT_STATUS
 29    * Sets the status of a script in SOSL_IF_SCRIPT. Collects needed data based on RUN_ID. To be defined in SOSL_EXECUTOR_DEFINITION.
 30    *
 31    * @param p_run_id The valid run id of the script that should change run state.
 32    * @param p_status A valid status as defined in SOSL_CONSTANTS for run states.
 33    *
 34    * @return Return 0 if successful executed otherwise -1.
 35    */
 36    FUNCTION set_script_status( p_run_id IN NUMBER
 37  				 , p_status IN NUMBER
 38  				 )
 39  	 RETURN NUMBER
 40    ;
 41  
 42    /* FUNCTION SOSL_IF.SEND_MAIL
 43    * This interface function is mainly used for testing. It will only send the mail message to SOSL_SERVER_LOG. Will be called on every
 44    * status change, if mail is activated. Collects needed data based on RUN_ID.
 45    * To be defined in SOSL_EXECUTOR_DEFINITION if USE_MAIL is activated.
 46    *
 47    * @param p_run_id The valid run id of the script that should send a mail on changing run state.
 48    * @param p_status A valid status as defined in SOSL_CONSTANTS for run states.
 49    *
 50    * @return Return 0 if successful executed otherwise -1.
 51    */
 52    FUNCTION send_mail( p_run_id IN NUMBER
 53  			 , p_status IN NUMBER
 54  			 )
 55  	 RETURN NUMBER
 56    ;
 57  
 58    /* FUNCTION SOSL_IF.ADD_SCRIPT
 59    * Adds a new script to SOSL_IF_SCRIPT.
 60    *
 61    * @param p_script_name The script filename including relative or full path. Must exist on the server SOSL is running.
 62    * @param p_executor_id The executor id associated with the script. NULL allowed. Scripts without executor are never executed by SOSL.
 63    * @param p_run_order The order in which the script should be executed. Equal order numbers mean random execution of ths script.
 64    * @param p_script_active Sets the script to active (1) or inactive (0). Only active scripts are executed.
 65    *
 66    * @return Return the new script id or -1 on errors.
 67    */
 68    FUNCTION add_script( p_script_name    IN VARCHAR2
 69  			  , p_executor_id    IN NUMBER
 70  			  , p_run_order      IN NUMBER	 DEFAULT 1
 71  			  , p_script_active  IN NUMBER	 DEFAULT 0
 72  			  )
 73  	 RETURN NUMBER
 74    ;
 75  
 76    /* FUNCTION SOSL_IF.SET_RUN_STATE
 77    * Sets the run state of a script. Scripts with a run state other than 0 are not
 78    * considered by SOSL for execution or a probably executed currently by SOSL.
 79    *
 80    * @param p_script_id The id of the script to change the run state.
 81    * @param p_run_state A valid status as defined in SOSL_CONSTANTS for run states.
 82    *
 83    * @return Return 0 if successful executed otherwise -1.
 84    */
 85    FUNCTION set_run_state( p_script_id IN NUMBER
 86  			     , p_run_state IN NUMBER DEFAULT 0
 87  			     )
 88  	 RETURN NUMBER
 89    ;
 90  
 91    /* FUNCTION SOSL_IF.SET_ACTIVE_STATE
 92    * Sets the usage state of a script. Inactive scripts are not executed by SOSL.
 93    *
 94    * @param p_script_id The id of the script to change the script state.
 95    * @param p_script_active The usage state of the script. Either active (1) or inactive (0).
 96    *
 97    * @return Return 0 if successful executed otherwise -1.
 98    */
 99    FUNCTION set_active_state( p_script_id	   IN NUMBER
100  				, p_script_active  IN NUMBER DEFAULT 0
101  				)
102  	 RETURN NUMBER
103    ;
104  
105    /* FUNCTION SOSL_IF.RESET_SCRIPTS
106    * Resets all scripts to run_state 0, so they can be executed again.
107    *
108    * @return Return 0 if successful executed otherwise -1.
109    */
110    FUNCTION reset_scripts
111  	 RETURN NUMBER
112    ;
113  
114    /* FUNCTION SOSL_IF.ACTIVATE_SCRIPTS
115    * Activate all scripts, so they can be executed depending on the state.
116    *
117    * @return Return 0 if successful executed otherwise -1.
118    */
119    FUNCTION activate_scripts
120  	 RETURN NUMBER
121    ;
122  
123    /* FUNCTION SOSL_IF.DEACTIVATE_SCRIPTS
124    * Dectivate all scripts, so they cannot be executed.
125    *
126    * @return Return 0 if successful executed otherwise -1.
127    */
128    FUNCTION deactivate_scripts
129  	 RETURN NUMBER
130    ;
131  
132  END;
133  /
old  25:     RETURN &SOSL_SCHEMA..SOSL_PAYLOAD
new  25:     RETURN SOSL.SOSL_PAYLOAD

Package created.

SQL> @@../sosl_ddl/packages/sosl_if.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- As this package depends on the schema SOSL is installed, getting fully qualified calls must be determined
SQL> -- dynamically using SQLPlus variable SOSL_SCHEMA.
SQL> COLUMN SOSL_SCHEMA NEW_VAL SOSL_SCHEMA
SQL> SELECT config_value AS SOSL_SCHEMA FROM sosl_config WHERE config_name = 'SOSL_SCHEMA';
SOSL

1 row selected.

SQL> 
SQL> CREATE OR REPLACE PACKAGE BODY sosl_if
  2  AS
  3    -- see package header for documentation, can be used as an template for own interface functions
  4    -- therefore all packages calls are fully qualified
  5    FUNCTION has_scripts
  6  	 RETURN NUMBER
  7    IS
  8  	 l_return	NUMBER;
  9  	 -- adjust the variables to your function
 10  	 l_log_category VARCHAR2(256) := 'SOSL_IF';
 11  	 l_caller	VARCHAR2(256) := 'sosl_if.has_scripts';
 12    BEGIN
 13  	 -- for your own interface function replace the following part with your routine to detect scripts waiting
 14  	 SELECT COUNT(*)
 15  	   INTO l_return
 16  	   FROM sosl_if_script
 17  		-- internal conditions about scripts ready to execute
 18  	  WHERE script_active = &SOSL_SCHEMA..sosl_constants.NUM_YES
 19  	    AND run_state     = &SOSL_SCHEMA..sosl_constants.RUN_STATE_WAITING
 20  		-- we need an assigned executor for the payload
 21  	    AND executor_id   IS NOT NULL
 22  	 ;
 23  	 -- end of individual section
 24  	 RETURN l_return;
 25    EXCEPTION
 26  	 WHEN OTHERS THEN
 27  	   -- log the error instead of RAISE, replace parameters with your function or package names and categories
 28  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
 29  	   RETURN -1;
 30    END has_scripts;
 31  
 32    FUNCTION get_next_script
 33  	 RETURN &SOSL_SCHEMA..SOSL_PAYLOAD
 34    IS
 35  	 l_payload	 &SOSL_SCHEMA..SOSL_PAYLOAD;
 36  	 l_executor_id	 NUMBER;
 37  	 l_ext_script_id VARCHAR2(4000);
 38  	 l_script_file	 VARCHAR2(4000);
 39  	 -- adjust the variables to your function
 40  	 l_log_category  VARCHAR2(256) := 'SOSL_IF';
 41  	 l_caller	 VARCHAR2(256) := 'sosl_if.get_next_script';
 42  	 CURSOR cur_script_data
 43  	 IS
 44  	   -- replace select with your own definition that delivers the executor id, the external script id as CHAR and the
 45  	   -- script file name including full or relative path
 46  	   SELECT executor_id
 47  		, TRIM(TO_CHAR(script_id)) AS ext_script_id
 48  		, script_name AS script_file
 49  	     FROM sosl_if_script
 50  		  -- internal conditions about scripts ready to execute
 51  	    WHERE script_active = &SOSL_SCHEMA..sosl_constants.NUM_YES
 52  	      AND run_state	= &SOSL_SCHEMA..sosl_constants.RUN_STATE_WAITING
 53  		  -- we need an assigned executor for the payload
 54  	      AND executor_id	IS NOT NULL
 55  		  -- adjust the order in which scripts get delivered
 56  	    ORDER BY run_order
 57  	 ;
 58    BEGIN
 59  	 l_payload := NULL;
 60  	 -- check if we have scripts, replace with your own has_scripts function
 61  	 IF sosl_if.has_scripts > 0
 62  	 THEN
 63  	   -- fetch only the first record, statement apart from order is identical to has_scripts statement
 64  	   OPEN cur_script_data;
 65  	   FETCH cur_script_data INTO l_executor_id, l_ext_script_id, l_script_file;
 66  	   CLOSE cur_script_data;
 67  	   -- you may want to add checks for the payload data before building the SOSL_PAYLOAD
 68  	   l_payload := &SOSL_SCHEMA..SOSL_PAYLOAD(l_executor_id, l_ext_script_id, l_script_file);
 69  	 ELSE
 70  	   -- log error information
 71  	   &SOSL_SCHEMA..sosl_log.minimal_error_log(l_caller, l_log_category, 'get_next_script called without having scripts to run');
 72  	   l_payload := NULL;
 73  	 END IF;
 74  	 RETURN l_payload;
 75    EXCEPTION
 76  	 WHEN OTHERS THEN
 77  	   -- log the error instead of RAISE
 78  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
 79  	   RETURN NULL;
 80    END get_next_script;
 81  
 82    FUNCTION set_script_status( p_run_id IN NUMBER
 83  				 , p_status IN NUMBER
 84  				 )
 85  	 RETURN NUMBER
 86    IS
 87  	 PRAGMA AUTONOMOUS_TRANSACTION;
 88  	 l_return	 NUMBER;
 89  	 l_script_id	 NUMBER;
 90  	 l_executor_id	 NUMBER;
 91  	 l_payload	 &SOSL_SCHEMA..SOSL_PAYLOAD;
 92  	 -- adjust the variables to your function
 93  	 l_log_category  VARCHAR2(256) := 'SOSL_IF';
 94  	 l_caller	 VARCHAR2(256) := 'sosl_if.set_script_status';
 95    BEGIN
 96  	 l_return := -1;
 97  	 -- get payload for own identifiers as send by get_next_script
 98  	 l_payload := &SOSL_SCHEMA..sosl_server.get_payload(p_run_id);
 99  	 IF l_payload IS NOT NULL
100  	 THEN
101  	   -- transform to internal type
102  	   l_script_id	 := TO_NUMBER(l_payload.ext_script_id);
103  	   l_executor_id := l_payload.executor_id;
104  	   -- update internal script table, replace with your routine to update internal status
105  	   UPDATE sosl_if_script
106  	      SET run_state = p_status
107  	    WHERE script_id    = l_script_id
108  	      AND executor_id  = l_executor_id
109  	   ;
110  	   COMMIT;
111  	   l_return := 0;
112  	 ELSE
113  	   -- log error information
114  	   &SOSL_SCHEMA..sosl_log.minimal_error_log(l_caller, l_log_category, 'Invalid SOSL_PAYLOAD for run_id: ' || p_run_id || ' and run state ' || p_status);
115  	   l_return := -1;
116  	 END IF;
117  	 RETURN l_return;
118    EXCEPTION
119  	 WHEN OTHERS THEN
120  	   -- log the error instead of RAISE
121  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
122  	   RETURN -1;
123    END set_script_status;
124  
125    FUNCTION send_mail( p_run_id IN NUMBER
126  			 , p_status IN NUMBER
127  			 )
128  	 RETURN NUMBER
129    IS
130  	 l_return	 NUMBER;
131  	 l_mail_subject  VARCHAR2(256);
132  	 l_mail_body	 VARCHAR2(32767);
133  	 l_sender	 VARCHAR2(128);
134  	 l_recipients	 VARCHAR2(1024);
135  	 l_payload	 &SOSL_SCHEMA..SOSL_PAYLOAD;
136  	 -- adjust the variables to your function
137  	 l_log_category  VARCHAR2(256) := 'SOSL_IF';
138  	 l_caller	 VARCHAR2(256) := 'sosl_if.send_mail';
139    BEGIN
140  	 l_return := -1;
141  	 -- define basic objects
142  	 l_mail_subject  := 'SOSL ' || &SOSL_SCHEMA..sosl_constants.run_state_text(p_status) || ' ';
143  	 l_sender	 := 'fake_sender@fake_domain.com';
144  	 l_recipients	 := 'fake_recipient_group@fake_domain.com; fake_recipient_special@fake_domain.com';
145  	 IF &SOSL_SCHEMA..sosl_server.has_run_id(p_run_id)
146  	 THEN
147  	   -- get payload for own identifiers as send by get_next_script
148  	   l_payload := &SOSL_SCHEMA..sosl_server.get_payload(p_run_id);
149  	   IF l_payload IS NOT NULL
150  	   THEN
151  	     -- prepare mail
152  	     l_mail_subject  := l_mail_subject || 'Script: ' || TRIM(l_payload.script_file);
153  	     -- format mail body RFC conform, use LF, CR is also valid, but NOT CRLF
154  	     l_mail_body     := 'Dear SOSL user' || &SOSL_SCHEMA..sosl_constants.LF || &SOSL_SCHEMA..sosl_constants.LF ||
155  				CASE
156  				  WHEN p_status = &SOSL_SCHEMA..sosl_constants.RUN_STATE_ERROR
157  				  THEN 'An ERROR happened during script execution.'
158  				  ELSE 'The state of the script execution has changed to ' || &SOSL_SCHEMA..sosl_constants.run_state_text(p_status)
159  				END || &SOSL_SCHEMA..sosl_constants.LF ||
160  				'Script: ' || l_payload.script_file || &SOSL_SCHEMA..sosl_constants.LF ||
161  				'Executor ID: ' || l_payload.executor_id || &SOSL_SCHEMA..sosl_constants.LF ||
162  				'Script ID: ' || l_payload.ext_script_id || &SOSL_SCHEMA..sosl_constants.LF ||
163  				'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || &SOSL_SCHEMA..sosl_constants.LF ||
164  				&SOSL_SCHEMA..sosl_constants.LF ||
165  				'Best regards' || &SOSL_SCHEMA..sosl_constants.LF ||
166  				'Your SOSL team'|| &SOSL_SCHEMA..sosl_constants.LF ||
167  				&SOSL_SCHEMA..sosl_constants.LF ||
168  				'Contact fake_admin@fake_domain.com for more information.'
169  	     ;
170  	   ELSE
171  	     -- we still have data for the mail
172  	     l_mail_subject := l_mail_subject || 'RUN_ID: ' || p_run_id;
173  	     l_mail_body     := 'Dear SOSL user' || &SOSL_SCHEMA..sosl_constants.LF || &SOSL_SCHEMA..sosl_constants.LF ||
174  				'An SEVERE ERROR happened during script execution.' || &SOSL_SCHEMA..sosl_constants.LF ||
175  				'Script cannot be identified or sosl_server.GET_PAYLOAD has failed.' || &SOSL_SCHEMA..sosl_constants.LF ||
176  				'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || &SOSL_SCHEMA..sosl_constants.LF ||
177  				'Intended state change to: ' || &SOSL_SCHEMA..sosl_constants.run_state_text(p_status) || &SOSL_SCHEMA..sosl_constants.LF ||
178  				&SOSL_SCHEMA..sosl_constants.LF ||
179  				'Best regards' || &SOSL_SCHEMA..sosl_constants.LF ||
180  				'Your SOSL team'|| &SOSL_SCHEMA..sosl_constants.LF ||
181  				&SOSL_SCHEMA..sosl_constants.LF ||
182  				'Contact fake_admin@fake_domain.com for more information.'
183  	     ;
184  	   END IF;
185  	   IF &SOSL_SCHEMA..sosl_server.dummy_mail(l_sender, l_recipients, l_mail_subject, l_mail_body)
186  	   THEN
187  	     l_return := 0;
188  	   ELSE
189  	     &SOSL_SCHEMA..sosl_log.minimal_error_log(l_caller, l_log_category, 'Could not send fake mail to log.');
190  	     l_return := -1;
191  	   END IF;
192  	 ELSE
193  	   &SOSL_SCHEMA..sosl_log.minimal_error_log('sosl_if.send_mail', 'SOSL_IF', 'RUN_ID ' || p_run_id || ' does not exist.');
194  	   l_mail_subject := l_mail_subject || 'Invalid RUN_ID: ' || p_run_id;
195  	   l_mail_body	   := 'Dear SOSL user' || &SOSL_SCHEMA..sosl_constants.LF || &SOSL_SCHEMA..sosl_constants.LF ||
196  			      'An SEVERE ERROR happened during script execution.' || &SOSL_SCHEMA..sosl_constants.LF ||
197  			      'Given RUN_ID does not exist in table SOSL_RUN_QUEUE.' || &SOSL_SCHEMA..sosl_constants.LF ||
198  			      'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || &SOSL_SCHEMA..sosl_constants.LF ||
199  			      'Intended state change to: ' || sosl_constants.run_state_text(p_status) || &SOSL_SCHEMA..sosl_constants.LF ||
200  			      &SOSL_SCHEMA..sosl_constants.LF ||
201  			      'Best regards' || &SOSL_SCHEMA..sosl_constants.LF ||
202  			      'Your SOSL team'|| &SOSL_SCHEMA..sosl_constants.LF ||
203  			      &SOSL_SCHEMA..sosl_constants.LF ||
204  			      'Contact fake_admin@fake_domain.com for more information.'
205  	   ;
206  	   IF &SOSL_SCHEMA..sosl_server.dummy_mail(l_sender, l_recipients, l_mail_subject, l_mail_body)
207  	   THEN
208  	     l_return := 0;
209  	   ELSE
210  	     &SOSL_SCHEMA..sosl_log.minimal_error_log(l_caller, l_log_category, 'Could not send fake mail to log.');
211  	     l_return := -1;
212  	   END IF;
213  	 END IF;
214  	 RETURN l_return;
215    EXCEPTION
216  	 WHEN OTHERS THEN
217  	   -- log the error instead of RAISE
218  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
219  	   RETURN -1;
220    END send_mail;
221  
222    FUNCTION add_script( p_script_name    IN VARCHAR2
223  			  , p_executor_id    IN NUMBER
224  			  , p_run_order      IN NUMBER	 DEFAULT 1
225  			  , p_script_active  IN NUMBER	 DEFAULT 0
226  			  )
227  	 RETURN NUMBER
228    IS
229  	 PRAGMA AUTONOMOUS_TRANSACTION;
230  	 l_return	 NUMBER;
231  	 -- adjust the variables to your function
232  	 l_log_category  VARCHAR2(256) := 'SOSL_IF';
233  	 l_caller	 VARCHAR2(256) := 'sosl_if.add_script';
234    BEGIN
235  	 -- no checks just insert
236  	 INSERT INTO sosl_if_script
237  	   ( script_name
238  	   , executor_id
239  	   , run_order
240  	   , script_active
241  	   )
242  	   VALUES ( p_script_name
243  		  , p_executor_id
244  		  , p_run_order
245  		  , p_script_active
246  		  )
247  	   RETURNING script_id INTO l_return
248  	 ;
249  	 COMMIT;
250  	 RETURN l_return;
251    EXCEPTION
252  	 WHEN OTHERS THEN
253  	   -- log the error instead of RAISE
254  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
255  	   RETURN -1;
256    END add_script;
257  
258    FUNCTION set_run_state( p_script_id IN NUMBER
259  			     , p_run_state IN NUMBER DEFAULT 0
260  			     )
261  	 RETURN NUMBER
262    IS
263  	 PRAGMA AUTONOMOUS_TRANSACTION;
264  	 -- adjust the variables to your function
265  	 l_log_category  VARCHAR2(256) := 'SOSL_IF';
266  	 l_caller	 VARCHAR2(256) := 'sosl_if.set_run_state';
267    BEGIN
268  	 UPDATE sosl_if_script
269  	    SET run_state = p_run_state
270  	  WHERE script_id = p_script_id
271  	 ;
272  	 COMMIT;
273  	 RETURN 0;
274    EXCEPTION
275  	 WHEN OTHERS THEN
276  	   -- log the error instead of RAISE
277  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
278  	   RETURN -1;
279    END set_run_state;
280  
281    FUNCTION set_active_state( p_script_id	   IN NUMBER
282  				, p_script_active  IN NUMBER DEFAULT 0
283  				)
284  	 RETURN NUMBER
285    IS
286  	 PRAGMA AUTONOMOUS_TRANSACTION;
287  	 -- adjust the variables to your function
288  	 l_log_category  VARCHAR2(256) := 'SOSL_IF';
289  	 l_caller	 VARCHAR2(256) := 'sosl_if.set_active_state';
290    BEGIN
291  	 UPDATE sosl_if_script
292  	    SET script_active = p_script_active
293  	  WHERE script_id = p_script_id
294  	 ;
295  	 COMMIT;
296  	 RETURN 0;
297    EXCEPTION
298  	 WHEN OTHERS THEN
299  	   -- log the error instead of RAISE
300  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
301  	   RETURN -1;
302    END set_active_state;
303  
304    FUNCTION reset_scripts
305  	 RETURN NUMBER
306    IS
307  	 PRAGMA AUTONOMOUS_TRANSACTION;
308  	 l_result	 NUMBER;
309  	 -- adjust the variables to your function
310  	 l_log_category  VARCHAR2(256) := 'SOSL_IF';
311  	 l_caller	 VARCHAR2(256) := 'sosl_if.reset_scripts';
312  	 CURSOR cur_scripts
313  	 IS
314  	   SELECT script_id
315  	     FROM sosl_if_script
316  	    WHERE run_state != &SOSL_SCHEMA..sosl_constants.RUN_STATE_WAITING
317  	 ;
318    BEGIN
319  	 &SOSL_SCHEMA..sosl_log.minimal_info_log(l_caller, l_log_category, 'Reset all scripts in SOSL_IF_SCRIPT to run_state WAITING');
320  	 FOR rec IN cur_scripts
321  	 LOOP
322  	   -- errors should be already logged
323  	   l_result := sosl_if.set_run_state(rec.script_id, &SOSL_SCHEMA..sosl_constants.RUN_STATE_WAITING);
324  	 END LOOP;
325  	 RETURN 0;
326    EXCEPTION
327  	 WHEN OTHERS THEN
328  	   -- log the error instead of RAISE
329  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
330  	   RETURN -1;
331    END reset_scripts;
332  
333    FUNCTION activate_scripts
334  	 RETURN NUMBER
335    IS
336  	 PRAGMA AUTONOMOUS_TRANSACTION;
337  	 l_result	 NUMBER;
338  	 -- adjust the variables to your function
339  	 l_log_category  VARCHAR2(256) := 'SOSL_IF';
340  	 l_caller	 VARCHAR2(256) := 'sosl_if.activate_scripts';
341  	 CURSOR cur_scripts
342  	 IS
343  	   SELECT script_id
344  	     FROM sosl_if_script
345  	    WHERE script_active != &SOSL_SCHEMA..sosl_constants.NUM_YES
346  	 ;
347    BEGIN
348  	 &SOSL_SCHEMA..sosl_log.minimal_info_log(l_caller, l_log_category, 'Activate all scripts in SOSL_IF_SCRIPT to enable them for execution');
349  	 FOR rec IN cur_scripts
350  	 LOOP
351  	   -- errors should be already logged
352  	   l_result := sosl_if.set_active_state(rec.script_id, &SOSL_SCHEMA..sosl_constants.NUM_YES);
353  	 END LOOP;
354  	 RETURN 0;
355    EXCEPTION
356  	 WHEN OTHERS THEN
357  	   -- log the error instead of RAISE
358  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
359  	   RETURN -1;
360    END activate_scripts;
361  
362    FUNCTION deactivate_scripts
363  	 RETURN NUMBER
364    IS
365  	 PRAGMA AUTONOMOUS_TRANSACTION;
366  	 l_result	 NUMBER;
367  	 -- adjust the variables to your function
368  	 l_log_category  VARCHAR2(256) := 'SOSL_IF';
369  	 l_caller	 VARCHAR2(256) := 'sosl_if.deactivate_scripts';
370  	 CURSOR cur_scripts
371  	 IS
372  	   SELECT script_id
373  	     FROM sosl_if_script
374  	    WHERE script_active != &SOSL_SCHEMA..sosl_constants.NUM_NO
375  	 ;
376    BEGIN
377  	 &SOSL_SCHEMA..sosl_log.minimal_info_log(l_caller, l_log_category, 'Deactivate all scripts in SOSL_IF_SCRIPT to disable them for execution');
378  	 FOR rec IN cur_scripts
379  	 LOOP
380  	   -- errors should be already logged
381  	   l_result := sosl_if.set_active_state(rec.script_id, &SOSL_SCHEMA..sosl_constants.NUM_NO);
382  	 END LOOP;
383  	 RETURN 0;
384    EXCEPTION
385  	 WHEN OTHERS THEN
386  	   -- log the error instead of RAISE
387  	   &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
388  	   RETURN -1;
389    END deactivate_scripts;
390  
391  END;
392  /
old  18:      WHERE script_active = &SOSL_SCHEMA..sosl_constants.NUM_YES
new  18:      WHERE script_active = SOSL.sosl_constants.NUM_YES
old  19:        AND run_state     = &SOSL_SCHEMA..sosl_constants.RUN_STATE_WAITING
new  19:        AND run_state     = SOSL.sosl_constants.RUN_STATE_WAITING
old  28:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new  28:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
old  33:     RETURN &SOSL_SCHEMA..SOSL_PAYLOAD
new  33:     RETURN SOSL.SOSL_PAYLOAD
old  35:     l_payload       &SOSL_SCHEMA..SOSL_PAYLOAD;
new  35:     l_payload       SOSL.SOSL_PAYLOAD;
old  51:        WHERE script_active = &SOSL_SCHEMA..sosl_constants.NUM_YES
new  51:        WHERE script_active = SOSL.sosl_constants.NUM_YES
old  52:          AND run_state     = &SOSL_SCHEMA..sosl_constants.RUN_STATE_WAITING
new  52:          AND run_state     = SOSL.sosl_constants.RUN_STATE_WAITING
old  68:       l_payload := &SOSL_SCHEMA..SOSL_PAYLOAD(l_executor_id, l_ext_script_id, l_script_file);
new  68:       l_payload := SOSL.SOSL_PAYLOAD(l_executor_id, l_ext_script_id, l_script_file);
old  71:       &SOSL_SCHEMA..sosl_log.minimal_error_log(l_caller, l_log_category, 'get_next_script called without having scripts to run');
new  71:       SOSL.sosl_log.minimal_error_log(l_caller, l_log_category, 'get_next_script called without having scripts to run');
old  78:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new  78:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
old  91:     l_payload       &SOSL_SCHEMA..SOSL_PAYLOAD;
new  91:     l_payload       SOSL.SOSL_PAYLOAD;
old  98:     l_payload := &SOSL_SCHEMA..sosl_server.get_payload(p_run_id);
new  98:     l_payload := SOSL.sosl_server.get_payload(p_run_id);
old 114:       &SOSL_SCHEMA..sosl_log.minimal_error_log(l_caller, l_log_category, 'Invalid SOSL_PAYLOAD for run_id: ' || p_run_id || ' and run state ' || p_status);
new 114:       SOSL.sosl_log.minimal_error_log(l_caller, l_log_category, 'Invalid SOSL_PAYLOAD for run_id: ' || p_run_id || ' and run state ' || p_status);
old 121:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new 121:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
old 135:     l_payload       &SOSL_SCHEMA..SOSL_PAYLOAD;
new 135:     l_payload       SOSL.SOSL_PAYLOAD;
old 142:     l_mail_subject  := 'SOSL ' || &SOSL_SCHEMA..sosl_constants.run_state_text(p_status) || ' ';
new 142:     l_mail_subject  := 'SOSL ' || SOSL.sosl_constants.run_state_text(p_status) || ' ';
old 145:     IF &SOSL_SCHEMA..sosl_server.has_run_id(p_run_id)
new 145:     IF SOSL.sosl_server.has_run_id(p_run_id)
old 148:       l_payload := &SOSL_SCHEMA..sosl_server.get_payload(p_run_id);
new 148:       l_payload := SOSL.sosl_server.get_payload(p_run_id);
old 154:         l_mail_body     := 'Dear SOSL user' || &SOSL_SCHEMA..sosl_constants.LF || &SOSL_SCHEMA..sosl_constants.LF ||
new 154:         l_mail_body     := 'Dear SOSL user' || SOSL.sosl_constants.LF || SOSL.sosl_constants.LF ||
old 156:                              WHEN p_status = &SOSL_SCHEMA..sosl_constants.RUN_STATE_ERROR
new 156:                              WHEN p_status = SOSL.sosl_constants.RUN_STATE_ERROR
old 158:                              ELSE 'The state of the script execution has changed to ' || &SOSL_SCHEMA..sosl_constants.run_state_text(p_status)
new 158:                              ELSE 'The state of the script execution has changed to ' || SOSL.sosl_constants.run_state_text(p_status)
old 159:                            END || &SOSL_SCHEMA..sosl_constants.LF ||
new 159:                            END || SOSL.sosl_constants.LF ||
old 160:                            'Script: ' || l_payload.script_file || &SOSL_SCHEMA..sosl_constants.LF ||
new 160:                            'Script: ' || l_payload.script_file || SOSL.sosl_constants.LF ||
old 161:                            'Executor ID: ' || l_payload.executor_id || &SOSL_SCHEMA..sosl_constants.LF ||
new 161:                            'Executor ID: ' || l_payload.executor_id || SOSL.sosl_constants.LF ||
old 162:                            'Script ID: ' || l_payload.ext_script_id || &SOSL_SCHEMA..sosl_constants.LF ||
new 162:                            'Script ID: ' || l_payload.ext_script_id || SOSL.sosl_constants.LF ||
old 163:                            'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || &SOSL_SCHEMA..sosl_constants.LF ||
new 163:                            'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || SOSL.sosl_constants.LF ||
old 164:                            &SOSL_SCHEMA..sosl_constants.LF ||
new 164:                            SOSL.sosl_constants.LF ||
old 165:                            'Best regards' || &SOSL_SCHEMA..sosl_constants.LF ||
new 165:                            'Best regards' || SOSL.sosl_constants.LF ||
old 166:                            'Your SOSL team'|| &SOSL_SCHEMA..sosl_constants.LF ||
new 166:                            'Your SOSL team'|| SOSL.sosl_constants.LF ||
old 167:                            &SOSL_SCHEMA..sosl_constants.LF ||
new 167:                            SOSL.sosl_constants.LF ||
old 173:         l_mail_body     := 'Dear SOSL user' || &SOSL_SCHEMA..sosl_constants.LF || &SOSL_SCHEMA..sosl_constants.LF ||
new 173:         l_mail_body     := 'Dear SOSL user' || SOSL.sosl_constants.LF || SOSL.sosl_constants.LF ||
old 174:                            'An SEVERE ERROR happened during script execution.' || &SOSL_SCHEMA..sosl_constants.LF ||
new 174:                            'An SEVERE ERROR happened during script execution.' || SOSL.sosl_constants.LF ||
old 175:                            'Script cannot be identified or sosl_server.GET_PAYLOAD has failed.' || &SOSL_SCHEMA..sosl_constants.LF ||
new 175:                            'Script cannot be identified or sosl_server.GET_PAYLOAD has failed.' || SOSL.sosl_constants.LF ||
old 176:                            'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || &SOSL_SCHEMA..sosl_constants.LF ||
new 176:                            'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || SOSL.sosl_constants.LF ||
old 177:                            'Intended state change to: ' || &SOSL_SCHEMA..sosl_constants.run_state_text(p_status) || &SOSL_SCHEMA..sosl_constants.LF ||
new 177:                            'Intended state change to: ' || SOSL.sosl_constants.run_state_text(p_status) || SOSL.sosl_constants.LF ||
old 178:                            &SOSL_SCHEMA..sosl_constants.LF ||
new 178:                            SOSL.sosl_constants.LF ||
old 179:                            'Best regards' || &SOSL_SCHEMA..sosl_constants.LF ||
new 179:                            'Best regards' || SOSL.sosl_constants.LF ||
old 180:                            'Your SOSL team'|| &SOSL_SCHEMA..sosl_constants.LF ||
new 180:                            'Your SOSL team'|| SOSL.sosl_constants.LF ||
old 181:                            &SOSL_SCHEMA..sosl_constants.LF ||
new 181:                            SOSL.sosl_constants.LF ||
old 185:       IF &SOSL_SCHEMA..sosl_server.dummy_mail(l_sender, l_recipients, l_mail_subject, l_mail_body)
new 185:       IF SOSL.sosl_server.dummy_mail(l_sender, l_recipients, l_mail_subject, l_mail_body)
old 189:         &SOSL_SCHEMA..sosl_log.minimal_error_log(l_caller, l_log_category, 'Could not send fake mail to log.');
new 189:         SOSL.sosl_log.minimal_error_log(l_caller, l_log_category, 'Could not send fake mail to log.');
old 193:       &SOSL_SCHEMA..sosl_log.minimal_error_log('sosl_if.send_mail', 'SOSL_IF', 'RUN_ID ' || p_run_id || ' does not exist.');
new 193:       SOSL.sosl_log.minimal_error_log('sosl_if.send_mail', 'SOSL_IF', 'RUN_ID ' || p_run_id || ' does not exist.');
old 195:       l_mail_body     := 'Dear SOSL user' || &SOSL_SCHEMA..sosl_constants.LF || &SOSL_SCHEMA..sosl_constants.LF ||
new 195:       l_mail_body     := 'Dear SOSL user' || SOSL.sosl_constants.LF || SOSL.sosl_constants.LF ||
old 196:                          'An SEVERE ERROR happened during script execution.' || &SOSL_SCHEMA..sosl_constants.LF ||
new 196:                          'An SEVERE ERROR happened during script execution.' || SOSL.sosl_constants.LF ||
old 197:                          'Given RUN_ID does not exist in table SOSL_RUN_QUEUE.' || &SOSL_SCHEMA..sosl_constants.LF ||
new 197:                          'Given RUN_ID does not exist in table SOSL_RUN_QUEUE.' || SOSL.sosl_constants.LF ||
old 198:                          'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || &SOSL_SCHEMA..sosl_constants.LF ||
new 198:                          'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || SOSL.sosl_constants.LF ||
old 199:                          'Intended state change to: ' || sosl_constants.run_state_text(p_status) || &SOSL_SCHEMA..sosl_constants.LF ||
new 199:                          'Intended state change to: ' || sosl_constants.run_state_text(p_status) || SOSL.sosl_constants.LF ||
old 200:                          &SOSL_SCHEMA..sosl_constants.LF ||
new 200:                          SOSL.sosl_constants.LF ||
old 201:                          'Best regards' || &SOSL_SCHEMA..sosl_constants.LF ||
new 201:                          'Best regards' || SOSL.sosl_constants.LF ||
old 202:                          'Your SOSL team'|| &SOSL_SCHEMA..sosl_constants.LF ||
new 202:                          'Your SOSL team'|| SOSL.sosl_constants.LF ||
old 203:                          &SOSL_SCHEMA..sosl_constants.LF ||
new 203:                          SOSL.sosl_constants.LF ||
old 206:       IF &SOSL_SCHEMA..sosl_server.dummy_mail(l_sender, l_recipients, l_mail_subject, l_mail_body)
new 206:       IF SOSL.sosl_server.dummy_mail(l_sender, l_recipients, l_mail_subject, l_mail_body)
old 210:         &SOSL_SCHEMA..sosl_log.minimal_error_log(l_caller, l_log_category, 'Could not send fake mail to log.');
new 210:         SOSL.sosl_log.minimal_error_log(l_caller, l_log_category, 'Could not send fake mail to log.');
old 218:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new 218:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
old 254:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new 254:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
old 277:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new 277:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
old 300:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new 300:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
old 316:        WHERE run_state != &SOSL_SCHEMA..sosl_constants.RUN_STATE_WAITING
new 316:        WHERE run_state != SOSL.sosl_constants.RUN_STATE_WAITING
old 319:     &SOSL_SCHEMA..sosl_log.minimal_info_log(l_caller, l_log_category, 'Reset all scripts in SOSL_IF_SCRIPT to run_state WAITING');
new 319:     SOSL.sosl_log.minimal_info_log(l_caller, l_log_category, 'Reset all scripts in SOSL_IF_SCRIPT to run_state WAITING');
old 323:       l_result := sosl_if.set_run_state(rec.script_id, &SOSL_SCHEMA..sosl_constants.RUN_STATE_WAITING);
new 323:       l_result := sosl_if.set_run_state(rec.script_id, SOSL.sosl_constants.RUN_STATE_WAITING);
old 329:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new 329:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
old 345:        WHERE script_active != &SOSL_SCHEMA..sosl_constants.NUM_YES
new 345:        WHERE script_active != SOSL.sosl_constants.NUM_YES
old 348:     &SOSL_SCHEMA..sosl_log.minimal_info_log(l_caller, l_log_category, 'Activate all scripts in SOSL_IF_SCRIPT to enable them for execution');
new 348:     SOSL.sosl_log.minimal_info_log(l_caller, l_log_category, 'Activate all scripts in SOSL_IF_SCRIPT to enable them for execution');
old 352:       l_result := sosl_if.set_active_state(rec.script_id, &SOSL_SCHEMA..sosl_constants.NUM_YES);
new 352:       l_result := sosl_if.set_active_state(rec.script_id, SOSL.sosl_constants.NUM_YES);
old 358:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new 358:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
old 374:        WHERE script_active != &SOSL_SCHEMA..sosl_constants.NUM_NO
new 374:        WHERE script_active != SOSL.sosl_constants.NUM_NO
old 377:     &SOSL_SCHEMA..sosl_log.minimal_info_log(l_caller, l_log_category, 'Deactivate all scripts in SOSL_IF_SCRIPT to disable them for execution');
new 377:     SOSL.sosl_log.minimal_info_log(l_caller, l_log_category, 'Deactivate all scripts in SOSL_IF_SCRIPT to disable them for execution');
old 381:       l_result := sosl_if.set_active_state(rec.script_id, &SOSL_SCHEMA..sosl_constants.NUM_NO);
new 381:       l_result := sosl_if.set_active_state(rec.script_id, SOSL.sosl_constants.NUM_NO);
old 387:       &SOSL_SCHEMA..sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
new 387:       SOSL.sosl_log.exception_log(l_caller, l_log_category, SQLERRM);

Package body created.

SQL> -- api package
SQL> @@../sosl_ddl/packages/sosl_api.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic package providing the API to the Simple Oracle Script Loader.
SQL> CREATE OR REPLACE PACKAGE sosl_api
  2  AS
  3    /**
  4    * This package contains SOSL API functions and procedures to be used by users with the role SOSL_USER or higher.
  5    * Some functions are limited to roles, higher than SOSL_USER. Config login information are not visible to SOSL_USER
  6    * role. Mainly used to manage executors and retrieve basic information.
  7    * This package is made for users to interactively manage executors and get or set parameter. The return value is
  8    * therefore usually a string that can be interpreted by a human being, not by programs or a number, mainly for IDs.
  9    * The functions can be used with select statements as well as in PLSQL blocks or code. Inserts and updates will run
 10    * as autonomous transactions.
 11    */
 12  
 13    /** Function SOSL_API.GET_CONFIG
 14    * Gets an existing configuration value for a given and existing case sensitive configuration name.
 15    * In case of errors details can be found in SOSL_SERVER_LOG_V. See SOSL_CONFIG_V for available configuration
 16    * values.
 17    *
 18    * @return The configured value as VARCHAR2 or an error text message.
 19    */
 20    FUNCTION get_config(p_config_name IN VARCHAR2)
 21  	 RETURN VARCHAR2
 22    ;
 23  
 24    /** Function SOSL_API.SET_RUNMODE
 25    * REQUIRES role SOSL_EXECUTOR or higher.
 26    * Sets the runmode for the SOSL server. Allowed values are RUN (default if no parameter given), PAUSE or STOP.
 27    * Depending on the current wait time and defined timeframe at server start, the server will read this state the
 28    * next time it is connecting to the database. If the server is inactive, the runmode will be used on server start.
 29    * In case of errors details can be found in SOSL_SERVER_LOG_V.
 30    *
 31    * This will not stop the server immediately as it depends on the server reading the entry. If in wait mode, depending
 32    * on the wait time, the server will stop after waiting. If the server is running outside of the given time frame that
 33    * was set on server start, the server will stop after entering the time frame known to the server at server start.
 34    * If you want to stop the server immediately you may do this on the local server.
 35    *
 36    * You may stop the server by database, but YOU CAN'T START THE SERVER BY DATABASE. This has to be done locally on
 37    * the SOSL server machine.
 38    *
 39    * @param p_runmode The desired run mode. Possible values are RUN, STOP, PAUSE. Default is RUN.
 40    *
 41    * @return A success or error text message.
 42    */
 43    FUNCTION set_runmode(p_runmode IN VARCHAR2 DEFAULT 'RUN')
 44  	 RETURN VARCHAR2
 45    ;
 46  
 47    /** Function SOSL_API.SET_TIMEFRAME
 48    * REQUIRES role SOSL_EXECUTOR or higher.
 49    * Set the timeframe where the server is allowed to connect to the database. If the server detects that it is
 50    * running out of the given timeframe it will not connect to the database and using the wait time defined for
 51    * SOSL_PAUSE_WAIT. Take care on setting this times that pause wait time is not too long and leads to overlaps
 52    * with the timeframe set. The larger SOSL_PAUSE_WAIT is, the bigger can be an overlap where the server is still
 53    * waiting, even if the timeframe for running has already started.
 54    *
 55    * If the pause wait time is one hour, than it is recommended that timeframe set is also fitting with the pause
 56    * wait time, e.g. 08:00 - 18:00, 07:30 - 19:30. To avoid overlaps you should set the from time to a value a few
 57    * minutes below the hourly waits, e.g. desired server at 08:00 is up, set 07:55 - 18:00, to ensure that the server
 58    * is up and running at 08:00.
 59    *
 60    * The server can handle daybreaks, so you might also set the timeframe to 21:55 - 06:00.
 61    *
 62    * If from or to is set to '-1', the timeframe will be disabled and ignored.
 63    *
 64    * ATTENTION! The time is related to the local server time of the SOSL server, not to the time of the database
 65    * server in case they differ.
 66    *
 67    * @param p_from The start time for the SOSL server in 24h format with leading zeros and : as delimiter or string '-1'.
 68    * @param p_to The end time for the SOSL server in 24h format with leading zeros and : as delimiter or string '-1'.
 69    *
 70    * @return A success or error text message.
 71    */
 72    FUNCTION set_timeframe( p_from IN VARCHAR2 DEFAULT '07:55'
 73  			     , p_to   IN VARCHAR2 DEFAULT '18:00'
 74  			     )
 75  	 RETURN VARCHAR2
 76    ;
 77  
 78    /* FUNCTION SOSL_API.HAS_SCRIPTS
 79    * Wrapper function for SOSL_SYS.HAS_SCRIPTS. Provided for reports to be run with SOSL_USER role.
 80    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
 81    * return a number greater or equal to 0 as well as messages waiting in SOSL_RUN_QUEUE to be processed. Errors will get logged.
 82    *
 83    * @return The total amount of scripts waiting for processing or -1 on unhandled exceptions/all functions have errors.
 84    */
 85    FUNCTION has_scripts
 86  	 RETURN NUMBER
 87    ;
 88  
 89    /** Function SOSL_API.CREATE_EXECUTOR
 90    * REQUIRES role SOSL_EXECUTOR or higher.
 91    * Creates a new executor definition if it did not exist already. DB_USER is set automatically using the SESSION_USER from
 92    * SYS_CONTEXT. The executor is neither activated nor marked as reviewed. To use the executor you must activate it and the
 93    * reviewed state must have been set.
 94    * The given interface functions must conform to the following declarations, must exist and be granted to SOSL_EXECUTOR role:
 95    *
 96    * fn_has_scripts: FUNCTION your_has_script RETURN NUMBER;
 97    * @return A positive integer including 0 for amount of scripts waiting or -1 on errors.
 98    * @task: Return the amount of waiting scripts.
 99    *
100    * fn_get_next_script: FUNCTION your_get_next_script RETURN SOSL.SOSL_PAYLOAD;
101    * @return A valid and filled SOSL_PAYLOAD object containing EXECUTOR_ID, EXT_SCRIPT_ID and SCRIPT_FILE or NULL on errors.
102    * @task: Return the details of the next waiting script.
103    *
104    * fn_set_script_status: FUNCTION your_set_script_status(p_run_id IN NUMBER, p_status IN NUMBER) RETURN NUMBER;
105    * @return Execution indicator: 0 on success or -1 on errors.
106    * @task: Set the internal status of your scripts queued for execution.
107    *
108    * fn_send_db_mail: FUNCTION your_send_mail(p_run_id IN NUMBER, p_status IN NUMBER) RETURN NUMBER;
109    * @return Execution indicator: 0 on success or -1 on errors.
110    * @task: Prepare and send a mail based on script status.
111    *
112    * For examples see package SOSL_IF.
113    *
114    * @param p_executor_name The unique executor definition name.
115    * @param p_function_owner The existing and for SOSL visible database user that owns the interface functions.
116    * @param p_fn_has_scripts The fully qualified interface function for has_scripts. Must exist and be granted to SOSL_EXECUTOR.
117    * @param p_fn_get_next_script The fully qualified interface function for get_next_script. Must exist and be granted to SOSL_EXECUTOR.
118    * @param p_fn_set_script_status The fully qualified interface function for set_script_status. Must exist and be granted to SOSL_EXECUTOR.
119    * @param p_cfg_file The filename including relative or absolute path that contains the login for the executor.
120    * @param p_use_mail Defines if mail should be used (1) or not (0). Default is no mail usage.
121    * @param p_fn_send_db_mail The fully qualified interface function for send mail. If mail should be used the parameter is mandatory, must exist and be granted to SOSL_EXECUTOR.
122    * @param p_executor_description An optional description for the new executor.
123    *
124    * @return The new executor id for the created executor or -1 on errors. Check SOSL_SERVER_LOG for details on errors.
125    */
126    FUNCTION create_executor( p_executor_name	 IN VARCHAR2
127  			       , p_function_owner	 IN VARCHAR2
128  			       , p_fn_has_scripts	 IN VARCHAR2
129  			       , p_fn_get_next_script	 IN VARCHAR2
130  			       , p_fn_set_script_status  IN VARCHAR2
131  			       , p_cfg_file		 IN VARCHAR2
132  			       , p_use_mail		 IN NUMBER     DEFAULT 0
133  			       , p_fn_send_db_mail	 IN VARCHAR2   DEFAULT NULL
134  			       , p_executor_description  IN VARCHAR2   DEFAULT NULL
135  			       )
136  	 RETURN NUMBER
137    ;
138  
139    /** Function SOSL_API.ACTIVATE_EXECUTOR
140    * REQUIRES role SOSL_EXECUTOR or higher.
141    * Sets the executor, identified by the given id, to active.
142    *
143    * @param p_executor_id The executor id to activate.
144    *
145    * @return A success or error text message.
146    */
147    FUNCTION activate_executor(p_executor_id IN NUMBER)
148  	 RETURN VARCHAR2
149    ;
150  
151    /** Function SOSL_API.DEACTIVATE_EXECUTOR
152    * REQUIRES role SOSL_EXECUTOR or higher.
153    * Sets the executor, identified by the given id, to deactivated.
154    *
155    * @param p_executor_id The executor id to activate.
156    *
157    * @return A success or error text message.
158    */
159    FUNCTION deactivate_executor(p_executor_id IN NUMBER)
160  	 RETURN VARCHAR2
161    ;
162  
163    /** Function SOSL_API.SET_EXECUTOR_REVIEWED
164    * REQUIRES role SOSL_REVIEWER or higher.
165    * Sets the executor, identified by the given id, to reviewed.
166    *
167    * @param p_executor_id The executor id to set to reviewed.
168    *
169    * @return A success or error text message.
170    */
171    FUNCTION set_executor_reviewed(p_executor_id IN NUMBER)
172  	 RETURN VARCHAR2
173    ;
174  
175    /** Function SOSL_API.REVOKE_EXECUTOR_REVIEWED
176    * REQUIRES role SOSL_REVIEWER or higher.
177    * Sets the executor, identified by the given id, to not reviewed.
178    *
179    * @param p_executor_id The executor id to set to not reviewed.
180    *
181    * @return A success or error text message.
182    */
183    FUNCTION revoke_executor_reviewed(p_executor_id IN NUMBER)
184  	 RETURN VARCHAR2
185    ;
186  
187    /* FUNCTION SOSL_API.ADD_SCRIPT
188    * Adds a new script to SOSL_IF_SCRIPT. Wrapper for SOSL_IF.ADD_SCRIPT.
189    *
190    * @param p_script_name The script filename including relative or full path. Must exist on the server SOSL is running.
191    * @param p_executor_id The executor id associated with the script. NULL allowed. Scripts without executor are never executed by SOSL.
192    * @param p_run_order The order in which the script should be executed. Equal order numbers mean random execution of ths script.
193    * @param p_script_active Sets the script to active (1) or inactive (0). Only active scripts are executed.
194    *
195    * @return Return the new script id or -1 on errors.
196    */
197    FUNCTION add_script( p_script_name    IN VARCHAR2
198  			  , p_executor_id    IN NUMBER
199  			  , p_run_order      IN NUMBER	 DEFAULT 1
200  			  , p_script_active  IN NUMBER	 DEFAULT 0
201  			  )
202  	 RETURN NUMBER
203    ;
204  
205    /** Function SOSL_API.DB_IN_TIME
206    * Wrapper for SOSL_UTIL.DB_IN_TIME.
207    * Checks if the database is within the defined start and stop time of the SOSL server. If the database time is
208    * not in sync with the local server time of the SOSL server, the result may be wrong. Sync the time of the database
209    * and the local server to get reliable results.
210    *
211    * @return TRUE if the current database time is within the server timeframe otherwise FALSE.
212    */
213    FUNCTION db_in_time
214  	 RETURN BOOLEAN
215    ;
216  
217  END;
218  /

Package created.

SQL> GRANT EXECUTE ON sosl_api TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/packages/sosl_api.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_api
  2  AS
  3    -- for description see header file
  4    FUNCTION get_config(p_config_name IN VARCHAR2)
  5  	 RETURN VARCHAR2
  6    IS
  7  	 l_return	 VARCHAR2(4000);
  8  	 l_user 	 VARCHAR2(128);
  9  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
 10  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.get_config';
 11    BEGIN
 12  	 l_user   := SYS_CONTEXT('USERENV', 'SESSION_USER');
 13  	 l_return := sosl_server.get_config(p_config_name);
 14  	 IF NOT sosl_util.has_role(l_user, 'SOSL_REVIEWER')
 15  	 THEN
 16  	   IF p_config_name = 'SOSL_PATH_CFG'
 17  	   THEN
 18  	     sosl_log.minimal_warning_log(l_caller, l_log_category, 'User ' || l_user || ' requested SOSL_PATH_CFG without sufficient role rights.');
 19  	     l_return := '*** at least SOSL_REVIEWER role needed to see this value';
 20  	   END IF;
 21  	 END IF;
 22  	 IF l_return = '-1'
 23  	 THEN
 24  	   l_return := 'ERROR executing SOSL_SERVER.GET_CONFIG see SOSL_SERVER_LOG for details';
 25  	 END IF;
 26  	 RETURN l_return;
 27    EXCEPTION
 28  	 WHEN OTHERS THEN
 29  	   -- log the error instead of RAISE
 30  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
 31  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 32  	   RETURN 'ERROR executing SOSL_API.GET_CONFIG see SOSL_SERVER_LOG for details';
 33    END get_config;
 34  
 35    FUNCTION set_runmode(p_runmode IN VARCHAR2 DEFAULT 'RUN')
 36  	 RETURN VARCHAR2
 37    IS
 38  	 l_return	 VARCHAR2(4000);
 39  	 l_result	 NUMBER;
 40  	 l_user 	 VARCHAR2(128);
 41  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
 42  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.set_runmode';
 43    BEGIN
 44  	 l_user   := SYS_CONTEXT('USERENV', 'SESSION_USER');
 45  	 IF sosl_util.has_role(l_user, 'SOSL_EXECUTOR')
 46  	 THEN
 47  	   l_result := sosl_server.set_runmode(p_runmode);
 48  	   IF l_result = -1
 49  	   THEN
 50  	     l_return := 'ERROR executing SOSL_SERVER.SET_RUNMODE with ' || p_runmode || ' see SOSL_SERVER_LOG for details';
 51  	   ELSE
 52  	     l_return := 'SUCCESS set runmode to ' || p_runmode;
 53  	   END IF;
 54  	 ELSE
 55  	   sosl_log.minimal_warning_log(l_caller, l_log_category, 'User ' || l_user || ' wanted to set runmode to ' || p_runmode || ' without sufficient role rights.');
 56  	   l_return := 'ERROR insufficient privileges. Needs at least role SOSL_EXECUTOR.';
 57  	 END IF;
 58  	 RETURN l_return;
 59    EXCEPTION
 60  	 WHEN OTHERS THEN
 61  	   -- log the error instead of RAISE
 62  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
 63  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 64  	   RETURN 'ERROR executing SOSL_API.SET_RUNMODE see SOSL_SERVER_LOG for details';
 65    END set_runmode;
 66  
 67    FUNCTION set_timeframe( p_from IN VARCHAR2 DEFAULT '07:55'
 68  			     , p_to   IN VARCHAR2 DEFAULT '18:00'
 69  			     )
 70  	 RETURN VARCHAR2
 71    IS
 72  	 l_return	 VARCHAR2(4000);
 73  	 l_user 	 VARCHAR2(128);
 74  	 l_from_result	 NUMBER;
 75  	 l_to_result	 NUMBER;
 76  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
 77  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.set_timeframe';
 78    BEGIN
 79  	 l_user   := SYS_CONTEXT('USERENV', 'SESSION_USER');
 80  	 IF sosl_util.has_role(l_user, 'SOSL_EXECUTOR')
 81  	 THEN
 82  	   l_from_result := sosl_server.set_config('SOSL_START_JOBS', p_from);
 83  	   l_to_result	 := sosl_server.set_config('SOSL_STOP_JOBS', p_to);
 84  	   IF	 l_from_result = -1
 85  	      OR l_to_result   = -1
 86  	   THEN
 87  	     -- logging should be done by called function
 88  	     l_return := 'ERROR executing sosl_server.set_config';
 89  	     IF l_from_result = -1
 90  	     THEN
 91  	       l_return := l_return || ' SOSL_START_JOBS: ' || p_from;
 92  	     END IF;
 93  	     IF l_to_result = -1
 94  	     THEN
 95  	       l_return := l_return || ' SOSL_STOP_JOBS ' || p_to;
 96  	     END IF;
 97  	     l_return := l_return || ' see SOSL_SERVER_LOG for details';
 98  	   ELSE
 99  	     IF p_from = '-1' OR p_to = '-1'
100  	     THEN
101  	       l_return := 'SUCCESS disabled server timeframe with -1';
102  	     ELSE
103  	       l_return := 'SUCCESS set server timeframe to ' || p_from || ' - ' || p_to;
104  	     END IF;
105  	   END IF;
106  	 ELSE
107  	   sosl_log.minimal_warning_log(l_caller, l_log_category, 'User ' || l_user || ' wanted to set server timeframe to ' || p_from || ' - ' || p_to || ' without sufficient role rights.');
108  	   l_return := 'ERROR insufficient privileges. Needs at least role SOSL_EXECUTOR.';
109  	 END IF;
110  	 RETURN l_return;
111    EXCEPTION
112  	 WHEN OTHERS THEN
113  	   -- log the error instead of RAISE
114  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
115  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
116  	   RETURN 'ERROR executing SOSL_API.SET_TIMEFRAME see SOSL_SERVER_LOG for details';
117    END set_timeframe;
118  
119    FUNCTION has_scripts
120  	 RETURN NUMBER
121    IS
122  	 l_return NUMBER;
123    BEGIN
124  	 l_return := sosl_sys.has_scripts;
125  	 RETURN l_return;
126    EXCEPTION
127  	 WHEN OTHERS THEN
128  	   -- log the error instead of RAISE
129  	   sosl_log.exception_log('sosl_api.has_scripts', 'SOSL_API', SQLERRM);
130  	   RETURN -1;
131    END has_scripts;
132  
133    FUNCTION create_executor( p_executor_name	 IN VARCHAR2
134  			       , p_function_owner	 IN VARCHAR2
135  			       , p_fn_has_scripts	 IN VARCHAR2
136  			       , p_fn_get_next_script	 IN VARCHAR2
137  			       , p_fn_set_script_status  IN VARCHAR2
138  			       , p_cfg_file		 IN VARCHAR2
139  			       , p_use_mail		 IN NUMBER     DEFAULT 0
140  			       , p_fn_send_db_mail	 IN VARCHAR2   DEFAULT NULL
141  			       , p_executor_description  IN VARCHAR2   DEFAULT NULL
142  			       )
143  	 RETURN NUMBER
144    IS
145  	 l_return	 NUMBER;
146  	 l_user 	 VARCHAR2(128);
147  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
148  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.create_executor';
149    BEGIN
150  	 l_user   := SYS_CONTEXT('USERENV', 'SESSION_USER');
151  	 IF sosl_util.has_role(l_user, 'SOSL_EXECUTOR')
152  	 THEN
153  	   l_return := sosl_util.create_executor( p_executor_name
154  						, l_user
155  						, p_function_owner
156  						, p_fn_has_scripts
157  						, p_fn_get_next_script
158  						, p_fn_set_script_status
159  						, p_cfg_file
160  						, p_use_mail
161  						, p_fn_send_db_mail
162  						, p_executor_description
163  						)
164  	   ;
165  	 ELSE
166  	   sosl_log.minimal_warning_log(l_caller, l_log_category, 'User ' || l_user || ' wanted to create an executor named ' || p_executor_name || ' using function owner ' || p_function_owner || ' without sufficient role rights.');
167  	   l_return := -1;
168  	 END IF;
169  	 RETURN l_return;
170    EXCEPTION
171  	 WHEN OTHERS THEN
172  	   -- log the error instead of RAISE
173  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
174  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
175  	   RETURN -1;
176    END create_executor;
177  
178    FUNCTION activate_executor(p_executor_id IN NUMBER)
179  	 RETURN VARCHAR2
180    IS
181  	 l_return	 VARCHAR2(4000);
182  	 l_user 	 VARCHAR2(128);
183  	 l_result	 NUMBER;
184  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
185  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.activate_executor';
186    BEGIN
187  	 l_user   := SYS_CONTEXT('USERENV', 'SESSION_USER');
188  	 IF sosl_util.has_role(l_user, 'SOSL_EXECUTOR')
189  	 THEN
190  	   l_result := sosl_util.active_state_executor(p_executor_id, sosl_constants.NUM_YES);
191  	   IF l_result = -1
192  	   THEN
193  	     l_return := 'ERROR activating executor with id ' || p_executor_id || ' see SOSL_SERVER_LOG for details';
194  	   ELSE
195  	     l_return := 'SUCCESS Activated executor with id ' || p_executor_id;
196  	   END IF;
197  	 ELSE
198  	   sosl_log.minimal_warning_log(l_caller, l_log_category, 'User ' || l_user || ' wanted to activate executor with id ' || p_executor_id || ' without sufficient role rights.');
199  	   l_return := 'ERROR insufficient privileges. Needs at least role SOSL_EXECUTOR.';
200  	 END IF;
201  	 RETURN l_return;
202    EXCEPTION
203  	 WHEN OTHERS THEN
204  	   -- log the error instead of RAISE
205  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
206  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
207  	   RETURN 'ERROR executing SOSL_API.ACTIVATE_EXECUTOR see SOSL_SERVER_LOG for details';
208    END activate_executor;
209  
210    FUNCTION deactivate_executor(p_executor_id IN NUMBER)
211  	 RETURN VARCHAR2
212    IS
213  	 l_return	 VARCHAR2(4000);
214  	 l_user 	 VARCHAR2(128);
215  	 l_result	 NUMBER;
216  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
217  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.deactivate_executor';
218    BEGIN
219  	 l_user   := SYS_CONTEXT('USERENV', 'SESSION_USER');
220  	 IF sosl_util.has_role(l_user, 'SOSL_EXECUTOR')
221  	 THEN
222  	   l_result := sosl_util.active_state_executor(p_executor_id, sosl_constants.NUM_NO);
223  	   IF l_result = -1
224  	   THEN
225  	     l_return := 'ERROR deactivating executor with id ' || p_executor_id || ' see SOSL_SERVER_LOG for details';
226  	   ELSE
227  	     l_return := 'SUCCESS Deactivated executor with id ' || p_executor_id;
228  	   END IF;
229  	 ELSE
230  	   sosl_log.minimal_warning_log(l_caller, l_log_category, 'User ' || l_user || ' wanted to deactivate executor with id ' || p_executor_id || ' without sufficient role rights.');
231  	   l_return := 'ERROR insufficient privileges. Needs at least role SOSL_EXECUTOR.';
232  	 END IF;
233  	 RETURN l_return;
234    EXCEPTION
235  	 WHEN OTHERS THEN
236  	   -- log the error instead of RAISE
237  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
238  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
239  	   RETURN 'ERROR executing SOSL_API.DEACTIVATE_EXECUTOR see SOSL_SERVER_LOG for details';
240    END deactivate_executor;
241  
242    FUNCTION set_executor_reviewed(p_executor_id IN NUMBER)
243  	 RETURN VARCHAR2
244    IS
245  	 l_return	 VARCHAR2(4000);
246  	 l_user 	 VARCHAR2(128);
247  	 l_result	 NUMBER;
248  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
249  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.set_executor_reviewed';
250    BEGIN
251  	 l_user   := SYS_CONTEXT('USERENV', 'SESSION_USER');
252  	 IF sosl_util.has_role(l_user, 'SOSL_REVIEWER')
253  	 THEN
254  	   l_result := sosl_util.review_state_executor(p_executor_id, sosl_constants.NUM_YES);
255  	   IF l_result = -1
256  	   THEN
257  	     l_return := 'ERROR set executor with id ' || p_executor_id || ' to reviewed see SOSL_SERVER_LOG for details';
258  	   ELSE
259  	     l_return := 'SUCCESS Set executor with id ' || p_executor_id || ' to reviewed';
260  	   END IF;
261  	 ELSE
262  	   sosl_log.minimal_warning_log(l_caller, l_log_category, 'User ' || l_user || ' wanted to set executor with id ' || p_executor_id || ' to reviewed without sufficient role rights.');
263  	   l_return := 'ERROR insufficient privileges. Needs at least role SOSL_REVIEWER.';
264  	 END IF;
265  	 RETURN l_return;
266    EXCEPTION
267  	 WHEN OTHERS THEN
268  	   -- log the error instead of RAISE
269  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
270  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
271  	   RETURN 'ERROR executing SOSL_API.SET_EXECUTOR_REVIEWED see SOSL_SERVER_LOG for details';
272    END set_executor_reviewed;
273  
274    FUNCTION revoke_executor_reviewed(p_executor_id IN NUMBER)
275  	 RETURN VARCHAR2
276    IS
277  	 l_return	 VARCHAR2(4000);
278  	 l_user 	 VARCHAR2(128);
279  	 l_result	 NUMBER;
280  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
281  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.revoke_executor_reviewed';
282    BEGIN
283  	 l_user   := SYS_CONTEXT('USERENV', 'SESSION_USER');
284  	 IF sosl_util.has_role(l_user, 'SOSL_REVIEWER')
285  	 THEN
286  	   l_result := sosl_util.review_state_executor(p_executor_id, sosl_constants.NUM_NO);
287  	   IF l_result = -1
288  	   THEN
289  	     l_return := 'ERROR set executor with id ' || p_executor_id || ' to not reviewed see SOSL_SERVER_LOG for details';
290  	   ELSE
291  	     l_return := 'SUCCESS Set executor with id ' || p_executor_id || ' to not reviewed';
292  	   END IF;
293  	 ELSE
294  	   sosl_log.minimal_warning_log(l_caller, l_log_category, 'User ' || l_user || ' wanted to set executor with id ' || p_executor_id || ' to not reviewed without sufficient role rights.');
295  	   l_return := 'ERROR insufficient privileges. Needs at least role SOSL_REVIEWER.';
296  	 END IF;
297  	 RETURN l_return;
298    EXCEPTION
299  	 WHEN OTHERS THEN
300  	   -- log the error instead of RAISE
301  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
302  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
303  	   RETURN 'ERROR executing SOSL_API.REVOKE_EXECUTOR_REVIEWED see SOSL_SERVER_LOG for details';
304    END revoke_executor_reviewed;
305  
306    FUNCTION add_script( p_script_name    IN VARCHAR2
307  			  , p_executor_id    IN NUMBER
308  			  , p_run_order      IN NUMBER	 DEFAULT 1
309  			  , p_script_active  IN NUMBER	 DEFAULT 0
310  			  )
311  	 RETURN NUMBER
312    IS
313  	 l_return	 NUMBER;
314  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
315  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.add_script';
316    BEGIN
317  	 l_return := sosl_if.add_script(p_script_name, p_executor_id, p_run_order, p_script_active);
318  	 RETURN l_return;
319    EXCEPTION
320  	 WHEN OTHERS THEN
321  	   -- log the error instead of RAISE
322  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
323  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
324  	   RETURN -1;
325    END add_script;
326  
327    FUNCTION db_in_time
328  	 RETURN BOOLEAN
329    IS
330  	 l_return	 BOOLEAN;
331  	 l_log_category  sosl_server_log.log_category%TYPE := 'SOSL_API';
332  	 l_caller	 sosl_server_log.caller%TYPE	   := 'sosl_api.db_in_time';
333    BEGIN
334  	 l_return := sosl_util.db_in_time;
335  	 RETURN l_return;
336    EXCEPTION
337  	 WHEN OTHERS THEN
338  	   -- log the error instead of RAISE
339  	   sosl_log.exception_log(l_caller, l_log_category, SQLERRM);
340  	   RETURN FALSE;
341    END db_in_time;
342  
343  END;
344  /

Package body created.

SQL> -- views
SQL> @@../sosl_ddl/views/sosl_config_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE VIEW sosl_config_v
  2  AS
  3  	 WITH cfg AS
  4  	      (SELECT config_name
  5  		    , CASE
  6  			WHEN config_name != 'SOSL_PATH_CFG'
  7  			THEN config_value
  8  			ELSE CASE
  9  			       WHEN sosl_util.has_role(SYS_CONTEXT('USERENV', 'SESSION_USER'), 'SOSL_REVIEWER')
 10  			       THEN config_value
 11  			       ELSE '***'
 12  			     END
 13  		      END AS config_value
 14  		    , CASE
 15  			WHEN config_name = 'SOSL_SCHEMA'
 16  			THEN 'Schema setup'
 17  			WHEN config_name = 'SOSL_RUNMODE'
 18  			THEN 'Database and server'
 19  			WHEN config_name IN ( 'SOSL_MAX_PARALLEL'
 20  					    , 'SOSL_DEFAULT_WAIT'
 21  					    , 'SOSL_NOJOB_WAIT'
 22  					    , 'SOSL_PAUSE_WAIT'
 23  					    , 'SOSL_START_JOBS'
 24  					    , 'SOSL_STOP_JOBS'
 25  					    )
 26  			THEN 'Database configuration'
 27  			WHEN config_name IN ( 'SOSL_SERVER_STATE'
 28  					    , 'SOSL_PATH_CFG'
 29  					    , 'SOSL_PATH_TMP'
 30  					    , 'SOSL_PATH_LOG'
 31  					    , 'SOSL_START_LOG'
 32  					    , 'SOSL_BASE_LOG'
 33  					    , 'SOSL_EXT_LOG'
 34  					    , 'SOSL_EXT_TMP'
 35  					    , 'SOSL_EXT_LOCK'
 36  					    , 'SOSL_EXT_ERROR'
 37  					    )
 38  			THEN 'Server configuration'
 39  			ELSE 'Unknown parameter'
 40  		      END						   AS configuration_by
 41  		    , config_type
 42  		    , CASE
 43  			WHEN config_max_length = -1
 44  			 AND config_type       = 'CHAR'
 45  			THEN '4000 chars'
 46  			WHEN config_max_length = -1
 47  			 AND config_type       = 'NUMBER'
 48  			THEN 'max int length'
 49  			ELSE TO_CHAR(config_max_length) || ' chars'
 50  		      END						   AS length_limit
 51  		    , config_description
 52  		    , TO_CHAR(updated, 'YYYY-MM-DD HH24:MI:SS') 	   AS updated
 53  		    , updated_by
 54  		    , updated_by_os
 55  		    , TO_CHAR(created, 'YYYY-MM-DD HH24:MI:SS') 	   AS created
 56  		    , created_by
 57  		    , created_by_os
 58  		    , CASE
 59  			WHEN config_name = 'SOSL_SCHEMA'
 60  			THEN 7
 61  			WHEN config_name = 'SOSL_RUNMODE'
 62  			THEN 1
 63  			WHEN config_name IN ( 'SOSL_START_JOBS'
 64  					    , 'SOSL_STOP_JOBS'
 65  					    )
 66  			THEN 2
 67  			WHEN config_name = 'SOSL_MAX_PARALLEL'
 68  			THEN 3
 69  			WHEN config_name IN ( 'SOSL_DEFAULT_WAIT'
 70  					    , 'SOSL_NOJOB_WAIT'
 71  					    , 'SOSL_PAUSE_WAIT'
 72  					    )
 73  			THEN 4
 74  			WHEN config_name = 'SOSL_SERVER_STATE'
 75  			THEN 5
 76  			WHEN config_name IN ( 'SOSL_PATH_CFG'
 77  					    , 'SOSL_PATH_TMP'
 78  					    , 'SOSL_PATH_LOG'
 79  					    , 'SOSL_START_LOG'
 80  					    , 'SOSL_BASE_LOG'
 81  					    , 'SOSL_EXT_LOG'
 82  					    , 'SOSL_EXT_TMP'
 83  					    , 'SOSL_EXT_LOCK'
 84  					    , 'SOSL_EXT_ERROR'
 85  					    )
 86  			THEN 6
 87  			ELSE 8
 88  		      END						   AS config_order
 89  		 FROM sosl_config
 90  	      )
 91    SELECT cfg.config_name
 92  	    , cfg.config_value
 93  	    , cfg.configuration_by
 94  	    , cfg.config_type
 95  	    , cfg.length_limit
 96  	    , cfg.config_description
 97  	    , cfg.updated
 98  	    , cfg.updated_by
 99  	    , cfg.updated_by_os
100  	    , cfg.created
101  	    , cfg.created_by
102  	    , cfg.created_by_os
103  	 FROM cfg
104  	ORDER BY cfg.config_order
105  	       , cfg.config_name
106  ;

View created.

SQL> GRANT SELECT ON sosl_config_v TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_executors_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE VIEW sosl_executors_v
  2  AS
  3    SELECT executor_name
  4  	    , function_owner
  5  	    , sosl_util.yes_no(use_mail) AS use_mail
  6  	    , sosl_util.yes_no(executor_active) AS executor_active
  7  	    , sosl_util.yes_no(executor_reviewed) AS executor_reviewed
  8  	    , fn_has_scripts
  9  	    , fn_get_next_script
 10  	    , fn_set_script_status
 11  	    , fn_send_db_mail
 12  	    , script_schema
 13  	    , CASE
 14  		WHEN sosl_util.has_role(SYS_CONTEXT('USERENV', 'SESSION_USER'), 'SOSL_REVIEWER')
 15  		THEN cfg_file
 16  		ELSE '***'
 17  	      END AS cfg_file
 18  	    , executor_description
 19  	    , executor_id
 20  	    , TO_CHAR(created, 'YYYY-MM-DD HH24:MI:SS') 	   AS created
 21  	    , created_by
 22  	    , created_by_os
 23  	    , TO_CHAR(updated, 'YYYY-MM-DD HH24:MI:SS') 	   AS updated
 24  	    , updated_by
 25  	    , updated_by_os
 26  	 FROM sosl_executor_definition
 27  ;

View created.

SQL> GRANT SELECT ON sosl_executors_v TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_run_queue_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE VIEW sosl_run_queue_v
  2  AS
  3    SELECT srq.run_id
  4  	    , sed.executor_name
  5  	    , srq.script_file
  6  	    , sosl_constants.run_state_text(srq.run_state)	       AS run_state
  7  	    , srq.ext_script_id
  8  	    , TO_CHAR(srq.created, 'YYYY-MM-DD HH24:MI:SS.FF9')        AS created
  9  	    , TO_CHAR(srq.waiting, 'YYYY-MM-DD HH24:MI:SS.FF9')        AS waiting
 10  	    , TO_CHAR(srq.enqueued, 'YYYY-MM-DD HH24:MI:SS.FF9')       AS enqueued
 11  	    , TO_CHAR(srq.started, 'YYYY-MM-DD HH24:MI:SS.FF9')        AS started
 12  	    , TO_CHAR(srq.running_since, 'YYYY-MM-DD HH24:MI:SS.FF9')  AS running_since
 13  	    , TO_CHAR(srq.finished, 'YYYY-MM-DD HH24:MI:SS.FF9')       AS finished
 14  	    , srq.created_by
 15  	    , srq.waiting_by
 16  	    , srq.enqueued_by
 17  	    , srq.started_by
 18  	    , srq.running_by
 19  	    , srq.finished_by
 20  	    , srq.created_by_os
 21  	    , srq.waiting_by_os
 22  	    , srq.enqueued_by_os
 23  	    , srq.started_by_os
 24  	    , srq.running_by_os
 25  	    , srq.finished_by_os
 26  	    , srq.executor_id
 27  	    , srq.run_state					       AS run_state_num
 28  	 FROM sosl_run_queue srq
 29  	 LEFT OUTER JOIN sosl_executor_definition sed
 30  	   ON srq.executor_id = sed.executor_id
 31  	-- first all scripts pending or running
 32  	ORDER BY srq.run_state
 33  	       , srq.created DESC
 34  ;

View created.

SQL> GRANT SELECT ON sosl_run_queue_v TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_run_stats_by_executor_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE VIEW sosl_run_stats_by_executor_v
  2  AS
  3  	 WITH run_stats AS
  4  	      (SELECT /*+MATERIALIZE*/
  5  		      executor_id
  6  		    , run_state
  7  		    , COUNT(*) AS script_count
  8  		 FROM sosl_run_queue
  9  		GROUP BY executor_id
 10  		       , run_state
 11  	      )
 12    SELECT sed.executor_name
 13  	    , sosl_constants.run_state_text(run_stats.run_state) AS run_state
 14  	    , run_stats.script_count
 15  	    , run_stats.executor_id
 16  	    , run_stats.run_state				 AS run_state_num
 17  	 FROM run_stats
 18  	 LEFT OUTER JOIN sosl_executor_definition sed
 19  	   ON run_stats.executor_id = sed.executor_id
 20  	ORDER BY run_stats.run_state
 21  	       , run_stats.executor_id
 22  ;

View created.

SQL> GRANT SELECT ON sosl_run_stats_by_executor_v TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_run_stats_total_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE VIEW sosl_run_stats_total_v
  2  AS
  3  	 WITH run_states AS
  4  	      (SELECT -1 AS run_state FROM dual
  5  		UNION ALL
  6  	       SELECT 0 AS run_state FROM dual
  7  		UNION ALL
  8  	       SELECT 1 AS run_state FROM dual
  9  		UNION ALL
 10  	       SELECT 2 AS run_state FROM dual
 11  		UNION ALL
 12  	       SELECT 3 AS run_state FROM dual
 13  		UNION ALL
 14  	       SELECT 4 AS run_state FROM dual
 15  	      )
 16  	    , run_stats AS
 17  	      (SELECT /*+MATERIALIZE*/
 18  		      run_state
 19  		    , COUNT(*) AS script_count
 20  		 FROM sosl_run_queue
 21  		GROUP BY run_state
 22  	      )
 23    SELECT sosl_constants.run_state_text(run_states.run_state)  AS run_state
 24  	    , NVL(run_stats.script_count, 0)			   AS script_count
 25  	    , run_states.run_state				   AS run_state_num
 26  	 FROM run_states
 27  	 LEFT OUTER JOIN run_stats
 28  	   ON run_states.run_state = run_stats.run_state
 29  	ORDER BY run_states.run_state
 30  ;

View created.

SQL> GRANT SELECT ON sosl_run_stats_total_v TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_server_log_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE VIEW sosl_server_log_v
  2  AS
  3  SELECT TO_CHAR(exec_timestamp, 'YYYY-MM-DD HH24:MI:SS.FF9') AS exec_time
  4  	  , log_type
  5  	  , log_category
  6  	  , message
  7  	  , run_id
  8  	  , executor_id
  9  	  , guid
 10  	  , sosl_identifier
 11  	  , caller
 12  	  , ext_script_id
 13  	  , script_file
 14  	  , created_by
 15  	  , created_by_os
 16  	  , full_message
 17  	  , exec_timestamp
 18    FROM sosl_server_log
 19   ORDER BY exec_timestamp DESC
 20  ;

View created.

SQL> GRANT SELECT ON sosl_server_log_v TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/views/sosl_sperrorlog_v.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE VIEW sosl_sperrorlog_v
  2  AS
  3    SELECT exec_time
  4  	    , username
  5  	    , script
  6  	    , identifier
  7  	    , message
  8  	    , statement
  9  	    , exec_timestamp
 10  	 FROM (SELECT TO_CHAR(timestamp, 'YYYY-MM-DD HH24:MI:SS.FF9') AS exec_time
 11  		    , username
 12  		    , script
 13  		    , identifier
 14  		    , message
 15  		    , statement
 16  		    , timestamp AS exec_timestamp
 17  		 FROM soslerrorlog
 18  		UNION ALL
 19  		  -- include setup log
 20  	       SELECT TO_CHAR(timestamp, 'YYYY-MM-DD HH24:MI:SS.FF9') AS exec_time
 21  		    , username
 22  		    , script
 23  		    , identifier
 24  		    , message
 25  		    , statement
 26  		    , timestamp AS exec_timestamp
 27  		 FROM sperrorlog
 28  		WHERE username = (SELECT sosl_schema FROM sosl_install_v)
 29  	      )
 30  	ORDER BY exec_timestamp DESC
 31  ;

View created.

SQL> GRANT SELECT ON sosl_sperrorlog_v TO sosl_user;

Grant succeeded.

SQL> -- ==============INSTALL done==============
SQL> @@../sosl_sql/util/log_silent.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> SET ECHO OFF
SUCCESS - no errors found during setup          0
