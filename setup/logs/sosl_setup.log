SQL> -- roles
SQL> @@../sosl_ddl/roles/create_roles.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- create sosl roles
SQL> CREATE ROLE sosl_admin;

Role created.

SQL> CREATE ROLE sosl_executor;

Role created.

SQL> CREATE ROLE sosl_reviewer;

Role created.

SQL> CREATE ROLE sosl_user;

Role created.

SQL> CREATE ROLE sosl_guest;

Role created.

SQL> -- hierarchical grants
SQL> GRANT sosl_guest TO sosl_user;

Grant succeeded.

SQL> GRANT sosl_user TO sosl_reviewer;

Grant succeeded.

SQL> GRANT sosl_reviewer TO sosl_executor;

Grant succeeded.

SQL> GRANT sosl_executor TO sosl_admin;

Grant succeeded.

SQL> -- types
SQL> @@../sosl_ddl/types/sosl_payload.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- basic api exchange type, only header, no member function
SQL> CREATE OR REPLACE TYPE sosl_payload
  2    AS OBJECT
  3  	 /* This type is used to exchange information on executor, external script id and the script filename including
  4  	 * relative or full path which must exist on the server SOSL is running.
  5  	 * It does not provide any member functions only fields to fill. Object initialization basic example:
  6  	 * DECLARE
  7  	 *   -- to access the type from other schemas, do not forget to qualify it with the SOSL schema used
  8  	 *   l_sosl_payload SOSL.SOSL_PAYLOAD;
  9  	 * BEGIN
 10  	 *   l_sosl_payload := sosl_payload(1, 'My script ID', '../../mydir/scriptfile.sql');
 11  	 * END;
 12  	 */
 13  	 ( executor_id	  NUMBER(38, 0)  -- the executor_id from SOSL_EXECUTOR_DEFINITION responsible for the script
 14  	 , ext_script_id  VARCHAR2(4000) -- the external script id managed by the executor
 15  	 , script_file	  VARCHAR2(4000) -- the script file name with full or relative path on the server where SOSL is running locally
 16  	 )
 17  ;
 18  /

Type created.

SQL> -- SQLPlus error logging table
SQL> @@../sosl_ddl/tables/soslerrorlog.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, equals SPERRORLOG
SQL> CREATE TABLE soslerrorlog
  2    ( username    VARCHAR2(256)
  3    , timestamp   TIMESTAMP
  4  	 -- older versions than Oracle 23 use VARCHAR2(1024)
  5    , script      CLOB	   -- VARCHAR2(1024)
  6    , identifier  VARCHAR2(256)
  7    , message     CLOB
  8    , statement   CLOB
  9    )
 10  ;

Table created.

SQL> COMMENT ON TABLE soslerrorlog IS 'Userdefined table for SQLPlus error logging';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.username IS 'Oracle account name';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.timestamp IS 'Time when the error occurred';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.script IS 'Name of the originating script if applicable';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.identifier IS 'User defined identifier string';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.message IS 'ORA, PLA or SP2 error message. No feed back messages are included. For example, "PL/SQL Block Created" is not recorded.';

Comment created.

SQL> COMMENT ON COLUMN soslerrorlog.statement IS 'The statement causing the error';

Comment created.

SQL> -- Grants, inherited by others, no guest and user access on tables
SQL> GRANT SELECT ON soslerrorlog TO sosl_reviewer;

Grant succeeded.

SQL> -- logging table
SQL> @@../sosl_ddl/tables/sosl_server_log.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_server_log
  2    ( exec_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP 		     NOT NULL
  3  	 -- due to Oracle limitations we must use trigger not a package variable, trigger takes care
  4  	 -- to assign a default INFO log type if getting sosl_sys.NA_TYPE
  5    , log_type	   VARCHAR2(30)    DEFAULT 'n/a'			     NOT NULL
  6    , log_category	   VARCHAR2(256)   DEFAULT 'n/a'			     NOT NULL
  7    , message	   VARCHAR2(4000)					     NOT NULL
  8    , run_id 	   NUMBER(38, 0)
  9    , executor_id	   NUMBER(38, 0)
 10    , guid		   VARCHAR2(64)
 11    , sosl_identifier   VARCHAR2(256)
 12    , caller 	   VARCHAR2(256)
 13    , ext_script_id	   VARCHAR2(4000)
 14    , script_file	   VARCHAR2(4000)
 15    , created_by	   VARCHAR2(256)   DEFAULT USER 			     NOT NULL
 16    , created_by_os	   VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , full_message	   CLOB
 18    )
 19    -- monthly partitions
 20    PARTITION BY RANGE (exec_timestamp)
 21    INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
 22    (PARTITION P_OLD
 23  	   VALUES LESS THAN (TO_TIMESTAMP('01-01-2024','DD-MM-YYYY'))
 24    )
 25  ;

Table created.

SQL> COMMENT ON TABLE sosl_server_log IS 'Holds the log events of the SOSL server CMD and interaction with the database as well as database events. Update is not allowed. Will use the alias slog.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.exec_timestamp IS 'The timestamp of the event. Automatically set by trigger, no set allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_type IS 'The logging type, supports currently INFO, WARNING, ERROR, FATAL, SUCCESS. Mandatory. Defined in package SOSL_SYS.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.log_category IS 'The log writer may provide an short log category description.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.message IS 'The shortend log message. Mandatory. If only a CLOB is passed, the short message is build from the CLOB. Categories too long will be cutted.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.full_message IS 'The full log message. For messages longer than 4000 bytes or char.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.guid IS 'The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.sosl_identifier IS 'The exact identifier for SOSLERRORLOG if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.run_id IS 'The associated run id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.executor_id IS 'The associated executor id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.script_file IS 'The script filename as delivered, including relative or absolute path.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.ext_script_id IS 'The (external) script id if available. No constraints active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.caller IS 'Caller identification if available, to distinguish database processes from SOSL CMD server processes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by IS 'The logged in DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_server_log.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- no primary key, only index
SQL> CREATE INDEX sosl_server_log_idx
  2    ON sosl_server_log (exec_timestamp, log_type, log_category)
  3  ;

Index created.

SQL> -- no constraints, as Oracle does not allow package functions in CHECK conditions
SQL> 
SQL> -- Grants, inherited by others, no guest and user access on tables
SQL> GRANT SELECT ON sosl_server_log TO sosl_reviewer;

Grant succeeded.

SQL> -- SOSL objects basic objects
SQL> @@../sosl_ddl/tables/sosl_config.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_config
  2    ( config_name	     VARCHAR2(128)					       NOT NULL
  3    , config_value	     VARCHAR2(4000)					       NOT NULL
  4    , config_max_length   NUMBER	     DEFAULT -1 			       NOT NULL
  5    , config_type	     VARCHAR2(6)     DEFAULT 'CHAR'			       NOT NULL
  6    , created	     DATE	     DEFAULT SYSDATE			       NOT NULL
  7    , updated	     DATE	     DEFAULT SYSDATE			       NOT NULL
  8    , created_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
  9    , created_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 10    , updated_by	     VARCHAR2(256)   DEFAULT USER			       NOT NULL
 11    , updated_by_os	     VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 12    , config_description  VARCHAR2(4000)
 13    )
 14  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_config IS 'Holds the configuration used by SOSL. Will use the alias scfg.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_name IS 'The unique case sensitive name of the SOSL configuration object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_value IS 'The configuration value always as VARCHAR2. Type handling and conversion must be done by the caller.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_type IS 'Defines how the config value has to be interpreted. Currently supports CHAR and NUMBER.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_max_length IS 'Defines a maximum length for CHAR type config values if set to a number > 0. Default is -1, do not not check length.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.config_description IS 'Optional description of the SOSL config object.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_config.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> 
SQL> -- primary key
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_pk
  3    PRIMARY KEY (config_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_type
  3    CHECK (config_type IN ('CHAR', 'NUMBER'))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_config
  2    ADD CONSTRAINT sosl_config_chk_max_length
  3    CHECK (config_max_length = -1 OR config_max_length > 0)
  4  ;

Table altered.

SQL> -- Grants, inherited by others, no guest and user access on tables
SQL> GRANT SELECT ON sosl_config TO sosl_reviewer;

Grant succeeded.

SQL> GRANT UPDATE ON sosl_config TO sosl_admin;

Grant succeeded.

SQL> @@../sosl_ddl/tables/sosl_executor_definition.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_executor_definition
  2    ( executor_id	       NUMBER(38, 0)   GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , executor_name	       VARCHAR2(256)						 NOT NULL
  4    , db_user	       VARCHAR2(128)						 NOT NULL
  5    , function_owner        VARCHAR2(128)						 NOT NULL
  6    , fn_has_scripts        VARCHAR2(520)						 NOT NULL
  7    , fn_get_next_script    VARCHAR2(520)						 NOT NULL
  8    , fn_set_script_status  VARCHAR2(520)						 NOT NULL
  9    , cfg_file	       VARCHAR2(4000)						 NOT NULL
 10    , use_mail	       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 11    , fn_send_db_mail       VARCHAR2(520)   DEFAULT 'yourpackage.yourfunction'	 NOT NULL
 12    , executor_active       NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 13    , executor_reviewed     NUMBER(1, 0)    DEFAULT 0				 NOT NULL
 14    , created	       DATE	       DEFAULT SYSDATE				 NOT NULL
 15    , updated	       DATE	       DEFAULT SYSDATE				 NOT NULL
 16    , created_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 17    , created_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 18    , updated_by	       VARCHAR2(256)   DEFAULT USER				 NOT NULL
 19    , updated_by_os	       VARCHAR2(256)   DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 20    , script_schema	       VARCHAR2(128)   DEFAULT NULL
 21    , executor_description  VARCHAR2(4000)
 22    )
 23  ;

Table created.

SQL> COMMENT ON TABLE sosl_executor_definition IS 'Defines the executors registered with SOSL. To improve security you may activate AUDIT on this table. Will use the alias sed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_id IS 'The generated unique id that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_name IS 'The unique name that identifies the executor.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.db_user IS 'The login name of the database user must match cfg_file login and be USER after login. No mixed case support, converted to upper case. Must exist and have the necessary rights to execute the queued scripts. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.function_owner IS 'The owner user name of the API functions, refers to the schema where the functions are defined. No mixed case support, converted to upper case. Can differ from the database user that executes SOSL. All API functions must have the same owner for one executor. No update allowed. Create a new executor, if user changes.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.fn_has_scripts IS 'The name of the interface function to use by HAS_SCRIPTS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to role SOSL_EXECUTOR. It shall not require parameters and return the amount of waiting scripts as NUMBER or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.fn_get_next_script IS 'The name of the interface function to use by GET_NEXT_SCRIPT wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to role SOSL_EXECUTOR. It shall not require parameters and return the script id, executor id and script file name as type SOSL_PAYLOAD. It should manage the given script id to ensure that scripts are not run twice.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.fn_set_script_status IS 'The name of the interface function to use by SET_SCRIPT_STATUS wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to role SOSL_EXECUTOR. It shall require the parameters P_RUN_ID IN NUMBER, P_STATUS IN NUMBER and return 0 or -1 on errors. Details can be fetched from SOSL_RUN_QUEUE. P_STATUS reflects the intended state as defined in SOSL_CONSTANTS RUN% constants. The effective state may differ from the intended state if transition has failed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.fn_send_db_mail IS 'The name of the interface function to use by SEND_DB_MAIL wrapper function, e.g. package.function or function. No mixed case support, converted to upper case. The function must have been granted with EXECUTE privilege to role SOSL_EXECUTOR. It shall require the parameters P_RUN_ID IN NUMBER, P_STATUS IN NUMBER and return 0 or -1 on errors. P_STATUS reflects the intended state as defined in SOSL_CONSTANTS RUN% constants. The effective state may differ from the intended state if transition has failed. Message building and sending is up to the defined function. If mail is activated this function is called on every state change.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.cfg_file IS 'The filename with absolute or relative path to the login config file for this executor. File and path must exist on the CMD server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.use_mail IS 'Defines if mail should be provided by SOSL. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). You may also integrate mail behind the SOSL scenes by integrating it into your interface functions.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_active IS 'Defines if the executor is active. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_reviewed IS 'Defines if the executor is reviewed, accepted and ready to be used. Accepts 0 (NO/FALSE) and 1 (YES/TRUE). Not active and reviewed executors will be ignored if they try to run scripts, every attempt gets logged. Can only be set by update, on insert always the default is used.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.script_schema IS 'The (optional) schema the script should run in. If set will cause an ALTER SESSION SET CURRENT_SCHEMA before executing the script otherwise db user schema is used. DB user must have rights for this schema if set. If acting on own schema or scripts do ALTER SESSION by themselves, you should leave it NULL.';

Comment created.

SQL> COMMENT ON COLUMN sosl_executor_definition.executor_description IS 'Optional executor description.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_pk
  3    PRIMARY KEY (executor_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- unique constraint
SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_uk
  3    UNIQUE (executor_name)
  4    ENABLE
  5  ;

Table altered.

SQL> -- check constraints
SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_chk_use_mail
  3    CHECK (use_mail IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_chk_active
  3    CHECK (executor_active IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> ALTER TABLE sosl_executor_definition
  2    ADD CONSTRAINT sosl_executor_definition_chk_reviewed
  3    CHECK (executor_reviewed IN (0, 1))
  4    ENABLE
  5  ;

Table altered.

SQL> GRANT SELECT ON sosl_executor_definition TO sosl_reviewer;

Grant succeeded.

SQL> GRANT UPDATE ON sosl_executor_definition TO sosl_reviewer;

Grant succeeded.

SQL> GRANT INSERT ON sosl_executor_definition TO sosl_executor;

Grant succeeded.

SQL> GRANT DELETE ON sosl_executor_definition TO sosl_admin;

Grant succeeded.

SQL> @@../sosl_ddl/tables/sosl_run_queue.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE TABLE sosl_run_queue
  2    ( run_id 	 NUMBER(38, 0)	 GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , run_state	 NUMBER(1, 0)	 DEFAULT 0				   NOT NULL
  4    , executor_id	 NUMBER(38, 0)						   NOT NULL
  5    , ext_script_id	 VARCHAR2(4000) 					   NOT NULL
  6    , script_file	 VARCHAR2(4000) 					   NOT NULL
  7    , script_guid	 VARCHAR2(64)	 DEFAULT 'n/a'				   NOT NULL
  8    , sosl_identifier VARCHAR2(256)	 DEFAULT 'n/a'				   NOT NULL
  9    , created	 TIMESTAMP	 DEFAULT SYSTIMESTAMP			   NOT NULL
 10    , waiting	 TIMESTAMP
 11    , enqueued	 TIMESTAMP
 12    , started	 TIMESTAMP
 13    , running_since	 TIMESTAMP
 14    , finished	 TIMESTAMP
 15    , created_by	 VARCHAR2(256)	 DEFAULT USER				   NOT NULL
 16    , created_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 17    , waiting_by	 VARCHAR2(256)	 DEFAULT USER
 18    , waiting_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 19    , enqueued_by	 VARCHAR2(256)	 DEFAULT USER
 20    , enqueued_by_os  VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 21    , started_by	 VARCHAR2(256)	 DEFAULT USER
 22    , started_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 23    , running_by	 VARCHAR2(256)	 DEFAULT USER
 24    , running_by_os	 VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 25    , finished_by	 VARCHAR2(256)	 DEFAULT USER
 26    , finished_by_os  VARCHAR2(256)	 DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 27    )
 28  ;

Table created.

SQL> COMMENT ON TABLE sosl_run_queue IS 'This table hold old and new runs of batch plans and the execution run state of each script. Granularity is single script. This is not a message queue. Will use the alias srq.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.run_id IS 'Generated unique id for a batch run script.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.run_state IS 'Holds the run state: 0 Waiting, 1 Enqueued, 2 Started, 3 Running, 4 Finished, -1 Error. To rerun a job, set run_state to 1. Will not be accepted if executor is not active and reviewed. Script dependencies are not checked. Can only be 0 or -1 on insert, managed by trigger';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.executor_id IS 'The valid executor id as returned from API (NUMBER). No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.ext_script_id IS 'The (external) identifier for the current script as returned from API (VARCHAR2). No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.script_file IS 'The script file name including (relative) path from API (VARCHAR2). No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.script_guid IS 'The unique id of the SOSL server associated with the script execution. This is a generic reference to SOSLERRORLOG.IDENTIFIER and local server logs. Set by SOSL server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.sosl_identifier IS 'The unique SOSL identifier id of the SOSL server associated with the script execution. This is a unique reference to SOSLERRORLOG.IDENTIFIER and local server logs. Set by SOSL server.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.created IS 'The date of record creation. No updates allowed, surpressed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.waiting IS 'The last date of setting the script run state to waiting (0). On insert this is the default managed by trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.enqueued IS 'The last date of setting the script run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.started IS 'The last date of setting the script run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.running_since IS 'The last date of setting the script run state to running (3).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.finished IS 'The last date of setting the script run state to finished or error (4, -1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.waiting_by IS 'Last DB user who set the record run state to waiting (0), managed by default and inser trigger, updates allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.waiting_by_os IS 'Last OS user who set the record run state to waiting (0), managed by default and insert trigger, updates allowed.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.enqueued_by IS 'Last DB user who tried to set the record run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.enqueued_by_os IS 'Last OS user who tried to set the record run state to enqueued (1).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.started_by IS 'Last DB user who tried to set the record run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.started_by_os IS 'Last OS user who tried to set the record run state to started (2).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.running_by IS 'Last DB user who tried to set the record run state to running (3).';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.running_by_os IS 'Last OS user who tried to set the record run state to running (3)';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.finished_by IS 'Last DB user who tried to set the record run state to finished (4) or -1 on errors.';

Comment created.

SQL> COMMENT ON COLUMN sosl_run_queue.finished_by_os IS 'Last OS user who tried to set the record run state to finished (4) or -1 on errors.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_run_queue
  2    ADD CONSTRAINT sosl_run_queue_pk
  3    PRIMARY KEY (run_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_run_queue
  2    ADD CONSTRAINT sosl_run_queue_chk_run_state
  3    CHECK (run_state IN (-1, 0, 1, 2, 3, 4))
  4  ;

Table altered.

SQL> -- foreign keys on all ids referenced, will set record to NULL on DELETE
SQL> ALTER TABLE sosl_run_queue
  2    ADD CONSTRAINT sosl_run_queue_executor_id_fk
  3    FOREIGN KEY (executor_id)
  4    REFERENCES sosl_executor_definition (executor_id)
  5    ON DELETE SET NULL
  6  ;

Table altered.

SQL> -- internal interface objects using the API
SQL> @@../sosl_ddl/tables/sosl_if_script.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- table is NOT qualified and created in the schema active at execution, columns ordered by access and then space consumption
SQL> CREATE TABLE sosl_if_script
  2    ( script_id	     NUMBER(38, 0)  GENERATED ALWAYS AS IDENTITY (NOCACHE NOCYCLE NOMAXVALUE)
  3    , script_name	     VARCHAR2(2000)					      NOT NULL
  4    , run_state	     NUMBER(1, 0)   DEFAULT 0				      NOT NULL
  5    , run_group	     VARCHAR2(30)   DEFAULT 'DEFAULT'			      NOT NULL
  6    , run_order	     NUMBER(38, 0)  DEFAULT 1				      NOT NULL
  7    , script_active	     NUMBER(1, 0)   DEFAULT 0				      NOT NULL
  8    , created	     DATE	    DEFAULT SYSDATE			      NOT NULL
  9    , created_by	     VARCHAR2(256)  DEFAULT USER			      NOT NULL
 10    , created_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER') NOT NULL
 11    , executor_id	     NUMBER(38, 0)
 12    , updated	     DATE
 13    , updated_by	     VARCHAR2(256)  DEFAULT USER
 14    , updated_by_os	     VARCHAR2(256)  DEFAULT SYS_CONTEXT('USERENV', 'OS_USER')
 15    , script_description  VARCHAR2(4000)
 16    )
 17  ;

Table created.

SQL> -- description
SQL> COMMENT ON TABLE sosl_if_script IS 'Internal interface table that holds the script file names that should be executed by SOSL. Used for tests and simple batch script setups. No logic control in triggers apart from insert and update dates and users. Will use the alias sis.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_id IS 'The generated unique id of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.executor_id IS 'The optional related executor id of the script file. If defined, must match an existing executor. If not defined, script is ignored.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_name IS 'The name of the script file including full or relative path. Use relative path (relative to batch_base_path or repository location) to ensure running scripts from different machines.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.run_order IS 'The order in which the script file should be executed. Same number means in parallel. Higher order numbers wait for scripts with lower order numbers to complete. Must be greater than 0.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.run_state IS 'Holds the run state: 0 Waiting, 1 Enqueued, 2 Started, 3 Running, 4 Finished, -1 Error. To rerun a job, set run_state to 1. Will not be accepted if executor is not active and reviewed. Script dependencies are not checked. Can only be 0 or -1 on insert, managed by trigger';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.run_group IS 'A minimalistic group ID provided as is. Mixed case delivers mixed results. Up to installer to manage specific groups. Allows grouping of scripts.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_active IS 'Defines active state of script. Only active scripts are handled. 0 is inactive, 1 is active.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.script_description IS 'Optional description of the script file.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.created IS 'Date created, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.updated IS 'Date updated, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.created_by IS 'DB user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.created_by_os IS 'OS user who created the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.updated_by IS 'DB user who updated the record, managed by default and trigger.';

Comment created.

SQL> COMMENT ON COLUMN sosl_if_script.updated_by_os IS 'OS user who updated the record, managed by default and trigger.';

Comment created.

SQL> -- primary key
SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_pk
  3    PRIMARY KEY (script_id)
  4    ENABLE
  5  ;

Table altered.

SQL> -- constraints
SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_chk_run_state
  3    CHECK (run_state IN (-1, 0, 1, 2, 3, 4))
  4  ;

Table altered.

SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_chk_active
  3    CHECK (script_active IN (0, 1))
  4  ;

Table altered.

SQL> -- foreign key
SQL> ALTER TABLE sosl_if_script
  2    ADD CONSTRAINT sosl_if_script_fk
  3    FOREIGN KEY (executor_id)
  4    REFERENCES sosl_executor_definition (executor_id)
  5    ON DELETE SET NULL
  6    ENABLE
  7  ;

Table altered.

SQL> -- package with no dependency on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_constants.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic package for constants used by the Simple Oracle Script Loader, no dependencies.
SQL> CREATE OR REPLACE PACKAGE sosl_constants
  2  AS
  3    /**
  4    * This package contains SOSL constant declarations and functions for retrieving the constant with pure SQL.
  5    * As there are no dependencies, exceptions must be catched or handled by the caller. No logging for this functions.
  6    */
  7  
  8    /*====================================== start package constants used by SOSL ======================================*/
  9    -- define log_type constants used in SOSL_SERVER_LOG
 10    LOG_ERROR_TYPE	     CONSTANT CHAR(5)  := 'ERROR';
 11    LOG_WARNING_TYPE      CONSTANT CHAR(7)  := 'WARNING';
 12    LOG_FATAL_TYPE	     CONSTANT CHAR(5)  := 'FATAL';
 13    LOG_INFO_TYPE	     CONSTANT CHAR(4)  := 'INFO';
 14    LOG_SUCCESS_TYPE      CONSTANT CHAR(7)  := 'SUCCESS';
 15    -- Generic n/a type. Should be different from table defaults like 'not set' as table triggers interpret their DDL default value as fallback
 16    -- to set default values using package variables, which is not supported in table DDL by Oracle using DEFAULT. Packages may use variables
 17    -- from other packages in DEFAULT declarations.
 18    GEN_NA_TYPE	     CONSTANT CHAR(3)	 := 'n/a';
 19    GEN_NA_DATE_TYPE      CONSTANT DATE	 := TO_DATE('01.01.1900', 'DD.MM.YYYY');
 20    GEN_NA_TIMESTAMP_TYPE CONSTANT TIMESTAMP  := TO_TIMESTAMP('01.01.1900', 'DD.MM.YYYY');
 21    GEN_DATE_FORMAT	     CONSTANT CHAR(21)	 := 'YYYY-MM-DD HH24:MI:SS';
 22    GEN_TIMESTAMP_FORMAT  CONSTANT CHAR(24)	 := 'YYYY-MM-DD HH24:MI:SS.FF';
 23    GEN_NULL_TEXT	     CONSTANT CHAR(4)	 := 'NULL';
 24    -- numerical equations to TRUE/YES and FALSE/NO
 25    NUM_YES		     CONSTANT INTEGER  := 1;
 26    NUM_NO		     CONSTANT INTEGER  := 0;
 27    -- default error numeric expression, that is returned by functions to indicate an error had occured
 28    NUM_ERROR	     CONSTANT INTEGER  := -1;
 29    -- default success numeric expression, that is returned by functions to indicate processing was successful
 30    NUM_SUCCESS	     CONSTANT INTEGER  := 0;
 31    -- Run states
 32    RUN_STATE_WAITING     CONSTANT INTEGER  := 0;
 33    RUN_STATE_ENQUEUED    CONSTANT INTEGER  := 1;
 34    RUN_STATE_STARTED     CONSTANT INTEGER  := 2;
 35    RUN_STATE_RUNNING     CONSTANT INTEGER  := 3;
 36    RUN_STATE_FINISHED    CONSTANT INTEGER  := 4;
 37    RUN_STATE_ERROR	     CONSTANT INTEGER  := -1;
 38    -- formatting
 39    LF		     CONSTANT CHAR(1)  := CHR(10);
 40    CR		     CONSTANT CHAR(1)  := CHR(13);
 41    CRLF		     CONSTANT CHAR(2)  := CHR(13) || CHR(10);
 42    /*====================================== end package constants used by SOSL ======================================*/
 43  
 44    /* FUNCTION SOSL_CONSTANTS.run_state_text
 45    * Returns the text interpretation (english) for the supported run states.
 46    *
 47    * @param p_run_state The numerical run state to express as text.
 48    *
 49    * @return The text equation for the given run state or sosl_constants.GEN_NA_TYPE on errors.
 50    */
 51    FUNCTION run_state_text(p_run_state IN NUMBER)
 52  	 RETURN VARCHAR2
 53  	 DETERMINISTIC
 54  	 PARALLEL_ENABLE
 55    ;
 56  
 57    -- All get_ functions only return the defined constant, no extra code. Constant name prefixed with GET_.
 58    FUNCTION get_log_error_type
 59  	 RETURN VARCHAR2
 60  	 DETERMINISTIC
 61  	 PARALLEL_ENABLE
 62    ;
 63    FUNCTION get_log_warning_type
 64  	 RETURN VARCHAR2
 65  	 DETERMINISTIC
 66  	 PARALLEL_ENABLE
 67    ;
 68    FUNCTION get_log_fatal_type
 69  	 RETURN VARCHAR2
 70  	 DETERMINISTIC
 71  	 PARALLEL_ENABLE
 72    ;
 73    FUNCTION get_log_info_type
 74  	 RETURN VARCHAR2
 75  	 DETERMINISTIC
 76  	 PARALLEL_ENABLE
 77    ;
 78    FUNCTION get_log_success_type
 79  	 RETURN VARCHAR2
 80  	 DETERMINISTIC
 81  	 PARALLEL_ENABLE
 82    ;
 83    FUNCTION get_gen_na_type
 84  	 RETURN VARCHAR2
 85  	 DETERMINISTIC
 86  	 PARALLEL_ENABLE
 87    ;
 88    FUNCTION get_gen_na_date_type
 89  	 RETURN DATE
 90  	 DETERMINISTIC
 91  	 PARALLEL_ENABLE
 92    ;
 93    FUNCTION get_gen_na_timestamp_type
 94  	 RETURN DATE
 95  	 DETERMINISTIC
 96  	 PARALLEL_ENABLE
 97    ;
 98    FUNCTION get_gen_date_format
 99  	 RETURN VARCHAR2
100  	 DETERMINISTIC
101  	 PARALLEL_ENABLE
102    ;
103    FUNCTION get_gen_timestamp_format
104  	 RETURN VARCHAR2
105  	 DETERMINISTIC
106  	 PARALLEL_ENABLE
107    ;
108    FUNCTION get_gen_null_text
109  	 RETURN VARCHAR2
110  	 DETERMINISTIC
111  	 PARALLEL_ENABLE
112    ;
113    FUNCTION get_num_yes
114  	 RETURN NUMBER
115  	 DETERMINISTIC
116  	 PARALLEL_ENABLE
117    ;
118    FUNCTION get_num_no
119  	 RETURN NUMBER
120  	 DETERMINISTIC
121  	 PARALLEL_ENABLE
122    ;
123    FUNCTION get_num_error
124  	 RETURN NUMBER
125  	 DETERMINISTIC
126  	 PARALLEL_ENABLE
127    ;
128    FUNCTION get_num_success
129  	 RETURN NUMBER
130  	 DETERMINISTIC
131  	 PARALLEL_ENABLE
132    ;
133    FUNCTION get_run_state_waiting
134  	 RETURN NUMBER
135  	 DETERMINISTIC
136  	 PARALLEL_ENABLE
137    ;
138    FUNCTION get_run_state_enqueued
139  	 RETURN NUMBER
140  	 DETERMINISTIC
141  	 PARALLEL_ENABLE
142    ;
143    FUNCTION get_run_state_started
144  	 RETURN NUMBER
145  	 DETERMINISTIC
146  	 PARALLEL_ENABLE
147    ;
148    FUNCTION get_run_state_running
149  	 RETURN NUMBER
150  	 DETERMINISTIC
151  	 PARALLEL_ENABLE
152    ;
153    FUNCTION get_run_state_finished
154  	 RETURN NUMBER
155  	 DETERMINISTIC
156  	 PARALLEL_ENABLE
157    ;
158    FUNCTION get_run_state_error
159  	 RETURN NUMBER
160  	 DETERMINISTIC
161  	 PARALLEL_ENABLE
162    ;
163    FUNCTION get_lf
164  	 RETURN VARCHAR2
165  	 DETERMINISTIC
166  	 PARALLEL_ENABLE
167    ;
168    FUNCTION get_cr
169  	 RETURN VARCHAR2
170  	 DETERMINISTIC
171  	 PARALLEL_ENABLE
172    ;
173    FUNCTION get_crlf
174  	 RETURN VARCHAR2
175  	 DETERMINISTIC
176  	 PARALLEL_ENABLE
177    ;
178  
179  END;
180  /

Package created.

SQL> -- grants
SQL> GRANT EXECUTE ON sosl_constants TO sosl_user;

Grant succeeded.

SQL> @@../sosl_ddl/packages/sosl_constants.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_constants
  2  AS
  3    -- for description see header file
  4  
  5    FUNCTION run_state_text(p_run_state IN NUMBER)
  6  	 RETURN VARCHAR2
  7  	 DETERMINISTIC
  8  	 PARALLEL_ENABLE
  9    IS
 10  	 l_return VARCHAR2(30);
 11    BEGIN
 12  	 l_return := CASE p_run_state
 13  		       WHEN sosl_constants.RUN_STATE_WAITING
 14  		       THEN 'Waiting'
 15  		       WHEN sosl_constants.RUN_STATE_ENQUEUED
 16  		       THEN 'Enqueued'
 17  		       WHEN sosl_constants.RUN_STATE_STARTED
 18  		       THEN 'Started'
 19  		       WHEN sosl_constants.RUN_STATE_RUNNING
 20  		       THEN 'Running'
 21  		       WHEN sosl_constants.RUN_STATE_FINISHED
 22  		       THEN 'Finished'
 23  		       WHEN sosl_constants.RUN_STATE_ERROR
 24  		       THEN 'ERROR'
 25  		       ELSE sosl_constants.GEN_NA_TYPE
 26  		     END;
 27  	 RETURN l_return;
 28    EXCEPTION
 29  	 WHEN OTHERS THEN
 30  	   RETURN sosl_constants.GEN_NA_TYPE;
 31    END run_state_text;
 32  
 33    FUNCTION get_log_error_type
 34  	 RETURN VARCHAR2
 35  	 DETERMINISTIC
 36  	 PARALLEL_ENABLE
 37    IS
 38    BEGIN
 39  	 RETURN sosl_constants.LOG_ERROR_TYPE;
 40    END get_log_error_type;
 41  
 42    FUNCTION get_log_warning_type
 43  	 RETURN VARCHAR2
 44  	 DETERMINISTIC
 45  	 PARALLEL_ENABLE
 46    IS
 47    BEGIN
 48  	 RETURN sosl_constants.LOG_WARNING_TYPE;
 49    END get_log_warning_type;
 50  
 51    FUNCTION get_log_fatal_type
 52  	 RETURN VARCHAR2
 53  	 DETERMINISTIC
 54  	 PARALLEL_ENABLE
 55    IS
 56    BEGIN
 57  	 RETURN sosl_constants.LOG_FATAL_TYPE;
 58    END get_log_fatal_type;
 59  
 60    FUNCTION get_log_info_type
 61  	 RETURN VARCHAR2
 62  	 DETERMINISTIC
 63  	 PARALLEL_ENABLE
 64    IS
 65    BEGIN
 66  	 RETURN sosl_constants.LOG_INFO_TYPE;
 67    END get_log_info_type;
 68  
 69    FUNCTION get_log_success_type
 70  	 RETURN VARCHAR2
 71  	 DETERMINISTIC
 72  	 PARALLEL_ENABLE
 73    IS
 74    BEGIN
 75  	 RETURN sosl_constants.LOG_SUCCESS_TYPE;
 76    END get_log_success_type;
 77  
 78    FUNCTION get_gen_na_type
 79  	 RETURN VARCHAR2
 80  	 DETERMINISTIC
 81  	 PARALLEL_ENABLE
 82    IS
 83    BEGIN
 84  	 RETURN sosl_constants.GEN_NA_TYPE;
 85    END get_gen_na_type;
 86  
 87    FUNCTION get_gen_na_date_type
 88  	 RETURN DATE
 89  	 DETERMINISTIC
 90  	 PARALLEL_ENABLE
 91    IS
 92    BEGIN
 93  	 RETURN sosl_constants.GEN_NA_DATE_TYPE;
 94    END get_gen_na_date_type;
 95  
 96    FUNCTION get_gen_na_timestamp_type
 97  	 RETURN DATE
 98  	 DETERMINISTIC
 99  	 PARALLEL_ENABLE
100    IS
101    BEGIN
102  	 RETURN sosl_constants.GEN_NA_TIMESTAMP_TYPE;
103    END get_gen_na_timestamp_type;
104  
105    FUNCTION get_gen_date_format
106  	 RETURN VARCHAR2
107  	 DETERMINISTIC
108  	 PARALLEL_ENABLE
109    IS
110    BEGIN
111  	 RETURN sosl_constants.GEN_DATE_FORMAT;
112    END get_gen_date_format;
113  
114    FUNCTION get_gen_timestamp_format
115  	 RETURN VARCHAR2
116  	 DETERMINISTIC
117  	 PARALLEL_ENABLE
118    IS
119    BEGIN
120  	 RETURN sosl_constants.GEN_TIMESTAMP_FORMAT;
121    END get_gen_timestamp_format;
122  
123    FUNCTION get_gen_null_text
124  	 RETURN VARCHAR2
125  	 DETERMINISTIC
126  	 PARALLEL_ENABLE
127    IS
128    BEGIN
129  	 RETURN sosl_constants.GEN_NULL_TEXT;
130    END get_gen_null_text;
131  
132    FUNCTION get_num_yes
133  	 RETURN NUMBER
134  	 DETERMINISTIC
135  	 PARALLEL_ENABLE
136    IS
137    BEGIN
138  	 RETURN sosl_constants.NUM_YES;
139    END get_num_yes;
140  
141    FUNCTION get_num_no
142  	 RETURN NUMBER
143  	 DETERMINISTIC
144  	 PARALLEL_ENABLE
145    IS
146    BEGIN
147  	 RETURN sosl_constants.NUM_NO;
148    END get_num_no;
149  
150    FUNCTION get_num_error
151  	 RETURN NUMBER
152  	 DETERMINISTIC
153  	 PARALLEL_ENABLE
154    IS
155    BEGIN
156  	 RETURN sosl_constants.NUM_ERROR;
157    END get_num_error;
158  
159    FUNCTION get_num_success
160  	 RETURN NUMBER
161  	 DETERMINISTIC
162  	 PARALLEL_ENABLE
163    IS
164    BEGIN
165  	 RETURN sosl_constants.NUM_SUCCESS;
166    END get_num_success;
167  
168    FUNCTION get_run_state_waiting
169  	 RETURN NUMBER
170  	 DETERMINISTIC
171  	 PARALLEL_ENABLE
172    IS
173    BEGIN
174  	 RETURN sosl_constants.RUN_STATE_WAITING;
175    END get_run_state_waiting;
176  
177    FUNCTION get_run_state_enqueued
178  	 RETURN NUMBER
179  	 DETERMINISTIC
180  	 PARALLEL_ENABLE
181    IS
182    BEGIN
183  	 RETURN sosl_constants.RUN_STATE_ENQUEUED;
184    END get_run_state_enqueued;
185  
186    FUNCTION get_run_state_started
187  	 RETURN NUMBER
188  	 DETERMINISTIC
189  	 PARALLEL_ENABLE
190    IS
191    BEGIN
192  	 RETURN sosl_constants.RUN_STATE_STARTED;
193    END get_run_state_started;
194  
195    FUNCTION get_run_state_running
196  	 RETURN NUMBER
197  	 DETERMINISTIC
198  	 PARALLEL_ENABLE
199    IS
200    BEGIN
201  	 RETURN sosl_constants.RUN_STATE_RUNNING;
202    END get_run_state_running;
203  
204    FUNCTION get_run_state_finished
205  	 RETURN NUMBER
206  	 DETERMINISTIC
207  	 PARALLEL_ENABLE
208    IS
209    BEGIN
210  	 RETURN sosl_constants.RUN_STATE_FINISHED;
211    END get_run_state_finished;
212  
213    FUNCTION get_run_state_error
214  	 RETURN NUMBER
215  	 DETERMINISTIC
216  	 PARALLEL_ENABLE
217    IS
218    BEGIN
219  	 RETURN sosl_constants.RUN_STATE_ERROR;
220    END get_run_state_error;
221  
222    FUNCTION get_lf
223  	 RETURN VARCHAR2
224  	 DETERMINISTIC
225  	 PARALLEL_ENABLE
226    IS
227    BEGIN
228  	 RETURN sosl_constants.LF;
229    END get_lf;
230  
231    FUNCTION get_cr
232  	 RETURN VARCHAR2
233  	 DETERMINISTIC
234  	 PARALLEL_ENABLE
235    IS
236    BEGIN
237  	 RETURN sosl_constants.CR;
238    END get_cr;
239  
240    FUNCTION get_crlf
241  	 RETURN VARCHAR2
242  	 DETERMINISTIC
243  	 PARALLEL_ENABLE
244    IS
245    BEGIN
246  	 RETURN sosl_constants.CRLF;
247    END get_crlf;
248  
249  END;
250  /

Package body created.

SQL> -- logging package
SQL> @@../sosl_ddl/packages/sosl_log.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic logging package, dependencies only to sosl_server_log and sosl_sys.
SQL> CREATE OR REPLACE PACKAGE sosl_log
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader for managing logging.
  5    * The interface has as well functions and procedures. Functions inform about success or error, whereas severe procedure exceptions
  6    * must be handled by the caller. The intention is to log as much information as possible before running into an exception
  7    * that can't be handled any longer.
  8    *
  9    * CURRENT ORACLE error: NOCOPY for IN parameters creates compile errors, whereas documentation allows IN NOCOPY var. Any
 10    * CLOB handling errors are possibly caused by the inability to provide a CLOB as reference.
 11    */
 12  
 13    /*====================================== start internal functions made visible for testing ======================================*/
 14    /* PROCEDURE SOSL_LOG.LOG_FALLBACK
 15    * This procedure tries some fallback actions, if logging raised an exception. It will not throw an extra exception. Intended to be
 16    * used during exception handling before raising the error.
 17    * It will try to log the error in one of this tables: SOSL_SERVER_LOG, SOSLERRORLOG, SPERRORLOG or, if everything fails output the error
 18    * via DBMS_OUTPUT.
 19    *
 20    * As we can't determine if the message contains an illegal character forcing the exception, the caller should transfer SQLERRM and
 21    * verify the transmitted content before passing it to this procedure or avoid transmitting parameters which should cause errors.
 22    *
 23    * If error could be logged it matches as follows:
 24    * SOSL_SERVER_LOG(caller, sosl_identifier, message) VALUES (p_script, p_identifier, p_message)
 25    * SOSLERRORLOG, SPERRORLOG(script, identifier, message) VALUES (p_script, p_identifier, p_message)
 26    * It will not prevent the exception, only try to log it somewhere, where it could be found without needing to analyze the db server
 27    * logs. Everything runs as autonomous transaction.
 28    *
 29    * DO NOT USE THIS PROCEDURE. It is internal for this package and only visible for testing.
 30    *
 31    * @param p_script The package function or procedure causing the error, e.g. sosl_log.log_event.
 32    * @param p_identifier The identifier for this error. Saved in SOSL_IDENTIFIER in SOSL_SERVER_LOG or IDENTIFIER in the error log tables.
 33    * @param p_message The message to save. Reduce it to SQLERRM if possible.
 34    */
 35    PROCEDURE log_fallback( p_script      IN VARCHAR2
 36  			     , p_identifier  IN VARCHAR2
 37  			     , p_message     IN VARCHAR2
 38  			     )
 39    ;
 40    /* PROCEDURE SOSL_LOG.LOG_EVENT
 41    * Writes a log entry as autonomous transaction. This is the internal base procedure, exposed for testing.
 42    * If on errors writing log entries is not possible the procedure hands the exception to the caller. This is the pure insert without
 43    * any checks. It takes the values as given and table may trigger exceptions. DO NOT USE THIS PROCEDURE. It is internal for this package.
 44    *
 45    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
 46    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Must be valid.
 47    * @param p_log_category An optional logging category.
 48    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
 49    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
 50    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
 51    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
 52    * @param p_script_file The script file name and path if available. Used as well by CMD server and SOSL packages and functions.
 53    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
 54    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
 55    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
 56    */
 57    PROCEDURE log_event( p_message	       IN VARCHAR2
 58  			  , p_log_type	       IN VARCHAR2
 59  			  , p_log_category     IN VARCHAR2
 60  			  , p_guid	       IN VARCHAR2
 61  			  , p_sosl_identifier  IN VARCHAR2
 62  			  , p_executor_id      IN NUMBER
 63  			  , p_ext_script_id    IN VARCHAR2
 64  			  , p_script_file      IN VARCHAR2
 65  			  , p_caller	       IN VARCHAR2
 66  			  , p_run_id	       IN NUMBER
 67  			  , p_full_message     IN CLOB
 68  			  )
 69    ;
 70  /*====================================== end internal functions made visible for testing ======================================*/
 71  
 72    /* FUNCTION SOSL_LOG.LOG_TYPE_VALID
 73    * Central function to check the log type. Supports the log types defined in SOSL_CONSTANTS. If log types should get expanded
 74    * adjust constants, this function, the table constraint on log_type and probably the default value for SOSL_SERVER_LOG in
 75    * table definition and trigger.
 76    *
 77    * @param p_log_type The log type to check. Case insensitive.
 78    *
 79    *@return TRUE if the given log type is supported. FALSE if not. Exceptions and errors will lead also to FALSE.
 80    */
 81    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
 82  	 RETURN BOOLEAN
 83  	 DETERMINISTIC
 84  	 PARALLEL_ENABLE
 85    ;
 86  
 87    /* FUNCTION SOSL_LOG.GET_VALID_LOG_TYPE
 88    * Verifies an given log type, returns either the given log type as upper case or the defined error default.
 89    *
 90    * @param p_log_type The log type to verify and return. Case insensitive.
 91    * @param p_error_default The alternative log type to return, if the log type is invalid. Must be a valid log type and not INFO or SUCCESS. If invalid, FATAL is returned.
 92    *
 93    * @return The valid log type as upper case on success. The valid error default if log type not supported. FATAL if the error default is invalid.
 94    */
 95    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
 96  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_constants.LOG_ERROR_TYPE
 97  				  )
 98  	 RETURN VARCHAR2
 99  	 DETERMINISTIC
100  	 PARALLEL_ENABLE
101    ;
102  
103    /* FUNCTION SOSL_LOG.DISTRIBUTE
104    * This functions distributes char data between a VARCHAR2 and a CLOB variable by the following rules:
105    * p_string empty or NULL: Fill p_string to p_max_string_length - p_split_end length.
106    * p_string length > p_max_string_length: Cut p_string to p_max_string_length, including p_split_end appended.
107    *	  p_clob NOT EMPTY: add split_start, rest of p_string before p_clob content.
108    *	  p_clob EMPTY: add split_start and rest of p_string.
109    * p_string length > 0 and < p_max_string_length: no change of p_string and p_clob.
110    * p_string and p_clob empty or NULL: leave unchanged, return FALSE otherwise always TRUE.
111    * In case of exceptions will try to write SQLERRM to p_string as CLOBs tend to be more error prone.
112    * Mainly used by SOSL_SERVER_LOG.
113    *
114    * @param p_string The string to distribute or check. In PLSQL strings can get 32767 chars long, whereas table columns are limited currently to 4000.
115    * @param p_clob The CLOB to distribute or check. Uses NOCOPY to guarantee that CLOB full length is used as given.
116    * @param p_max_string_length The maximum length p_string should have. If this size is exeeded the string gets distribute between p_string and p_clob.
117    * @param p_split_end The split end characters to indicate that the string is continued in p_clob.
118    * @param p_split_start The split start characters for the continuing string in the CLOB.
119    * @param p_delimiter The delimiter between rest of string in CLOB and original CLOB content, if both have content and string must be splitted.
120    *
121    * @return FALSE if p_string and p_clob are empty/NULL or an exception had occurred, otherwise TRUE.
122    */
123    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
124  			  , p_clob		IN OUT NOCOPY  CLOB
125  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
126  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
127  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
128  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
129  			  )
130  	 RETURN BOOLEAN
131    ;
132  
133    /* PROCEDURE SOSL_LOG.FULL_LOG
134    * Procedure with all parameters for logging. Will check parameters before logging. You should at least set also p_log_category
135    * and p_caller, to be able to assign the log entry to a specific event and object. On parameter errors a separate log entry is
136    * created. Intention is to write a log in any case and not throw any exception. This still may happen on main system malfunctions
137    * but is limited to this events.
138    * To keep things as fast as possible, column length checks are hardcoded, no extra round trip to USER_TAB_COLUMNS. If table definition
139    * changes, this package has to be adjusted.
140    *
141    * @param p_message The message to log. Limited to 4000 chars. If longer it is split and rest is stored in full_message CLOB by trigger. If NULL p_full_message must be provided.
142    * @param p_log_type The log type is basically defined by SOSL_SYS. Currently: INFO, WARNING, ERROR, FATAL, SUCCESS. Will be set to ERROR if not valid.
143    * @param p_log_category An optional logging category.
144    * @param p_caller Caller identification if available, to distinguish database processes from SOSL CMD server processes or external usage.
145    * @param p_guid The GUID the process is running with. Can be used as LIKE reference on SOSLERRORLOG. Most likely used by CMD server.
146    * @param p_sosl_identifier The exact identifier for SOSLERRORLOG if available. Most likely used by CMD server.
147    * @param p_executor_id The associated executor id if available. Used as well by CMD server and SOSL packages and functions.
148    * @param p_ext_script_id The (external) script id if available. Used as well by CMD server and SOSL packages and functions.
149    * @param p_script_file The script file name and path if available. Used as well by CMD server and SOSL packages and functions.
150    * @param p_run_id The associated run id if available. Most likely used by SOSL packages and functions.
151    * @param p_full_message The full message as CLOB if the message size exceeds the PLSQL limit of 32767 bytes. Must be given if p_message is NULL.
152    */
153    PROCEDURE full_log( p_message	      IN VARCHAR2
154  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_constants.LOG_INFO_TYPE
155  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
156  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
157  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
158  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
159  			 , p_executor_id      IN NUMBER      DEFAULT NULL
160  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
161  			 , p_script_file      IN VARCHAR2    DEFAULT NULL
162  			 , p_run_id	      IN NUMBER      DEFAULT NULL
163  			 , p_full_message     IN CLOB	     DEFAULT NULL
164  			 )
165    ;
166  
167    /* PROCEDURE SOSL_LOG.EXCEPTION_LOG
168    * Prepared and standardize logging for unhandled exceptions with reduced parameters. This procedure will not deal with extra exceptions.
169    * It will try to log the exception and then return to the caller without raising any new exceptions or logging them. It is designed
170    * for relative stability in case of exceptions. Will do a simple NVL check on parameters, nothing more before formatting and submitting
171    * the log entry. Will set log type to SOSL_CONSTANTS.LOG_FATAL_TYPE.
172    *
173    * @param p_caller The full name of function, procedure or package that has caused the unhandled exception. Case sensitive.
174    * @param p_category The log category for the function, procedure or package. Case sensitive.
175    * @param p_sqlerrmsg The full error message, usually SQLERRM. Limited to VARCHAR2 limit 32767 chars.
176    */
177    PROCEDURE exception_log( p_caller     IN VARCHAR2
178  			      , p_category   IN VARCHAR2
179  			      , p_sqlerrmsg  IN VARCHAR2
180  			      )
181    ;
182  
183    /* PROCEDURE SOSL_LOG.MINIMAL_ERROR_LOG
184    * Prepared and standardize logging for errors with reduced parameters. Will do a simple NVL check on parameters, nothing more
185    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
186    * Will set log type to SOSL_CONSTANTS.LOG_ERROR_TYPE.
187    *
188    * @param p_caller The full name of function, procedure or package that has caused the error. Case sensitive.
189    * @param p_category The log category for the function, procedure or package. Case sensitive.
190    * @param p_short_msg The short error message, preferably smaller than 4000 chars. Will be formatted using p_caller.
191    * @param p_full_msg The complete error message, with details on the error. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
192    */
193    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
194  				  , p_category	 IN VARCHAR2
195  				  , p_short_msg  IN VARCHAR2
196  				  , p_full_msg	 IN CLOB     DEFAULT NULL
197  				  )
198    ;
199    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
200  				  , p_category	 IN VARCHAR2
201  				  , p_short_msg  IN VARCHAR2
202  				  , p_full_msg	 IN VARCHAR2
203  				  )
204    ;
205  
206    /* PROCEDURE SOSL_LOG.MINIMAL_ERROR_LOG
207    * Prepared and standardize logging for information with reduced parameters. Will do a simple NVL check on parameters, nothing more
208    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
209    * Will set log type to SOSL_CONSTANTS.LOG_INFO_TYPE.
210    *
211    * @param p_caller The full name of function, procedure or package that should be logged. Case sensitive.
212    * @param p_category The log category for the function, procedure or package. Case sensitive.
213    * @param p_short_msg The short info message, preferably smaller than 4000 chars. Will be formatted using p_caller.
214    * @param p_full_msg The complete info message, with details. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
215    */
216    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
217  				 , p_category	IN VARCHAR2
218  				 , p_short_msg	IN VARCHAR2
219  				 , p_full_msg	IN CLOB      DEFAULT NULL
220  				 )
221    ;
222    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
223  				 , p_category	IN VARCHAR2
224  				 , p_short_msg	IN VARCHAR2
225  				 , p_full_msg	IN VARCHAR2
226  				 )
227    ;
228  
229    /* PROCEDURE SOSL_LOG.MINIMAL_WARNING_LOG
230    * Prepared and standardize logging for warning with reduced parameters. Will do a simple NVL check on parameters, nothing more
231    * before formatting and submitting the log entry. Will log own exceptions but not raise those exceptions.
232    * Will set log type to SOSL_CONSTANTS.LOG_WARNING_TYPE.
233    *
234    * @param p_caller The full name of function, procedure or package that should be logged. Case sensitive.
235    * @param p_category The log category for the function, procedure or package. Case sensitive.
236    * @param p_short_msg The short warning message, preferably smaller than 4000 chars. Will be formatted using p_caller.
237    * @param p_full_msg The complete warning message, with details. Will not be formatted but may contain parts of p_short_msg, if message is longer than 4000 chars.
238    */
239    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
240  				    , p_category   IN VARCHAR2
241  				    , p_short_msg  IN VARCHAR2
242  				    , p_full_msg   IN CLOB     DEFAULT NULL
243  				    )
244    ;
245    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
246  				    , p_category   IN VARCHAR2
247  				    , p_short_msg  IN VARCHAR2
248  				    , p_full_msg   IN VARCHAR2
249  				    )
250    ;
251  
252    /* PROCEDURE SOSL_LOG.LOG_COLUMN_CHANGE
253    * Checks old and new values of a given column for differences and logs the difference. The log type will be WARNING if
254    * forbidden is TRUE, otherwise INFO. Supported types: VARCHAR2, NUMBER, DATE and TIMESTAMP
255    *
256    * @param p_old_value The old column value.
257    * @param p_new_value The new column value.
258    * @param p_column_name The name of the table and column, e.g. table.column that is checked for changes. No checks, apart from NULL, only log info. Used as log category.
259    * @param p_caller The name of the procedure, package, trigger or function that is calling this procedure. No checks, apart from NULL, only log info.
260    * @param p_forbidden Influences the log type, if TRUE the log type is WARNING else the log type is INFO.
261    */
262    PROCEDURE log_column_change( p_old_value     IN VARCHAR2
263  				  , p_new_value     IN VARCHAR2
264  				  , p_column_name   IN VARCHAR2
265  				  , p_caller	    IN VARCHAR2
266  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
267  				  )
268    ;
269    PROCEDURE log_column_change( p_old_value     IN NUMBER
270  				  , p_new_value     IN NUMBER
271  				  , p_column_name   IN VARCHAR2
272  				  , p_caller	    IN VARCHAR2
273  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
274  				  )
275    ;
276    PROCEDURE log_column_change( p_old_value     IN DATE
277  				  , p_new_value     IN DATE
278  				  , p_column_name   IN VARCHAR2
279  				  , p_caller	    IN VARCHAR2
280  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
281  				  )
282    ;
283    PROCEDURE log_column_change( p_old_value     IN TIMESTAMP
284  				  , p_new_value     IN TIMESTAMP
285  				  , p_column_name   IN VARCHAR2
286  				  , p_caller	    IN VARCHAR2
287  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
288  				  )
289    ;
290  
291  END;
292  /

Package created.

SQL> -- grants
SQL> GRANT EXECUTE ON sosl_log TO sosl_executor;

Grant succeeded.

SQL> @@../sosl_ddl/packages/sosl_log.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_log
  2  AS
  3    -- for description see header file
  4    PROCEDURE log_fallback( p_script      IN VARCHAR2
  5  			     , p_identifier  IN VARCHAR2
  6  			     , p_message     IN VARCHAR2
  7  			     )
  8    IS
  9  	 PRAGMA AUTONOMOUS_TRANSACTION;
 10  	 l_saved BOOLEAN;
 11    BEGIN
 12  	 l_saved := FALSE;
 13  	 -- try to save information in tables probably available
 14  	 BEGIN
 15  	   INSERT INTO sosl_server_log
 16  	     ( message
 17  	     , log_type
 18  	     , log_category
 19  	     , sosl_identifier
 20  	     , caller
 21  	     )
 22  	     VALUES
 23  	       ( p_message
 24  	       , sosl_constants.LOG_FATAL_TYPE
 25  	       , 'SOSL_LOG internal error'
 26  	       , p_identifier
 27  	       , p_script
 28  	       )
 29  	   ;
 30  	   COMMIT;
 31  	   l_saved := TRUE;
 32  	 EXCEPTION
 33  	   WHEN OTHERS THEN
 34  	     l_saved := FALSE;
 35  	 END;
 36  	 IF NOT l_saved
 37  	 THEN
 38  	   BEGIN
 39  	     INSERT INTO soslerrorlog
 40  	       ( message
 41  	       , identifier
 42  	       , script
 43  	       , username
 44  	       , timestamp
 45  	       )
 46  	       VALUES
 47  		 ( p_message
 48  		 , p_identifier
 49  		 , p_script
 50  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 51  		 , SYSTIMESTAMP
 52  		 )
 53  	     ;
 54  	     COMMIT;
 55  	     l_saved := TRUE;
 56  	   EXCEPTION
 57  	     WHEN OTHERS THEN
 58  	       l_saved := FALSE;
 59  	   END;
 60  	 END IF;
 61  	 IF NOT l_saved
 62  	 THEN
 63  	   BEGIN
 64  	     INSERT INTO sperrorlog
 65  	       ( message
 66  	       , identifier
 67  	       , script
 68  	       , username
 69  	       , timestamp
 70  	       )
 71  	       VALUES
 72  		 ( p_message
 73  		 , p_identifier
 74  		 , p_script
 75  		 , SYS_CONTEXT('USERENV', 'SESSION_USER')
 76  		 , SYSTIMESTAMP
 77  		 )
 78  	     ;
 79  	     COMMIT;
 80  	     l_saved := TRUE;
 81  	   EXCEPTION
 82  	     WHEN OTHERS THEN
 83  	       l_saved := FALSE;
 84  	   END;
 85  	 END IF;
 86  	 -- all inserts failed, use DBMS_OUTPUT
 87  	 IF NOT l_saved
 88  	 THEN
 89  	   DBMS_OUTPUT.PUT_LINE('SOSL_LOG.LOG_FALLBACK could not save error. Fatal error in ' || p_script || ' error: ' || p_message);
 90  	 END IF;
 91    EXCEPTION
 92  	 WHEN OTHERS THEN
 93  	   -- fallback failed, let caller handle and raise the error, do nothing therefore.
 94  	   NULL;
 95    END log_fallback;
 96  
 97    PROCEDURE log_event( p_message	       IN VARCHAR2
 98  			  , p_log_type	       IN VARCHAR2
 99  			  , p_log_category     IN VARCHAR2
100  			  , p_guid	       IN VARCHAR2
101  			  , p_sosl_identifier  IN VARCHAR2
102  			  , p_executor_id      IN NUMBER
103  			  , p_ext_script_id    IN VARCHAR2
104  			  , p_script_file      IN VARCHAR2
105  			  , p_caller	       IN VARCHAR2
106  			  , p_run_id	       IN NUMBER
107  			  , p_full_message     IN CLOB
108  			  )
109    IS
110  	 PRAGMA AUTONOMOUS_TRANSACTION;
111    BEGIN
112  	 INSERT INTO sosl_server_log
113  	   ( message
114  	   , log_type
115  	   , log_category
116  	   , guid
117  	   , sosl_identifier
118  	   , executor_id
119  	   , ext_script_id
120  	   , script_file
121  	   , caller
122  	   , run_id
123  	   , full_message
124  	   )
125  	   VALUES
126  	     ( p_message
127  	     , p_log_type
128  	     , p_log_category
129  	     , p_guid
130  	     , p_sosl_identifier
131  	     , p_executor_id
132  	     , p_ext_script_id
133  	     , p_script_file
134  	     , p_caller
135  	     , p_run_id
136  	     , p_full_message
137  	     )
138  	 ;
139  	 COMMIT;
140    EXCEPTION
141  	 WHEN OTHERS THEN
142  	   -- try fallback
143  	   log_fallback('sosl_log.log_event', 'SOSL_LOG', SQLERRM);
144  	   -- try ROLLBACK
145  	   ROLLBACK;
146  	   -- and raise the error again now
147  	   RAISE;
148    END log_event;
149  
150    FUNCTION log_type_valid(p_log_type IN VARCHAR2)
151  	 RETURN BOOLEAN
152  	 DETERMINISTIC
153  	 PARALLEL_ENABLE
154    IS
155  	 l_return	     BOOLEAN;
156  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
157  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_type_valid';
158    BEGIN
159  	 l_return := FALSE;
160  	 IF UPPER(p_log_type) IN ( sosl_constants.LOG_INFO_TYPE
161  				 , sosl_constants.LOG_WARNING_TYPE
162  				 , sosl_constants.LOG_ERROR_TYPE
163  				 , sosl_constants.LOG_FATAL_TYPE
164  				 , sosl_constants.LOG_SUCCESS_TYPE
165  				 )
166  	 THEN
167  	   l_return := TRUE;
168  	 END IF;
169  	 RETURN l_return;
170    EXCEPTION
171  	 WHEN OTHERS THEN
172  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
173  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
174  		    , p_log_category => l_self_log_category
175  		    , p_guid => NULL
176  		    , p_sosl_identifier => NULL
177  		    , p_executor_id => NULL
178  		    , p_ext_script_id => NULL
179  		    , p_script_file => NULL
180  		    , p_caller => l_self_caller
181  		    , p_run_id => NULL
182  		      -- full details
183  		    , p_full_message => SQLERRM
184  		    )
185  	   ;
186  	   RETURN FALSE;
187    END log_type_valid;
188  
189    FUNCTION get_valid_log_type( p_log_type	     IN VARCHAR2
190  				  , p_error_default  IN VARCHAR2 DEFAULT sosl_constants.LOG_ERROR_TYPE
191  				  )
192  	 RETURN VARCHAR2
193  	 DETERMINISTIC
194  	 PARALLEL_ENABLE
195    IS
196  	 l_return	     VARCHAR2(30);
197  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
198  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.get_valid_log_type';
199    BEGIN
200  	 l_return := sosl_constants.LOG_FATAL_TYPE;
201  	 IF log_type_valid(p_log_type)
202  	 THEN
203  	   l_return := UPPER(p_log_type);
204  	 ELSE
205  	   IF	   log_type_valid(p_error_default)
206  	      AND  UPPER(p_error_default) NOT IN ( sosl_constants.LOG_INFO_TYPE
207  						 , sosl_constants.LOG_SUCCESS_TYPE
208  						 )
209  	   THEN
210  	     l_return := UPPER(p_error_default);
211  	   END IF;
212  	 END IF;
213  	 RETURN l_return;
214    EXCEPTION
215  	 WHEN OTHERS THEN
216  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
217  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
218  		    , p_log_category => l_self_log_category
219  		    , p_guid => NULL
220  		    , p_sosl_identifier => NULL
221  		    , p_executor_id => NULL
222  		    , p_ext_script_id => NULL
223  		    , p_script_file => NULL
224  		    , p_caller => l_self_caller
225  		    , p_run_id => NULL
226  		      -- full details
227  		    , p_full_message => SQLERRM
228  		    )
229  	   ;
230  	   RETURN sosl_constants.LOG_FATAL_TYPE;
231    END get_valid_log_type;
232  
233    FUNCTION distribute( p_string		IN OUT	       VARCHAR2
234  			  , p_clob		IN OUT NOCOPY  CLOB
235  			  , p_max_string_length IN	       INTEGER	 DEFAULT 4000
236  			  , p_split_end 	IN	       VARCHAR2  DEFAULT '...'
237  			  , p_split_start	IN	       VARCHAR2  DEFAULT '...'
238  			  , p_delimiter 	IN	       VARCHAR2  DEFAULT ' - '
239  			  )
240  	 RETURN BOOLEAN
241    IS
242  	 l_string	     VARCHAR2(32767);
243  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
244  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.distribute';
245    BEGIN
246  	 IF	(p_string IS NULL OR NVL(LENGTH(TRIM(p_string)), 0) = 0)
247  	    AND (p_clob   IS NULL OR NVL(LENGTH(TRIM(p_clob)), 0) = 0)
248  	 THEN
249  	   RETURN FALSE;
250  	 END IF;
251  	 IF	p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
252  	    AND p_clob	 IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
253  	 THEN
254  	   IF LENGTH(p_string) > p_max_string_length
255  	   THEN
256  	     -- need to split
257  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1)) || p_delimiter;
258  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
259  	     p_clob   := l_string || p_clob;
260  	   END IF;
261  	   RETURN TRUE;
262  	 END IF;
263  	 IF p_string IS NOT NULL AND NVL(LENGTH(TRIM(p_string)), 0) > 0
264  	 THEN
265  	   IF LENGTH(p_string) > p_max_string_length
266  	   THEN
267  	     -- need to split
268  	     l_string := p_split_start || SUBSTR(p_string, (p_max_string_length - LENGTH(p_split_end) + 1));
269  	     p_string := SUBSTR(p_string, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end;
270  	     p_clob   := TO_CLOB(l_string);
271  	   ELSE
272  	     p_clob := TO_CLOB(l_string);
273  	   END IF;
274  	   RETURN TRUE;
275  	 END IF;
276  	 IF p_clob IS NOT NULL AND NVL(LENGTH(TRIM(p_clob)), 0) > 0
277  	 THEN
278  	   IF LENGTH(p_clob) > p_max_string_length
279  	   THEN
280  	     p_string := TO_CHAR(SUBSTR(p_clob, 1, (p_max_string_length - LENGTH(p_split_end))) || p_split_end);
281  	   ELSE
282  	     p_string := TO_CHAR(p_clob);
283  	   END IF;
284  	   RETURN TRUE;
285  	 END IF;
286  	 -- should not reach this point
287  	 log_event( p_message => l_self_caller || ': Logic incomplete. Procedure should exit before and not reach end of procedure'
288  		  , p_log_type => sosl_constants.LOG_FATAL_TYPE
289  		  , p_log_category => l_self_log_category
290  		  , p_guid => NULL
291  		  , p_sosl_identifier => NULL
292  		  , p_executor_id => NULL
293  		  , p_ext_script_id => NULL
294  		  , p_script_file => NULL
295  		  , p_caller => l_self_caller
296  		  , p_run_id => NULL
297  		    -- full details
298  		  , p_full_message => SQLERRM
299  		  )
300  	 ;
301  	 RETURN FALSE;
302    EXCEPTION
303  	 WHEN OTHERS THEN
304  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
305  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
306  		    , p_log_category => l_self_log_category
307  		    , p_guid => NULL
308  		    , p_sosl_identifier => NULL
309  		    , p_executor_id => NULL
310  		    , p_ext_script_id => NULL
311  		    , p_script_file => NULL
312  		    , p_caller => l_self_caller
313  		    , p_run_id => NULL
314  		      -- full details
315  		    , p_full_message => SQLERRM
316  		    )
317  	   ;
318  	   RETURN FALSE;
319    END distribute;
320  
321    PROCEDURE full_log( p_message	      IN VARCHAR2
322  			 , p_log_type	      IN VARCHAR2    DEFAULT sosl_constants.LOG_INFO_TYPE
323  			 , p_log_category     IN VARCHAR2    DEFAULT 'not set'
324  			 , p_caller	      IN VARCHAR2    DEFAULT NULL
325  			 , p_guid	      IN VARCHAR2    DEFAULT NULL
326  			 , p_sosl_identifier  IN VARCHAR2    DEFAULT NULL
327  			 , p_executor_id      IN NUMBER      DEFAULT NULL
328  			 , p_ext_script_id    IN VARCHAR2    DEFAULT NULL
329  			 , p_script_file      IN VARCHAR2    DEFAULT NULL
330  			 , p_run_id	      IN NUMBER      DEFAULT NULL
331  			 , p_full_message     IN CLOB	     DEFAULT NULL
332  			 )
333    IS
334  	 -- set variables to current type
335  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
336  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.full_log';
337  	 l_log_category      sosl_server_log.log_category%TYPE;
338  	 l_log_type	     sosl_server_log.log_type%TYPE;
339  	 l_caller	     sosl_server_log.caller%TYPE;
340  	 l_guid 	     sosl_server_log.guid%TYPE;
341  	 l_sosl_identifier   sosl_server_log.sosl_identifier%TYPE;
342  	 l_executor_id	     sosl_server_log.executor_id%TYPE;
343  	 l_ext_script_id     sosl_server_log.ext_script_id%TYPE;
344  	 l_script_file	     sosl_server_log.script_file%TYPE;
345  	 l_run_id	     sosl_server_log.run_id%TYPE;
346  	 l_col_length	     INTEGER;
347    BEGIN
348  	 -- basic column checks message splitting is left to table triggers
349  	 l_log_type := sosl_log.get_valid_log_type(p_log_type);
350  	 -- LOG_CATEGORY
351  	 IF NVL(LENGTH(TRIM(p_log_category)), 0) > 256
352  	 THEN
353  	   -- write extra log entry and cut original content to limit
354  	   log_event( p_message => l_self_caller || ': p_log_category length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
355  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
356  		    , p_log_category => l_self_log_category
357  		    , p_guid => NULL
358  		    , p_sosl_identifier => NULL
359  		    , p_executor_id => NULL
360  		    , p_ext_script_id => NULL
361  		    , p_script_file => NULL
362  		    , p_caller => l_self_caller
363  		    , p_run_id => NULL
364  		      -- details and original message
365  		    , p_full_message => ('LOG_CATEGORY: ' || TRIM(p_log_category) || ' length: ' || LENGTH(TRIM(p_log_category)) || ' msg: ' || p_message || ' - ' || p_full_message)
366  		    )
367  	   ;
368  	   l_log_category := SUBSTR(TRIM(p_log_category), 1, 256);
369  	 ELSE
370  	   l_log_category := NVL(TRIM(p_log_category), sosl_constants.GEN_NA_TYPE);
371  	 END IF;
372  	 -- CALLER
373  	 IF NVL(LENGTH(TRIM(p_caller)), 0) > 256
374  	 THEN
375  	   -- write extra log entry and cut original content to limit
376  	   log_event( p_message => l_self_caller || ': p_caller length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
377  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
378  		    , p_log_category => l_self_log_category
379  		    , p_guid => NULL
380  		    , p_sosl_identifier => NULL
381  		    , p_executor_id => NULL
382  		    , p_ext_script_id => NULL
383  		    , p_script_file => NULL
384  		    , p_caller => l_self_caller
385  		    , p_run_id => NULL
386  		      -- details and original message
387  		    , p_full_message => ('CALLER: ' || TRIM(p_caller) || ' length: ' || LENGTH(TRIM(p_caller)) || ' msg: ' || p_message || ' - ' || p_full_message)
388  		    )
389  	   ;
390  	   l_caller := SUBSTR(TRIM(p_caller), 1, 256);
391  	 ELSE
392  	   l_caller := TRIM(p_caller);
393  	 END IF;
394  	 -- GUID
395  	 IF NVL(LENGTH(TRIM(p_guid)), 0) > 64
396  	 THEN
397  	   -- write extra log entry and cut original content to limit
398  	   log_event( p_message => l_self_caller || ': p_guid length exceeds column length (64) in SOSL_SERVER_LOG. See full message for message causing the error.'
399  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
400  		    , p_log_category => l_self_log_category
401  		    , p_guid => NULL
402  		    , p_sosl_identifier => NULL
403  		    , p_executor_id => NULL
404  		    , p_ext_script_id => NULL
405  		    , p_script_file => NULL
406  		    , p_caller => l_self_caller
407  		    , p_run_id => NULL
408  		      -- details and original message
409  		    , p_full_message => ('GUID: ' || TRIM(p_guid) || ' length: ' || LENGTH(TRIM(p_guid)) || ' msg: ' || p_message || ' - ' || p_full_message)
410  		    )
411  	   ;
412  	   l_guid := SUBSTR(TRIM(p_guid), 1, 64);
413  	 ELSE
414  	   l_guid := TRIM(p_guid);
415  	 END IF;
416  	 -- SOSL_IDENTIFIER
417  	 IF NVL(LENGTH(TRIM(p_sosl_identifier)), 0) > 256
418  	 THEN
419  	   -- write extra log entry and cut original content to limit
420  	   log_event( p_message => l_self_caller || ': p_sosl_identifier length exceeds column length (256) in SOSL_SERVER_LOG. See full message for message causing the error.'
421  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
422  		    , p_log_category => l_self_log_category
423  		    , p_guid => NULL
424  		    , p_sosl_identifier => NULL
425  		    , p_executor_id => NULL
426  		    , p_ext_script_id => NULL
427  		    , p_script_file => NULL
428  		    , p_caller => l_self_caller
429  		    , p_run_id => NULL
430  		      -- details and original message
431  		    , p_full_message => ('SOSL_IDENTIFIER: ' || TRIM(p_sosl_identifier) || ' length: ' || LENGTH(TRIM(p_sosl_identifier)) || ' msg: ' || p_message || ' - ' || p_full_message)
432  		    )
433  	   ;
434  	   l_sosl_identifier := SUBSTR(TRIM(p_sosl_identifier), 1, 256);
435  	 ELSE
436  	   l_sosl_identifier := TRIM(p_sosl_identifier);
437  	 END IF;
438  	 -- EXT_SCRIPT_ID
439  	 IF NVL(LENGTH(TRIM(p_ext_script_id)), 0) > 4000
440  	 THEN
441  	   -- write extra log entry and cut original content to limit
442  	   log_event( p_message => l_self_caller || ': p_ext_script_id length exceeds column length (4000) in SOSL_SERVER_LOG. See full message for message causing the error.'
443  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
444  		    , p_log_category => l_self_log_category
445  		    , p_guid => NULL
446  		    , p_sosl_identifier => NULL
447  		    , p_executor_id => NULL
448  		    , p_ext_script_id => NULL
449  		    , p_script_file => NULL
450  		    , p_caller => l_self_caller
451  		    , p_run_id => NULL
452  		      -- details and original message
453  		    , p_full_message => ('EXT_SCRIPT_ID: ' || TRIM(p_ext_script_id) || ' length: ' || LENGTH(TRIM(p_ext_script_id)) || ' msg: ' || p_message || ' - ' || p_full_message)
454  		    )
455  	   ;
456  	   l_ext_script_id := SUBSTR(TRIM(p_ext_script_id), 1, 4000);
457  	 ELSE
458  	   l_ext_script_id := TRIM(p_ext_script_id);
459  	 END IF;
460  	 -- SCRIPT_FILE
461  	 IF NVL(LENGTH(TRIM(p_script_file)), 0) > 4000
462  	 THEN
463  	   -- write extra log entry and cut original content to limit
464  	   log_event( p_message => l_self_caller || ': p_script_file length exceeds column length (4000) in SOSL_SERVER_LOG. See full message for message causing the error.'
465  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
466  		    , p_log_category => l_self_log_category
467  		    , p_guid => NULL
468  		    , p_sosl_identifier => NULL
469  		    , p_executor_id => NULL
470  		    , p_ext_script_id => NULL
471  		    , p_script_file => NULL
472  		    , p_caller => l_self_caller
473  		    , p_run_id => NULL
474  		      -- details and original message
475  		    , p_full_message => ('SCRIPT_FILE: ' || TRIM(p_script_file) || ' length: ' || LENGTH(TRIM(p_script_file)) || ' msg: ' || p_message || ' - ' || p_full_message)
476  		    )
477  	   ;
478  	   l_script_file := SUBSTR(TRIM(p_script_file), 1, 4000);
479  	 ELSE
480  	   l_script_file := TRIM(p_script_file);
481  	 END IF;
482  	 -- no check on numbers
483  	 l_executor_id := p_executor_id;
484  	 l_run_id := p_run_id;
485  	 -- try to write the given data to SOSL_SERVER_LOG
486  	 log_event( p_message => p_message
487  		  , p_log_type => l_log_type
488  		  , p_log_category => l_log_category
489  		  , p_guid => l_guid
490  		  , p_sosl_identifier => l_sosl_identifier
491  		  , p_executor_id => l_executor_id
492  		  , p_ext_script_id => l_ext_script_id
493  		  , p_script_file => l_script_file
494  		  , p_caller => l_caller
495  		  , p_run_id => l_run_id
496  		  , p_full_message => p_full_message
497  		  )
498  	 ;
499    EXCEPTION
500  	 WHEN OTHERS THEN
501  	   log_event( p_message => l_self_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(SQLERRM, 1, 500)) || CASE WHEN LENGTH(SQLERRM) > 500 THEN ' ... see full_message for complete details.' END
502  		    , p_log_type => sosl_constants.LOG_FATAL_TYPE
503  		    , p_log_category => l_self_log_category
504  		    , p_guid => NULL
505  		    , p_sosl_identifier => NULL
506  		    , p_executor_id => NULL
507  		    , p_ext_script_id => NULL
508  		    , p_script_file => NULL
509  		    , p_caller => l_self_caller
510  		    , p_run_id => NULL
511  		      -- full details and original message
512  		    , p_full_message => (SQLERRM || ': ' || p_message)
513  		    )
514  	   ;
515    END full_log;
516  
517    PROCEDURE exception_log( p_caller     IN VARCHAR2
518  			      , p_category   IN VARCHAR2
519  			      , p_sqlerrmsg  IN VARCHAR2
520  			      )
521    IS
522  	 l_category  sosl_server_log.log_category%TYPE;
523  	 l_caller    sosl_server_log.caller%TYPE;
524  	 l_message   VARCHAR2(32767);
525    BEGIN
526  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
527  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
528  	 l_message   := NVL(p_sqlerrmsg, 'Called sosl_log.exception_log without message.');
529  	 log_event( p_message => l_caller || ': Unhandled EXCEPTION = ' || TRIM(SUBSTR(l_message, 1, 500)) || CASE WHEN LENGTH(l_message) > 500 THEN ' ... see full_message for complete details.' END
530  		  , p_log_type => sosl_constants.LOG_FATAL_TYPE
531  		  , p_log_category => l_category
532  		  , p_guid => NULL
533  		  , p_sosl_identifier => NULL
534  		  , p_executor_id => NULL
535  		  , p_ext_script_id => NULL
536  		  , p_script_file => NULL
537  		  , p_caller => l_caller
538  		  , p_run_id => NULL
539  		    -- full details and original message
540  		  , p_full_message => l_message
541  		  )
542  	 ;
543    EXCEPTION
544  	 WHEN OTHERS THEN
545  	   -- no extra trouble if already in exception state
546  	   NULL;
547    END exception_log;
548  
549    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
550  				  , p_category	 IN VARCHAR2
551  				  , p_short_msg  IN VARCHAR2
552  				  , p_full_msg	 IN CLOB     DEFAULT NULL
553  				  )
554    IS
555  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
556  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_error_log CLOB';
557  	 l_category	     sosl_server_log.log_category%TYPE;
558  	 l_caller	     sosl_server_log.caller%TYPE;
559  	 l_short_msg	     VARCHAR2(32767);
560  	 l_full_msg	     CLOB;
561    BEGIN
562  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
563  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
564  	 IF p_short_msg IS NULL AND p_full_msg IS NULL
565  	 THEN
566  	   l_short_msg := l_caller || ': ERROR = Called sosl_log.minimal_error_log without any message.';
567  	   l_full_msg  := l_caller || ': ERROR = Called sosl_log.minimal_error_log without any message.';
568  	 ELSIF p_short_msg IS NULL AND p_full_msg IS NOT NULL
569  	 THEN
570  	   -- split long message
571  	   l_short_msg := l_caller || ': ERROR = ' || SUBSTR(p_full_msg, 1, 500) || CASE WHEN LENGTH(p_full_msg) > 500 THEN ' ... see full_message for complete details.' END;
572  	   l_full_msg  := p_full_msg;
573  	 ELSIF LENGTH(p_short_msg) > 3600
574  	 THEN
575  	   -- a very long short message, handle the overflow and distribute it to full message, we do not check for 4000 length to have some formatting space
576  	   l_short_msg := l_caller || ': ERROR = ' || SUBSTR(p_short_msg, 1, 500) || ' ... see full_message for complete details.';
577  	   l_full_msg  := '... ' || SUBSTR(p_short_msg, 501) || ' - ' || p_full_msg;
578  	 ELSE
579  	   -- if long message is NULL we do not care, maybe NULL or given, handled as given.
580  	   l_short_msg := l_caller || ': ERROR = ' || p_short_msg;
581  	   l_full_msg  := p_full_msg;
582  	 END IF;
583  	 log_event( p_message => l_short_msg
584  		  , p_log_type => sosl_constants.LOG_ERROR_TYPE
585  		  , p_log_category => l_category
586  		  , p_guid => NULL
587  		  , p_sosl_identifier => NULL
588  		  , p_executor_id => NULL
589  		  , p_ext_script_id => NULL
590  		  , p_script_file => NULL
591  		  , p_caller => l_caller
592  		  , p_run_id => NULL
593  		    -- full details and original message
594  		  , p_full_message => l_full_msg
595  		  )
596  	 ;
597    EXCEPTION
598  	 WHEN OTHERS THEN
599  	   -- log exception as we should not be already in exception state, only application error
600  	   -- do not raise again
601  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
602    END minimal_error_log;
603  
604    PROCEDURE minimal_error_log( p_caller	 IN VARCHAR2
605  				  , p_category	 IN VARCHAR2
606  				  , p_short_msg  IN VARCHAR2
607  				  , p_full_msg	 IN VARCHAR2
608  				  )
609    IS
610  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
611  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_error_log VARCHAR2';
612    BEGIN
613  	 sosl_log.minimal_error_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
614    EXCEPTION
615  	 WHEN OTHERS THEN
616  	   -- log exception as we should not be already in exception state, only application error
617  	   -- do not raise again
618  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
619    END minimal_error_log;
620  
621    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
622  				 , p_category	IN VARCHAR2
623  				 , p_short_msg	IN VARCHAR2
624  				 , p_full_msg	IN CLOB      DEFAULT NULL
625  				 )
626    IS
627  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
628  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_info_log CLOB';
629  	 l_category	     sosl_server_log.log_category%TYPE;
630  	 l_caller	     sosl_server_log.caller%TYPE;
631  	 l_short_msg	     VARCHAR2(32767);
632  	 l_full_msg	     CLOB;
633    BEGIN
634  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
635  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
636  	 IF p_short_msg IS NULL AND p_full_msg IS NULL
637  	 THEN
638  	   l_short_msg := l_caller || ': ERROR = Called sosl_log.minimal_info_log without any message.';
639  	   l_full_msg  := l_caller || ': ERROR = Called sosl_log.minimal_info_log without any message.';
640  	 ELSIF p_short_msg IS NULL AND p_full_msg IS NOT NULL
641  	 THEN
642  	   -- split long message
643  	   l_short_msg := SUBSTR(p_full_msg, 1, 500) || CASE WHEN LENGTH(p_full_msg) > 500 THEN ' ... see full_message for complete details.' END;
644  	   l_full_msg  := p_full_msg;
645  	 ELSIF LENGTH(p_short_msg) > 3600
646  	 THEN
647  	   -- a very long short message, handle the overflow and distribute it to full message, we do not check for 4000 length to have some formatting space
648  	   l_short_msg := SUBSTR(p_short_msg, 1, 500) || ' ... see full_message for complete details.';
649  	   l_full_msg  := '... ' || SUBSTR(p_short_msg, 501) || ' - ' || p_full_msg;
650  	 ELSE
651  	   -- if long message is NULL we do not care, maybe NULL or given, handled as given.
652  	   l_short_msg := p_short_msg;
653  	   l_full_msg  := p_full_msg;
654  	 END IF;
655  	 log_event( p_message => l_short_msg
656  		  , p_log_type => sosl_constants.LOG_INFO_TYPE
657  		  , p_log_category => l_category
658  		  , p_guid => NULL
659  		  , p_sosl_identifier => NULL
660  		  , p_executor_id => NULL
661  		  , p_ext_script_id => NULL
662  		  , p_script_file => NULL
663  		  , p_caller => l_caller
664  		  , p_run_id => NULL
665  		    -- full details and original message
666  		  , p_full_message => l_full_msg
667  		  )
668  	 ;
669    EXCEPTION
670  	 WHEN OTHERS THEN
671  	   -- log exception as we should not be already in exception state, only application error
672  	   -- do not raise again
673  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
674    END minimal_info_log;
675  
676    PROCEDURE minimal_info_log( p_caller	IN VARCHAR2
677  				 , p_category	IN VARCHAR2
678  				 , p_short_msg	IN VARCHAR2
679  				 , p_full_msg	IN VARCHAR2
680  				 )
681    IS
682  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
683  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_info_log VARCHAR2';
684    BEGIN
685  	 sosl_log.minimal_info_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
686    EXCEPTION
687  	 WHEN OTHERS THEN
688  	   -- log exception as we should not be already in exception state, only application error
689  	   -- do not raise again
690  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
691    END minimal_info_log;
692  
693    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
694  				    , p_category   IN VARCHAR2
695  				    , p_short_msg  IN VARCHAR2
696  				    , p_full_msg   IN CLOB     DEFAULT NULL
697  				    )
698    IS
699  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
700  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_warning_log CLOB';
701  	 l_category	     sosl_server_log.log_category%TYPE;
702  	 l_caller	     sosl_server_log.caller%TYPE;
703  	 l_short_msg	     VARCHAR2(32767);
704  	 l_full_msg	     CLOB;
705    BEGIN
706  	 l_category  := NVL(p_category, sosl_constants.GEN_NA_TYPE);
707  	 l_caller    := NVL(p_caller, sosl_constants.GEN_NA_TYPE);
708  	 IF p_short_msg IS NULL AND p_full_msg IS NULL
709  	 THEN
710  	   l_short_msg := l_caller || ': ERROR = Called sosl_log.minimal_warning_log without any message.';
711  	   l_full_msg  := l_caller || ': ERROR = Called sosl_log.minimal_warning_log without any message.';
712  	 ELSIF p_short_msg IS NULL AND p_full_msg IS NOT NULL
713  	 THEN
714  	   -- split long message
715  	   l_short_msg := SUBSTR(p_full_msg, 1, 500) || CASE WHEN LENGTH(p_full_msg) > 500 THEN ' ... see full_message for complete details.' END;
716  	   l_full_msg  := p_full_msg;
717  	 ELSIF LENGTH(p_short_msg) > 3600
718  	 THEN
719  	   -- a very long short message, handle the overflow and distribute it to full message, we do not check for 4000 length to have some formatting space
720  	   l_short_msg := SUBSTR(p_short_msg, 1, 500) || ' ... see full_message for complete details.';
721  	   l_full_msg  := '... ' || SUBSTR(p_short_msg, 501) || ' - ' || p_full_msg;
722  	 ELSE
723  	   -- if long message is NULL we do not care, maybe NULL or given, handled as given.
724  	   l_short_msg := p_short_msg;
725  	   l_full_msg  := p_full_msg;
726  	 END IF;
727  	 log_event( p_message => l_short_msg
728  		  , p_log_type => sosl_constants.LOG_WARNING_TYPE
729  		  , p_log_category => l_category
730  		  , p_guid => NULL
731  		  , p_sosl_identifier => NULL
732  		  , p_executor_id => NULL
733  		  , p_ext_script_id => NULL
734  		  , p_script_file => NULL
735  		  , p_caller => l_caller
736  		  , p_run_id => NULL
737  		    -- full details and original message
738  		  , p_full_message => l_full_msg
739  		  )
740  	 ;
741    EXCEPTION
742  	 WHEN OTHERS THEN
743  	   -- log exception as we should not be already in exception state, only application error
744  	   -- do not raise again
745  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
746    END minimal_warning_log;
747  
748    PROCEDURE minimal_warning_log( p_caller	   IN VARCHAR2
749  				    , p_category   IN VARCHAR2
750  				    , p_short_msg  IN VARCHAR2
751  				    , p_full_msg   IN VARCHAR2
752  				    )
753    IS
754  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
755  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.minimal_warning_log VARCHAR2';
756    BEGIN
757  	 sosl_log.minimal_warning_log(p_caller, p_category, p_short_msg, TO_CLOB(p_full_msg));
758    EXCEPTION
759  	 WHEN OTHERS THEN
760  	   -- log exception as we should not be already in exception state, only application error
761  	   -- do not raise again
762  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
763    END minimal_warning_log;
764  
765    PROCEDURE log_column_change( p_old_value     IN VARCHAR2
766  				  , p_new_value     IN VARCHAR2
767  				  , p_column_name   IN VARCHAR2
768  				  , p_caller	    IN VARCHAR2
769  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
770  				  )
771    IS
772  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
773  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change VARCHAR2';
774  	 l_log_category      sosl_server_log.log_category%TYPE;
775  	 l_caller	     sosl_server_log.caller%TYPE;
776    BEGIN
777  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
778  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
779  	   -- log parameter errors
780  	 IF p_column_name IS NULL
781  	 THEN
782  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
783  	 END IF;
784  	 IF p_caller IS NULL
785  	 THEN
786  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
787  	 END IF;
788  	 IF NVL(p_old_value, sosl_constants.GEN_NA_TYPE) != NVL(p_new_value, sosl_constants.GEN_NA_TYPE)
789  	 THEN
790  	   IF p_forbidden
791  	   THEN
792  	     sosl_log.minimal_warning_log( l_caller
793  					 , l_log_category
794  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(p_new_value, sosl_constants.GEN_NULL_TEXT)
795  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
796  					 )
797  	     ;
798  	   ELSE
799  	     sosl_log.minimal_info_log( l_caller
800  				      , l_log_category
801  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(p_old_value, sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(p_new_value, sosl_constants.GEN_NULL_TEXT)
802  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
803  				      )
804  	     ;
805  	   END IF;
806  	 END IF;
807    EXCEPTION
808  	 WHEN OTHERS THEN
809  	   -- log exception as we should not be already in exception state, only application error
810  	   -- do not raise again
811  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
812    END log_column_change; -- VARCHAR2
813  
814    PROCEDURE log_column_change( p_old_value     IN NUMBER
815  				  , p_new_value     IN NUMBER
816  				  , p_column_name   IN VARCHAR2
817  				  , p_caller	    IN VARCHAR2
818  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
819  				  )
820    IS
821  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
822  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change NUMBER';
823  	 l_log_category      sosl_server_log.log_category%TYPE;
824  	 l_caller	     sosl_server_log.caller%TYPE;
825    BEGIN
826  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
827  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
828  	   -- log parameter errors
829  	 IF p_column_name IS NULL
830  	 THEN
831  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
832  	 END IF;
833  	 IF p_caller IS NULL
834  	 THEN
835  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
836  	 END IF;
837  	 -- use TO_CHAR for comparing NULL values as there is no invalid number symbol
838  	 IF NVL(TO_CHAR(p_old_value), sosl_constants.GEN_NA_TYPE) != NVL(TO_CHAR(p_new_value), sosl_constants.GEN_NA_TYPE)
839  	 THEN
840  	   IF p_forbidden
841  	   THEN
842  	     sosl_log.minimal_warning_log( l_caller
843  					 , l_log_category
844  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(TO_CHAR(p_new_value), sosl_constants.GEN_NULL_TEXT)
845  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
846  					 )
847  	     ;
848  	   ELSE
849  	     sosl_log.minimal_info_log( l_caller
850  				      , l_log_category
851  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(TO_CHAR(p_old_value), sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(TO_CHAR(p_new_value), sosl_constants.GEN_NULL_TEXT)
852  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
853  				      )
854  	     ;
855  	   END IF;
856  	 END IF;
857    EXCEPTION
858  	 WHEN OTHERS THEN
859  	   -- log exception as we should not be already in exception state, only application error
860  	   -- do not raise again
861  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
862    END log_column_change; -- NUMBER
863  
864    PROCEDURE log_column_change( p_old_value     IN DATE
865  				  , p_new_value     IN DATE
866  				  , p_column_name   IN VARCHAR2
867  				  , p_caller	    IN VARCHAR2
868  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
869  				  )
870    IS
871  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
872  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change DATE';
873  	 l_log_category      sosl_server_log.log_category%TYPE;
874  	 l_caller	     sosl_server_log.caller%TYPE;
875    BEGIN
876  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
877  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
878  	   -- log parameter errors
879  	 IF p_column_name IS NULL
880  	 THEN
881  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
882  	 END IF;
883  	 IF p_caller IS NULL
884  	 THEN
885  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
886  	 END IF;
887  	 IF NVL(p_old_value, sosl_constants.GEN_NA_DATE_TYPE) != NVL(p_new_value, sosl_constants.GEN_NA_DATE_TYPE)
888  	 THEN
889  	   IF p_forbidden
890  	   THEN
891  	     sosl_log.minimal_warning_log( l_caller
892  					 , l_log_category
893  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_DATE_FORMAT), sosl_constants.GEN_NULL_TEXT)
894  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
895  					 )
896  	     ;
897  	   ELSE
898  	     sosl_log.minimal_info_log( l_caller
899  				      , l_log_category
900  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(TO_CHAR(p_old_value, sosl_constants.GEN_DATE_FORMAT), sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_DATE_FORMAT), sosl_constants.GEN_NULL_TEXT)
901  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
902  				      )
903  	     ;
904  	   END IF;
905  	 END IF;
906    EXCEPTION
907  	 WHEN OTHERS THEN
908  	   -- log exception as we should not be already in exception state, only application error
909  	   -- do not raise again
910  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
911    END log_column_change; -- DATE
912  
913    PROCEDURE log_column_change( p_old_value     IN TIMESTAMP
914  				  , p_new_value     IN TIMESTAMP
915  				  , p_column_name   IN VARCHAR2
916  				  , p_caller	    IN VARCHAR2
917  				  , p_forbidden     IN BOOLEAN	DEFAULT TRUE
918  				  )
919    IS
920  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_LOG';
921  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_log.log_column_change TIMESTAMP';
922  	 l_log_category      sosl_server_log.log_category%TYPE;
923  	 l_caller	     sosl_server_log.caller%TYPE;
924    BEGIN
925  	 l_log_category := NVL(UPPER(p_column_name), sosl_constants.GEN_NA_TYPE);
926  	 l_caller	:= NVL(p_caller, sosl_constants.GEN_NA_TYPE);
927  	   -- log parameter errors
928  	 IF p_column_name IS NULL
929  	 THEN
930  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_column_name is missing.');
931  	 END IF;
932  	 IF p_caller IS NULL
933  	 THEN
934  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'ERROR Parameter p_caller is missing.');
935  	 END IF;
936  	 IF NVL(p_old_value, sosl_constants.GEN_NA_TIMESTAMP_TYPE) != NVL(p_new_value, sosl_constants.GEN_NA_TIMESTAMP_TYPE)
937  	 THEN
938  	   IF p_forbidden
939  	   THEN
940  	     sosl_log.minimal_warning_log( l_caller
941  					 , l_log_category
942  					 , 'FORBIDDEN change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' tried to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_TIMESTAMP_FORMAT), sosl_constants.GEN_NULL_TEXT)
943  					 , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
944  					 )
945  	     ;
946  	   ELSE
947  	     sosl_log.minimal_info_log( l_caller
948  				      , l_log_category
949  				      , 'Change of column ' || NVL(p_column_name, sosl_constants.GEN_NA_TYPE) || ' from: ' || NVL(TO_CHAR(p_old_value, sosl_constants.GEN_TIMESTAMP_FORMAT), sosl_constants.GEN_NULL_TEXT) || ' to: ' || NVL(TO_CHAR(p_new_value, sosl_constants.GEN_TIMESTAMP_FORMAT), sosl_constants.GEN_NULL_TEXT)
950  				      , 'Change issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
951  				      )
952  	     ;
953  	   END IF;
954  	 END IF;
955    EXCEPTION
956  	 WHEN OTHERS THEN
957  	   -- log exception as we should not be already in exception state, only application error
958  	   -- do not raise again
959  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
960    END log_column_change; -- TIMESTAMP
961  
962  END;
963  /

Package body created.

SQL> -- util package
SQL> @@../sosl_ddl/packages/sosl_util.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic util package not using data objects of the Simple Oracle Script Loader, apart from sosl_sys and logging.
SQL> CREATE OR REPLACE PACKAGE sosl_util
  2  AS
  3    /**
  4    * This package contains basic functions and procedures used by the Simple Oracle Script Loader that have minimal dependencies on
  5    * SOSL object. Provides logging.
  6    */
  7  
  8    /* PROCEDURE SOSL_UTIL.SPLIT_FUNCTION_NAME
  9    * Splits the given function name into its parts. Supposed delimiter is the point ".".
 10    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 11    * @param p_package OUT parameter, contains the package name if any or NULL.
 12    * @param p_function OUT parameter, contains the pure function name.
 13    */
 14    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
 15  				    , p_package       OUT VARCHAR2
 16  				    , p_function      OUT VARCHAR2
 17  				    )
 18    ;
 19  
 20    /* FUNCTION SOSL_UTIL.HAS_DB_USER
 21    * Checks if a given user is visible for SOSL by checking ALL_USERS. Users must be visible to SOSL to be able to dynamically
 22    * grant the necessary rights on the API for script execution.
 23    *
 24    * @param p_username The database user name to check.
 25    *
 26    * @return TRUE if the user is visible in ALL_USERS to SOSL, otherwise FALSE.
 27    */
 28    FUNCTION has_db_user(p_username IN VARCHAR2)
 29  	 RETURN BOOLEAN
 30    ;
 31  
 32    /* FUNCTION SOSL_UTIL.HAS_FUNCTION
 33    * Checks if a given function or package function name is visible for SOSL by checking ALL_ATTRIBUTES. Internal SOSL packages,
 34    * apart from SOSL_IF% packages, are excluded from the search to avoid self references.
 35    *
 36    * @param p_owner The owner of the function or package function name to check.
 37    * @param p_function_name The function or package function name to check. Package functions must be qualified with the package name, e.g. my_package.my_function.
 38    * @param p_datatype The return datatype of the function expected, e.g. a valid Oracle datatype like NUMBER or VARCHAR2.
 39    *
 40    * @return TRUE if the function is visible in ALL_ATTRIBUTES to SOSL and has the required return datatype, otherwise FALSE.
 41    */
 42    FUNCTION has_function( p_owner	       IN VARCHAR2
 43  			    , p_function_name  IN VARCHAR2
 44  			    , p_datatype       IN VARCHAR2
 45  			    )
 46  	 RETURN BOOLEAN
 47    ;
 48  
 49    /*FUNCTION SOSL_UTIL.GET_COL_LENGTH
 50    * Returns the column length for a given table and column or -1 if table or column does not exist from USER_TAB_COLUMNS using
 51    * DATA_LENGTH. DATA_LENGTH is misleading if not a char type or CLOB, as CLOB types report 4000 which is definitely wrong.
 52    * The only types handled are NUMBER and CLOB. All other types return the DATA_LENGTH.
 53    *
 54    * Length for numbers is calculated by adding precision and scale.
 55    *
 56    * CLOB will return the PLSQL equation of a VARCHAR2/CLOB, which is 32767 and still wrong, but useful to see if a PLSQL can handle
 57    * the CLOB. Be careful with CLOB handling. If source is not a table column, PLSQL most likely limits it to 32767 cutting longer content.
 58    *
 59    * Objects not in the current schema will not be considered and return -1 AS USER_TAB_COLUMN is used.
 60    *
 61    * No handling for date and timestamp values, as their char representation has too much dependencies on NLS and formatting to get a
 62    * reliable length.
 63    *
 64    * Byte and char semantic is not considered only the effective chars that can be stored in CHAR or VARCHAR2 as defined by DATA_LENGTH.
 65    *
 66    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
 67    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
 68    *
 69    * @return The calculated length of the column. Fix PLSQL limit 32767 for CLOB types. DATA_LENGTH for data and timestamp types.
 70    */
 71    FUNCTION get_col_length( p_table  IN VARCHAR2
 72  			      , p_column IN VARCHAR2
 73  			      )
 74  	 RETURN INTEGER
 75    ;
 76  
 77    /* FUNCTION SOSL_UTIL.GET_COL_TYPE
 78    * Returns the type of a column from USER_TAB_COLUMNS as defined in DATA_TYPE or NA_TYPE if table or column doesn't exist.
 79    * Objects not in the current schema will not be considered and return NA_TYPE.
 80    *
 81    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
 82    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
 83    *
 84    * @return The type of the column as defined in DATA_TYPE or sosl_sys.NA_TYPE on errors or not found columns and tables.
 85    */
 86    FUNCTION get_col_type( p_table  IN VARCHAR2
 87  			    , p_column IN VARCHAR2
 88  			    )
 89  	 RETURN VARCHAR2
 90    ;
 91  
 92    /* FUNCTION SOSL_UTIL.CHECK_COL
 93    * This function can check NUMBER and VARCHAR2/CHAR columns for length and type. Passing a number for a char column type will result
 94    * in FALSE. Providing a P_VALUE with a length longer than the length calculated, will result in FALSE. It will not consider
 95    * implicite Oracle conversions. Expects type like defined.
 96    *
 97    * Number length is calculated by TO_CHAR string representation removing all delimiters and counting only numbers 0-9.
 98    * Passing a VARCHAR2 value is valid for CHAR and VARCHAR2 column types.
 99    *
100    * @param p_table The name of the table. Case insensitive. Will be transformed to UPPER.
101    * @param p_column The name of the column. Case insensitive. Will be transformed to UPPER.
102    * @param p_value The value for the table column to check against column definition.
103    *
104    * @return TRUE if value and column match in type and length, otherwise FALSE.
105    */
106    FUNCTION check_col( p_table  IN VARCHAR2
107  			 , p_column IN VARCHAR2
108  			 , p_value  IN VARCHAR2
109  			 )
110  	 RETURN BOOLEAN
111    ;
112    FUNCTION check_col( p_table  IN VARCHAR2
113  			 , p_column IN VARCHAR2
114  			 , p_value  IN NUMBER
115  			 )
116  	 RETURN BOOLEAN
117    ;
118  
119    /* FUNCTION SOSL_UTIL.HAS_ROLE
120    * This function determines if a given database user has the requested role granted.
121    *
122    * @param p_db_user The database user to check. Has to be a valid database user.
123    * @param p_role The role to check. Limited to roles starting with SOSL. Must be a valid and existing role.
124    *
125    * @return Will return TRUE, if user has the role assigned, otherwise FALSE, also in case of errors which get logged.
126    */
127    FUNCTION has_role( p_db_user IN VARCHAR2
128  			, p_role    IN VARCHAR2
129  			)
130  	 RETURN BOOLEAN
131    ;
132  
133    /* FUNCTION SOSL_UTIL.GRANT_ROLE
134    * This function grants a given database user the given role.
135    *
136    * @param p_db_user The database user to get the role grant. Has to be a valid database user.
137    * @param p_role The role to grant. Limited to roles starting with SOSL. Must be a valid and existing role with ADMIN rights for SOSL schema.
138    *
139    * @return Will return TRUE, if user has the role or has been granted the role successfully, otherwise FALSE, also in case of errors which get logged.
140    */
141    FUNCTION grant_role( p_db_user IN VARCHAR2
142  			  , p_role    IN VARCHAR2
143  			  )
144  	 RETURN BOOLEAN
145    ;
146  
147    /* FUNCTION SOSL_UTIL.REVOKE_ROLE
148    * This function revoke a given role from a given database user.
149    *
150    * @param p_db_user The database user to remove the role grant. Has to be a valid database user.
151    * @param p_role The role to remove. Limited to roles starting with SOSL. Must be a valid and existing role with ADMIN rights for SOSL schema.
152    *
153    * @return Will return TRUE, if user has not the role or has been revoked the role successfully, otherwise FALSE, also in case of errors which get logged.
154    */
155    FUNCTION revoke_role( p_db_user IN VARCHAR2
156  			   , p_role    IN VARCHAR2
157  			   )
158  	 RETURN BOOLEAN
159    ;
160  
161    /* FUNCTION SOSL_UTIL.UTC_MAIL_DATE
162    * Returns the current date timestamp as a formatted string for date values in mail.
163    *
164    * @return A date string conform to RFC5322 for using mail or NULL on errors.
165    *
166    * @see https://datatracker.ietf.org/doc/html/rfc5322
167    */
168    FUNCTION utc_mail_date
169  	 RETURN VARCHAR2
170    ;
171  
172    /* FUNCTION SOSL_UTIL.FORMAT_MAIL
173    * This function formats a mail message conforming to RFC5322. The content of p_message is not checked against RFC. This is
174    * the repsonsibility of the user. This is for small messages that do not exceed 32k in total.
175    *
176    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
177    * @param p_recipients The semicolon separated list of mail recipient addresses.
178    * @param p_subject A preferablly short subject for the mail.
179    * @param p_message The correctly formatted mail message.
180    *
181    * @return A formatted string with complete mail message that can be used with RFC compliant mail servers or NULL on errors.
182    */
183    FUNCTION format_mail( p_sender	   IN VARCHAR2
184  			   , p_recipients  IN VARCHAR2
185  			   , p_subject	   IN VARCHAR2
186  			   , p_message	   IN VARCHAR2
187  			   )
188  	 RETURN VARCHAR2
189    ;
190  
191    /* FUNCTION SOSL_UTIL.CHECK_MAIL_ADDRESS
192    * Checks the format of an email address roughly. Does not check if this is a valid and working email address.
193    * Format checking based on a minimal email address like a@b.io, which requires a minimum length of six chars
194    * and having the @ and the . as domain separator in the email address. Errors will get logged.
195    *
196    * @param The email address to check, basic expected format is user@company.domain.
197    *
198    * @return Return TRUE if the address fulfills the minimum criteria for a mail address otherwise FALSE, including for errors.
199    */
200    FUNCTION check_mail_address_format(p_mail_address IN VARCHAR2)
201  	 RETURN BOOLEAN
202    ;
203  
204    /* FUNCTION SOSL_UTIL.DUMMY_MAIL
205    * This is a testing function that will NOT send any mail. It will log the mail message created in SOSL_SERVER_LOG using
206    * the field full_message, so output can be controlled.
207    *
208    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
209    * @param p_recipients The semicolon separated list of mail recipient addresses.
210    * @param p_subject A preferablly short subject for the mail.
211    * @param p_message The correctly formatted mail message.
212    *
213    * @return Will return 0 on success or -1 on errors.
214    */
215    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
216  			  , p_recipients  IN VARCHAR2
217  			  , p_subject	  IN VARCHAR2
218  			  , p_message	  IN VARCHAR2
219  			  )
220  	 RETURN NUMBER
221    ;
222  
223    /* FUNCTION SOSL_UTIL.TXT_BOOLEAN
224    * Provides text values to display instead of BOOLEAN or NUMBER values interpreted as BOOLEAN. Numbers are interpreted
225    * similar to Oracle SQL, where 0 is FALSE and 1 is TRUE. 1 is considered as TRUE, any other value as FALSE. NULL values
226    * are interpreted as sosl_sys.NA_TYPE. Maximum 10 characters for TRUE/FALSE equation.
227    *
228    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
229    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
230    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
231    *
232    * @return The text equation for the given p_bool value or sosl_constants.GEN_NA_TYPE on errors.
233    */
234    FUNCTION txt_boolean( p_bool   IN BOOLEAN
235  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
236  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
237  			   )
238  	 RETURN VARCHAR2
239  	 DETERMINISTIC
240  	 PARALLEL_ENABLE
241    ;
242    FUNCTION txt_boolean( p_bool   IN NUMBER
243  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
244  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
245  			   )
246  	 RETURN VARCHAR2
247  	 DETERMINISTIC
248  	 PARALLEL_ENABLE
249    ;
250  
251    /* FUNCTION SOSL_UTIL.YES_NO
252    * A simple wrapper for txt_boolean with YES/NO instead of TRUE/FALSE.
253    *
254    * @param p_bool The BOOLEAN or NUMBER value that should be interpreted.
255    * @param p_true The text equation for TRUE, maximum 10 characters. Longer strings get cut. Case is not controlled.
256    * @param p_false The text equation for FALSE, maximum 10 characters. Longer strings get cut. Case is not controlled.
257    *
258    * @return The text equation for the given p_bool value or sosl_constants.GEN_NA_TYPE on errors.
259    */
260    FUNCTION yes_no( p_bool	 IN BOOLEAN
261  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
262  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
263  		      )
264  	 RETURN VARCHAR2
265  	 DETERMINISTIC
266  	 PARALLEL_ENABLE
267    ;
268    FUNCTION yes_no( p_bool	 IN NUMBER
269  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
270  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
271  		      )
272  	 RETURN VARCHAR2
273  	 DETERMINISTIC
274  	 PARALLEL_ENABLE
275    ;
276  
277    /* FUNCTION SOSL_UTIL.OBJECT_DATE
278    * Works only for objects in the current schema, using USER_OBJECTS. Will return the LAST_DDL_TIME or the NA date type
279    * from SOSL_CONSTANTS if the object could not be found. Object type has to conform to object types used in USER_OBJECTS.
280    *
281    * @param p_object_name The name of the object, will be transformed to UPPERCASE as SOSL does not use mixed case.
282    * @param p_object_type A valid object type for USER_OBJECTS, e.g. FUNCTION, PACKAGE, PACKAGE BODY, PROCEDURE.
283    *
284    * @return The LAST_DDL_TIME as noted in USER_OBJECTS or SOSL_CONSTANTS.GEN_NA_DATE_TYPE on errors or not found.
285    */
286    FUNCTION object_date( p_object_name IN VARCHAR2
287  			   , p_object_type IN VARCHAR2
288  			   )
289  	 RETURN DATE
290    ;
291  
292    /* FUNCTION SOSL_UTIL.GET_VALID_RUN_STATE
293    * Checks if given run state in valid and returns the valid run state or error state.
294    *
295    * @param The run state to check. See SOSL_CONSTANTS for defined run states.
296    *
297    * @return Either the given run state if valid or SOSL_CONSTANTS.RUN_STATE_ERROR.
298    */
299    FUNCTION get_valid_run_state(p_run_state IN NUMBER)
300  	 RETURN NUMBER
301    ;
302  
303  END;
304  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_util.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_util
  2  AS
  3    -- for description see header file
  4    PROCEDURE split_function_name( p_function_name IN  VARCHAR2
  5  				    , p_package       OUT VARCHAR2
  6  				    , p_function      OUT VARCHAR2
  7  				    )
  8    IS
  9  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
 10  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.split_function_name';
 11    BEGIN
 12  	 IF INSTR(p_function_name, '.') > 0
 13  	 THEN
 14  	   p_package   := TRIM(SUBSTR(p_function_name, 1, INSTR(p_function_name, '.') -1));
 15  	   p_function  := TRIM(SUBSTR(p_function_name, INSTR(p_function_name, '.') +1));
 16  	 ELSE
 17  	   p_package   := NULL;
 18  	   p_function  := TRIM(p_function_name);
 19  	 END IF;
 20    EXCEPTION
 21  	 WHEN OTHERS THEN
 22  	   -- log event and raise
 23  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 24  	   RAISE;
 25    END split_function_name;
 26  
 27    FUNCTION has_db_user(p_username IN VARCHAR2)
 28  	 RETURN BOOLEAN
 29    IS
 30  	 l_has_user	     NUMBER;
 31  	 l_return	     BOOLEAN;
 32  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
 33  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.has_db_user';
 34    BEGIN
 35  	 l_return := FALSE;
 36  	 SELECT COUNT(*) INTO l_has_user FROM all_users WHERE username = p_username;
 37  	 IF l_has_user != 0
 38  	 THEN
 39  	   l_return := TRUE;
 40  	 END IF;
 41  	 RETURN l_return;
 42    EXCEPTION
 43  	 WHEN OTHERS THEN
 44  	   -- log event instead of raise
 45  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 46  	   RETURN FALSE;
 47    END has_db_user;
 48  
 49    FUNCTION has_function( p_owner	       IN VARCHAR2
 50  			    , p_function_name  IN VARCHAR2
 51  			    , p_datatype       IN VARCHAR2
 52  			    )
 53  	 RETURN BOOLEAN
 54    IS
 55  	 l_has_function      NUMBER;
 56  	 l_package	     VARCHAR2(128);
 57  	 l_function	     VARCHAR2(128);
 58  	 l_return	     BOOLEAN;
 59  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_UTIL';
 60  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.has_function';
 61    BEGIN
 62  	 l_return := FALSE;
 63  	 split_function_name(p_function_name, l_package, l_function);
 64  	 SELECT COUNT(*)
 65  	   INTO l_has_function
 66  	   FROM all_arguments
 67  	  WHERE position		   = 0				     -- only functions
 68  	    AND argument_name		   IS NULL			     -- only functions
 69  	    AND data_type		   = p_datatype
 70  	    AND owner			   = UPPER(p_owner)
 71  	    AND NVL(package_name, 'N/A')   = NVL(UPPER(l_package), 'N/A')    -- may not contain a package name
 72  	    AND object_name		   = UPPER(l_function)
 73  	    AND package_name		   NOT IN ( 'SOSL_SYS'		     -- exclude internal packages that should never be referenced
 74  						  , 'SOSL_UTIL'
 75  						  , 'SOSL_LOG'
 76  						  , 'SOSL_CONSTANTS'
 77  						  , 'SOSL_API'
 78  						  )
 79  	 ;
 80  	 IF l_has_function != 0
 81  	 THEN
 82  	   l_return := TRUE;
 83  	 END IF;
 84  	 RETURN l_return;
 85    EXCEPTION
 86  	 WHEN OTHERS THEN
 87  	   -- log event instead of raise
 88  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 89  	   RETURN FALSE;
 90    END has_function;
 91  
 92    FUNCTION get_col_length( p_table  IN VARCHAR2
 93  			      , p_column IN VARCHAR2
 94  			      )
 95  	 RETURN INTEGER
 96    IS
 97  	 l_return	     INTEGER;
 98  	 l_has_column	     INTEGER;
 99  	 l_data_type	     user_tab_columns.data_type%TYPE;
100  	 l_data_length	     user_tab_columns.data_length%TYPE;
101  	 l_data_precision    user_tab_columns.data_precision%TYPE;
102  	 l_data_scale	     user_tab_columns.data_scale%TYPE;
103  	 l_self_log_category sosl_server_log.log_category%TYPE	   := 'SOSL_UTIL';
104  	 l_self_caller	     sosl_server_log.caller%TYPE	   := 'sosl_util.get_col_length';
105    BEGIN
106  	 l_return := -1;
107  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
108  	 IF l_has_column = 1
109  	 THEN
110  	   -- column match calculate length
111  	   SELECT data_type
112  		, data_length
113  		, data_precision
114  		, data_scale
115  	     INTO l_data_type
116  		, l_data_length
117  		, l_data_precision
118  		, l_data_scale
119  	     FROM user_tab_columns
120  	    WHERE table_name  = UPPER(p_table)
121  	      AND column_name = UPPER(p_column)
122  	   ;
123  	   IF l_data_type = 'NUMBER'
124  	   THEN
125  	     IF l_data_scale != 0
126  	     THEN
127  	       -- consider delimiter
128  	       l_return := l_data_precision + l_data_scale;
129  	     ELSE
130  	       l_return := l_data_precision;
131  	     END IF;
132  	   ELSIF l_data_type = 'CLOB'
133  	   THEN
134  	     l_return := 32767;
135  	   ELSE
136  	     l_return := l_data_length;
137  	   END IF;
138  	 END IF;
139  	 RETURN l_return;
140    EXCEPTION
141  	 WHEN OTHERS THEN
142  	   -- log event instead of raise
143  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
144  	   RETURN sosl_constants.NUM_ERROR;
145    END get_col_length;
146  
147    FUNCTION get_col_type( p_table  IN VARCHAR2
148  			    , p_column IN VARCHAR2
149  			    )
150  	 RETURN VARCHAR2
151    IS
152  	 l_return	     VARCHAR2(128);
153  	 l_has_column	     INTEGER;
154  	 l_data_type	     user_tab_columns.data_type%TYPE;
155  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
156  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.get_col_type';
157    BEGIN
158  	 l_return := sosl_constants.GEN_NA_TYPE;
159  	 SELECT COUNT(*) INTO l_has_column FROM user_tab_columns WHERE table_name = UPPER(p_table) AND column_name = UPPER(p_column);
160  	 IF l_has_column = 1
161  	 THEN
162  	   -- column match get data type
163  	   SELECT data_type
164  	     INTO l_return
165  	     FROM user_tab_columns
166  	    WHERE table_name  = UPPER(p_table)
167  	      AND column_name = UPPER(p_column)
168  	   ;
169  	 END IF;
170  	 RETURN l_return;
171    EXCEPTION
172  	 WHEN OTHERS THEN
173  	   -- log event instead of raise
174  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
175  	   RETURN sosl_constants.GEN_NA_TYPE;
176    END get_col_type;
177  
178    FUNCTION check_col( p_table  IN VARCHAR2
179  			 , p_column IN VARCHAR2
180  			 , p_value  IN VARCHAR2
181  			 )
182  	 RETURN BOOLEAN
183    IS
184  	 l_return	     BOOLEAN;
185  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
186  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.check_col VARCHAR';
187    BEGIN
188  	 l_return := FALSE;
189  	 IF sosl_util.get_col_type(p_table, p_column) IN ('VARCHAR2', 'CHAR')
190  	 THEN
191  	   IF NVL(LENGTH(p_value), 0) <= sosl_util.get_col_length(p_table, p_column)
192  	   THEN
193  	     l_return := TRUE;
194  	   END IF;
195  	 END IF;
196  	 RETURN l_return;
197    EXCEPTION
198  	 WHEN OTHERS THEN
199  	   -- log event instead of raise
200  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
201  	   RETURN FALSE;
202    END check_col; -- VARCHAR2 variant
203  
204    FUNCTION check_col( p_table  IN VARCHAR2
205  			 , p_column IN VARCHAR2
206  			 , p_value  IN NUMBER
207  			 )
208  	 RETURN BOOLEAN
209    IS
210  	 l_return	     BOOLEAN;
211  	 l_number	     VARCHAR2(128);
212  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
213  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.check_col NUMBER';
214    BEGIN
215  	 l_return := FALSE;
216  	 IF sosl_util.get_col_type(p_table, p_column) = 'NUMBER'
217  	 THEN
218  	   l_number := REGEXP_REPLACE(TO_CHAR(p_value), '[^0-9]', '');
219  	   IF NVL(LENGTH(l_number), 0) <= sosl_util.get_col_length(p_table, p_column)
220  	   THEN
221  	     l_return := TRUE;
222  	   END IF;
223  	 END IF;
224  	 RETURN l_return;
225    EXCEPTION
226  	 WHEN OTHERS THEN
227  	   -- log event instead of raise
228  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
229  	   RETURN FALSE;
230    END check_col; -- NUMBER variant
231  
232    FUNCTION has_role( p_db_user IN VARCHAR2
233  			, p_role    IN VARCHAR2
234  			)
235  	 RETURN BOOLEAN
236    IS
237  	 l_count	     NUMBER;
238  	 l_return	     BOOLEAN;
239  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
240  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.has_role';
241    BEGIN
242  	 l_return := FALSE;
243  	 SELECT COUNT(*)
244  	   INTO l_count
245  	   FROM dba_role_privs
246  	  WHERE granted_role LIKE 'SOSL%'
247  	    AND grantee      = UPPER(p_db_user)
248  	    AND granted_role = UPPER(p_role)
249  	 ;
250  	 l_return := (l_count != 0);
251  	 RETURN l_return;
252    EXCEPTION
253  	 WHEN OTHERS THEN
254  	   -- log event instead of raise
255  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
256  	   RETURN FALSE;
257    END has_role;
258  
259    FUNCTION grant_role( p_db_user IN VARCHAR2
260  			  , p_role    IN VARCHAR2
261  			  )
262  	 RETURN BOOLEAN
263    IS
264  	 PRAGMA AUTONOMOUS_TRANSACTION;
265  	 l_return	     BOOLEAN;
266  	 l_statement	     VARCHAR2(1024);
267  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
268  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.grant_role';
269    BEGIN
270  	 l_return := FALSE;
271  	 IF has_role(p_db_user, p_role)
272  	 THEN
273  	   -- has grant everything is okay
274  	   l_return := TRUE;
275  	 ELSE
276  	   -- give grant
277  	   l_statement := 'GRANT ' || p_role || ' TO ' || p_db_user;
278  	   BEGIN
279  	     EXECUTE IMMEDIATE l_statement;
280  	     l_return := TRUE;
281  	   EXCEPTION
282  	     WHEN OTHERS THEN
283  	       -- log error
284  	       sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM || ' - Could not execute: ' || l_statement);
285  	       l_return := FALSE;
286  	   END;
287  	 END IF;
288  	 RETURN l_return;
289    EXCEPTION
290  	 WHEN OTHERS THEN
291  	   -- log event instead of raise
292  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
293  	   RETURN FALSE;
294    END grant_role;
295  
296    FUNCTION revoke_role( p_db_user IN VARCHAR2
297  			   , p_role    IN VARCHAR2
298  			   )
299  	 RETURN BOOLEAN
300    IS
301  	 PRAGMA AUTONOMOUS_TRANSACTION;
302  	 l_return	     BOOLEAN;
303  	 l_statement	     VARCHAR2(1024);
304  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
305  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.revoke_role';
306    BEGIN
307  	 l_return := FALSE;
308  	 IF NOT has_role(p_db_user, p_role)
309  	 THEN
310  	   -- role not given or revoked
311  	   l_return := TRUE;
312  	 ELSE
313  	   -- give grant
314  	   l_statement := 'REVOKE ' || p_role || ' FROM ' || p_db_user;
315  	   BEGIN
316  	     EXECUTE IMMEDIATE l_statement;
317  	     l_return := TRUE;
318  	   EXCEPTION
319  	     WHEN OTHERS THEN
320  	       -- log error
321  	       sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM || ' - Could not execute: ' || l_statement);
322  	       l_return := FALSE;
323  	   END;
324  	 END IF;
325  	 RETURN l_return;
326    EXCEPTION
327  	 WHEN OTHERS THEN
328  	   -- log event instead of raise
329  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
330  	   RETURN FALSE;
331    END revoke_role;
332  
333    FUNCTION utc_mail_date
334  	 RETURN VARCHAR2
335    IS
336  	 l_date VARCHAR2(500);
337    BEGIN
338  	 l_date := TO_CHAR(SYSTIMESTAMP AT TIME ZONE SESSIONTIMEZONE, 'Dy, DD Mon YYYY HH24:MI:SS TZHTZM');
339  	 RETURN l_date;
340    EXCEPTION
341  	 WHEN OTHERS THEN
342  	   -- log event instead of raise
343  	   sosl_log.exception_log('sosl_util.utc_mail_date', 'SOSL_UTIL', SQLERRM);
344  	   RETURN NULL;
345    END utc_mail_date;
346  
347    FUNCTION format_mail( p_sender	   IN VARCHAR2
348  			   , p_recipients  IN VARCHAR2
349  			   , p_subject	   IN VARCHAR2
350  			   , p_message	   IN VARCHAR2
351  			   )
352  	 RETURN VARCHAR2
353    IS
354  	 l_crlf 	 VARCHAR2(2)	   := CHR(13) || CHR(10);
355  	 l_mail_message  VARCHAR2(32767);
356    BEGIN
357  	 l_mail_message := 'From: ' || p_sender || l_crlf ||
358  			   'To: ' || p_recipients || l_crlf ||
359  			   'Date: ' || sosl_util.utc_mail_date || l_crlf ||
360  			   'Subject: ' || p_subject || l_crlf ||
361  			   p_message
362  	 ;
363  	 RETURN l_mail_message;
364    EXCEPTION
365  	 WHEN OTHERS THEN
366  	   -- log event instead of raise
367  	   sosl_log.exception_log('sosl_util.format_mail', 'SOSL_UTIL', SQLERRM);
368  	   RETURN NULL;
369    END format_mail;
370  
371    FUNCTION check_mail_address_format(p_mail_address IN VARCHAR2)
372  	 RETURN BOOLEAN
373    IS
374  	 l_return	     BOOLEAN;
375  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_UTIL';
376  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_util.check_mail_address_format';
377    BEGIN
378  	 l_return := FALSE;
379  	 IF	 LENGTH(p_mail_address) > 5
380  	    AND  INSTR(p_mail_address, '@') > 0
381  	    AND  INSTR(p_mail_address, '.') > 0
382  	 THEN
383  	   l_return := TRUE;
384  	 END IF;
385  	 RETURN l_return;
386    EXCEPTION
387  	 WHEN OTHERS THEN
388  	   -- log event instead of raise
389  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
390  	   RETURN FALSE;
391    END check_mail_address_format;
392  
393    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
394  			  , p_recipients  IN VARCHAR2
395  			  , p_subject	  IN VARCHAR2
396  			  , p_message	  IN VARCHAR2
397  			  )
398  	 RETURN NUMBER
399    IS
400  	 l_message	     VARCHAR2(32767);
401  	 l_self_log_category sosl_server_log.log_category%TYPE	 := 'MAIL DUMMY';
402  	 l_self_caller	     sosl_server_log.caller%TYPE	 := 'sosl_util.dummy_mail';
403    BEGIN
404  	 l_message := sosl_util.format_mail(p_sender, p_recipients, p_subject, p_message);
405  	 sosl_log.minimal_info_log(l_self_caller, l_self_log_category, 'Fake mail with subject "' || p_subject || '" created in full_message. Check the results.', l_message);
406  	 RETURN sosl_constants.NUM_SUCCESS;
407    EXCEPTION
408  	 WHEN OTHERS THEN
409  	   -- log the error instead of RAISE
410  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
411  	   RETURN sosl_constants.NUM_ERROR;
412    END dummy_mail;
413  
414    FUNCTION txt_boolean( p_bool   IN BOOLEAN
415  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
416  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
417  			   )
418  	 RETURN VARCHAR2
419  	 DETERMINISTIC
420  	 PARALLEL_ENABLE
421    IS
422    BEGIN
423  	 IF p_bool
424  	 THEN
425  	   RETURN TRIM(SUBSTR(NVL(p_true, 'TRUE'), 1, 10));
426  	 ELSE
427  	   RETURN TRIM(SUBSTR(NVL(p_false, 'FALSE'), 1, 10));
428  	 END IF;
429    EXCEPTION
430  	 WHEN OTHERS THEN
431  	   sosl_log.exception_log('sosl_util.txt_boolean BOOLEAN', 'SOSL_UTIL', SQLERRM);
432  	   RETURN sosl_constants.GEN_NA_TYPE;
433    END txt_boolean; -- boolean input
434  
435    FUNCTION txt_boolean( p_bool   IN NUMBER
436  			   , p_true   IN VARCHAR2 DEFAULT 'TRUE'
437  			   , p_false  IN VARCHAR2 DEFAULT 'FALSE'
438  			   )
439  	 RETURN VARCHAR2
440  	 DETERMINISTIC
441  	 PARALLEL_ENABLE
442    IS
443    BEGIN
444  	 RETURN sosl_util.txt_boolean((p_bool = 1), p_true, p_false);
445    EXCEPTION
446  	 WHEN OTHERS THEN
447  	   sosl_log.exception_log('sosl_util.txt_boolean NUMBER', 'SOSL_UTIL', SQLERRM);
448  	   RETURN sosl_constants.GEN_NA_TYPE;
449    END txt_boolean; -- number input
450  
451    FUNCTION yes_no( p_bool	 IN BOOLEAN
452  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
453  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
454  		      )
455  	 RETURN VARCHAR2
456  	 DETERMINISTIC
457  	 PARALLEL_ENABLE
458    IS
459    BEGIN
460  	 RETURN sosl_util.txt_boolean(p_bool, p_true, p_false);
461    EXCEPTION
462  	 WHEN OTHERS THEN
463  	   sosl_log.exception_log('sosl_util.yes_no BOOLEAN', 'SOSL_UTIL', SQLERRM);
464  	   RETURN sosl_constants.GEN_NA_TYPE;
465    END yes_no;
466  
467    FUNCTION yes_no( p_bool	 IN NUMBER
468  		      , p_true	 IN VARCHAR2 DEFAULT 'YES'
469  		      , p_false  IN VARCHAR2 DEFAULT 'NO'
470  		      )
471  	 RETURN VARCHAR2
472  	 DETERMINISTIC
473  	 PARALLEL_ENABLE
474    IS
475    BEGIN
476  	 RETURN sosl_util.txt_boolean((p_bool = 1), p_true, p_false);
477    EXCEPTION
478  	 WHEN OTHERS THEN
479  	   sosl_log.exception_log('sosl_util.yes_no NUMBER', 'SOSL_UTIL', SQLERRM);
480  	   RETURN sosl_constants.GEN_NA_TYPE;
481    END yes_no;
482  
483    FUNCTION object_date( p_object_name IN VARCHAR2
484  			   , p_object_type IN VARCHAR2
485  			   )
486  	 RETURN DATE
487    IS
488  	 l_has_object  NUMBER;
489  	 l_return      DATE;
490    BEGIN
491  	 l_return := sosl_constants.GEN_NA_DATE_TYPE;
492  	 SELECT COUNT(*)
493  	   INTO l_has_object
494  	   FROM user_objects
495  	  WHERE object_name = TRIM(UPPER(p_object_name))
496  	    AND object_type = TRIM(UPPER(p_object_type))
497  	 ;
498  	 -- only if we have exactly one object
499  	 IF l_has_object = 1
500  	 THEN
501  	   SELECT last_ddl_time
502  	     INTO l_return
503  	     FROM user_objects
504  	    WHERE object_name = TRIM(UPPER(p_object_name))
505  	      AND object_type = TRIM(UPPER(p_object_type))
506  	   ;
507  	 END IF;
508  	 RETURN l_return;
509    EXCEPTION
510  	 WHEN OTHERS THEN
511  	   sosl_log.exception_log('sosl_util.object_date', 'SOSL_UTIL', SQLERRM);
512  	   RETURN sosl_constants.GEN_NA_DATE_TYPE;
513    END object_date;
514  
515    FUNCTION get_valid_run_state(p_run_state IN NUMBER)
516  	 RETURN NUMBER
517    IS
518    BEGIN
519  	 IF p_run_state IN ( sosl_constants.RUN_STATE_WAITING
520  			   , sosl_constants.RUN_STATE_ENQUEUED
521  			   , sosl_constants.RUN_STATE_STARTED
522  			   , sosl_constants.RUN_STATE_RUNNING
523  			   , sosl_constants.RUN_STATE_FINISHED
524  			   , sosl_constants.RUN_STATE_ERROR
525  			   )
526  	 THEN
527  	   RETURN p_run_state;
528  	 ELSE
529  	   sosl_log.minimal_error_log('sosl_util.get_valid_run_state', 'SOSL_UTIL', 'Run state ' || p_run_state || ' not supported.');
530  	   RETURN sosl_constants.RUN_STATE_ERROR;
531  	 END IF;
532    EXCEPTION
533  	 WHEN OTHERS THEN
534  	   sosl_log.exception_log('sosl_util.get_valid_run_state', 'SOSL_UTIL', SQLERRM);
535  	   RETURN -1;
536    END get_valid_run_state;
537  
538  END;
539  /

Package body created.

SQL> -- packages depending on SOSL objects
SQL> @@../sosl_ddl/packages/sosl_sys.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- main package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl_sys
  2  AS
  3  
  4    /* FUNCTION SOSL_SYS.GET_VALID_EXECUTOR_CNT
  5    * Determines the count of all valid executors. A valid executor is defined as an executor that is
  6    * marked as active and reviewed.
  7    *
  8    * @return The total count of all valid executors or -1 on errors.
  9    */
 10    FUNCTION get_valid_executor_cnt
 11  	 RETURN NUMBER
 12    ;
 13  
 14    /* FUNCTION SOSL_SYS.GET_WAITING_CNT
 15    * Determines the count of all scripts in the run queue with status WAITING.
 16    *
 17    * @return The count of all waiting scripts in the run queue or -1 on errors.
 18    */
 19    FUNCTION get_waiting_cnt
 20  	 RETURN NUMBER
 21    ;
 22  
 23    /* FUNCTION SOSL_SYS.GET_WAITING_CNT
 24    * Determines the count of all scripts of an executor in the run queue with status WAITING.
 25    *
 26    * @param p_executor_id The executor id to get all scripts in the run queue with status WAITING.
 27    *
 28    * @return The count of all waiting scripts in the run queue or -1 on errors.
 29    */
 30    FUNCTION get_waiting_cnt(p_executor_id IN NUMBER)
 31  	 RETURN NUMBER
 32    ;
 33  
 34    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_HAS_SCRIPTS
 35    * Deactivates all executors using the given function owner and function for has_scripts.
 36    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 37    * that throw exceptions or errors on calling them. Errors will be logged.
 38    *
 39    * @param p_function_owner The owner of the has_scripts function definition.
 40    * @param p_fn_has_scripts The defined script call for has_scripts.
 41    * @param p_log_reason A detailed reason why executor has be deactivated.
 42    *
 43    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 44    */
 45    FUNCTION deactivate_by_fn_has_scripts( p_function_owner IN VARCHAR2
 46  					    , p_fn_has_scripts IN VARCHAR2
 47  					    , p_log_reason     IN VARCHAR2
 48  					    )
 49  	 RETURN BOOLEAN
 50    ;
 51  
 52    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_GET_NEXT_SCRIPT
 53    * Deactivates all executors using the given function owner and function for get_next_script.
 54    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 55    * that throw exceptions or errors on calling them. Errors will be logged.
 56    *
 57    * @param p_function_owner The owner of the get_next_script function definition.
 58    * @param p_fn_get_next_script The defined script call for get_next_script.
 59    * @param p_log_reason A detailed reason why executor has be deactivated.
 60    *
 61    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 62    */
 63    FUNCTION deactivate_by_fn_get_next_script( p_function_owner     IN VARCHAR2
 64  						, p_fn_get_next_script IN VARCHAR2
 65  						, p_log_reason	       IN VARCHAR2
 66  						)
 67  	 RETURN BOOLEAN
 68    ;
 69  
 70    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_SET_SCRIPT_STATUS
 71    * Deactivates all executors using the given function owner and function for set_script_status.
 72    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 73    * that throw exceptions or errors on calling them. Errors will be logged.
 74    *
 75    * @param p_function_owner The owner of the set_script_status function definition.
 76    * @param p_fn_set_script_status The defined script call for set_script_status.
 77    * @param p_log_reason A detailed reason why executor has be deactivated.
 78    *
 79    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 80    */
 81    FUNCTION deactivate_by_fn_set_script_status( p_function_owner	   IN VARCHAR2
 82  						  , p_fn_set_script_status IN VARCHAR2
 83  						  , p_log_reason	   IN VARCHAR2
 84  						  )
 85  	 RETURN BOOLEAN
 86    ;
 87  
 88    /* FUNCTION SOSL_SYS.DEACTIVATE_BY_FN_SEND_DB_MAIL
 89    * Deactivates all executors using the given function owner and function for send_db_mail.
 90    * Runs as an autonomous transaction. Used to deactivate executors having functions configured
 91    * that throw exceptions or errors on calling them. Errors will be logged.
 92    *
 93    * @param p_function_owner The owner of the send_db_mail function definition.
 94    * @param p_fn_send_db_mail The defined script call for send_db_mail.
 95    * @param p_log_reason A detailed reason why executor has be deactivated.
 96    *
 97    * @return TRUE if successful executed, FALSE on internal exceptions not handled.
 98    */
 99    FUNCTION deactivate_by_fn_send_db_mail( p_function_owner  IN VARCHAR2
100  					     , p_fn_send_db_mail IN VARCHAR2
101  					     , p_log_reason	 IN VARCHAR2
102  					     )
103  	 RETURN BOOLEAN
104    ;
105  
106    /* FUNCTION SOSL_SYS.BUILD_SCRIPT_CALL
107    * Builds a SELECT FROM dual statement with the given function name and,
108    * if NOT NULL, function owner that can be executed dynamically. The return values and
109    * types are not checked and must be handled by the caller. By SOSL default the function
110    * owner is set and NOT NULL. Anyway this functions handles also NULL on function owner.
111    *
112    * WORKS ONLY FOR FUNCTION WITHOUT PARAMETER, e.g. has_scripts and get_next_script.
113    *
114    * BE AWARE that oracle cannot distinguish between package functions where the package is named
115    * like the schema, if names are equal, e.g. if a package exists, called SOSL, like the schema SOSL,
116    * Oracle would search with SOSL.myfunction not a function in the SOSL schema, it would search
117    * myfunction in the package SOSL if executed dynamically.
118    *
119    * @param p_function_owner If set, the function owner of the function. Will prefix the call.
120    * @param p_function_name The name of the function or package function.
121    *
122    * @return A statement to retrieve the function call e.g. SELECT owner.function FROM dual.
123    */
124    FUNCTION build_script_call( p_function_owner  IN VARCHAR2
125  				 , p_function_name   IN VARCHAR2
126  				 )
127  	 RETURN VARCHAR2
128    ;
129  
130    /* FUNCTION SOSL_SYS.BUILD_SIGNAL_CALL
131    * Builds a SELECT FROM dual statement with the given function name and, if NOT NULL, function owner that can be
132    * executed dynamically and the given parameter. The return values and
133    * types are not checked and must be handled by the caller. By SOSL default the function
134    * owner is set and NOT NULL. Anyway this functions handles also NULL on function owner.
135    *
136    * WORKS ONLY FOR FUNCTION WITH DEFINED PARAMETER, e.g. set_script_status and send_db_mail.
137    *
138    * BE AWARE that oracle cannot distinguish between package functions where the package is named
139    * like the schema, if names are equal, e.g. if a package exists, called SOSL, like the schema SOSL,
140    * Oracle would search with SOSL.myfunction not a function in the SOSL schema, it would search
141    * myfunction in the package SOSL if executed dynamically.
142    *
143    * @param p_function_owner If set, the function owner of the function. Will prefix the call.
144    * @param p_function_name The name of the function or package function.
145    * @param p_run_id The first function parameter representing the run id.
146    * @param p_status The second function parameter representing the status that should be set.
147    *
148    * @return A statement to retrieve the function call e.g. SELECT owner.function(1, 0) FROM dual.
149    */
150    FUNCTION build_signal_call( p_function_owner  IN VARCHAR2
151  				 , p_function_name   IN VARCHAR2
152  				 , p_run_id	     IN NUMBER
153  				 , p_status	     IN NUMBER
154  				 )
155  	 RETURN VARCHAR2
156    ;
157  
158    /* FUNCTION SOSL_SYS.GET_HAS_SCRIPT_CNT
159    * Determines the count result of all defined has_script functions of valid executors.
160    * Failures on specific executors are only considered, if none of the defined functions
161    * could be executed without errors. Defined scripts will be executed dynamically. Make
162    * sure that has_scripts execute fast, especially if more than one executor is active.
163    *
164    * Will only execute unique functions. If different executors share the same function owner
165    * and function definition, then the function is only executed once and not per executor.
166    * Call syntax is functionOwner.functionName where functionName can also be a package call.
167    *
168    * ATTENTION Will all executors with scripts throwing execptions!
169    *
170    * @return The total count of all defined has_scripts function or -1 on severe errors.
171    */
172    FUNCTION get_has_script_cnt
173  	 RETURN NUMBER
174    ;
175  
176    /* FUNCTION SOSL_SYS.IS_EXECUTOR_VALID
177    * Checks if the given executor id is valid in sense of active and reviewed. Errors will be logged.
178    *
179    * @param p_executor_id The id of the executor to check if the executor is active and reviewed.
180    *
181    * @return If executor exists, is reviewed and active, returns TRUE otherwise FALSE, also in case of errors.
182    */
183    FUNCTION is_executor_valid(p_executor_id IN NUMBER)
184  	 RETURN BOOLEAN
185    ;
186  
187    /* FUNCTION SOSL_SYS.IS_EXECUTOR
188    * Checks if the given executor id exists in SOSL_EXECUTOR_DEFINITION. Errors will be logged.
189    *
190    * @param p_executor_id The id of the executor to check.
191    *
192    * @return If executor exists returns TRUE otherwise FALSE, also in case of errors.
193    */
194    FUNCTION is_executor(p_executor_id IN NUMBER)
195  	 RETURN BOOLEAN
196    ;
197  
198    /**
199    * This package contains the main functions and procedures used by the Simple Oracle Script Loader to handle executors and scripts.
200    * It is not allowed to use this package for function assignments in SOSL_EXECUTOR_DEFINITION.
201    */
202  
203    /*FUNCTION SOSL_SYS.HAS_VALID_EXECUTORS
204    * Checks if any valid executor (active and reviewed) exists. Errors get logged, return on error is FALSE.
205    *
206    * @return Return TRUE if at least one active and reviewed executor exists, otherwise FALSE.
207    */
208    FUNCTION has_valid_executors
209  	 RETURN BOOLEAN
210    ;
211  
212    /* FUNCTION SOSL_SYS.HAS_SCRIPTS
213    * This function will be used by the wrapper function SOSL_SERVER.HAS_SCRIPTS.
214    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
215    * return a number greater or equal to 0 as well as messages waiting in SOSL_RUN_QUEUE to be processed. Errors will get logged.
216    *
217    * @return The total amount of scripts waiting for processing or -1 on unhandled exceptions/all functions have errors.
218    */
219    FUNCTION has_scripts
220  	 RETURN NUMBER
221    ;
222  
223    /* FUNCTION SOSL_SYS.HAS_RUN_ID
224    * Checks if a given run id exists. Errors get logged.
225    *
226    * @param p_run_id The run id to verify.
227    *
228    * @return TRUE if run id exists otherwise FALSE.
229    */
230    FUNCTION has_run_id(p_run_id IN NUMBER)
231  	 RETURN BOOLEAN
232    ;
233  
234    /* FUNCTION SOSL_SYS.GET_RUN_STATE
235    * Return the current run state for a given run id. Errors get logged.
236    *
237    * @param p_run_id The run id to get the run state for.
238    *
239    * @return On success the current run state or -1 on errors.
240    */
241    FUNCTION get_run_state(p_run_id IN NUMBER)
242  	 RETURN NUMBER
243    ;
244  
245    /* FUNCTION SOSL_SYS.GET_PAYLOAD
246    * Builds a SOSL_PAYLOAD object from the given run id.
247    *
248    * @param p_run_id The run id to get the SOSL_PAYLOAD object for.
249    *
250    * @return On success a valid SOSL_PAYLOAD object or NULL on errors.
251    */
252    FUNCTION get_payload(p_run_id IN NUMBER)
253  	 RETURN SOSL_PAYLOAD
254    ;
255  
256    /* FUNCTION SOSL_SYS.SIGNAL_STATUS_CHANGE
257    * Uses the defined executor from given run id to execute the defined interface function for set_script_status.
258    * The given run id must be valid, as well as the defined function for set_script_status. Otherwise the executor is deactivated.
259    * If mail is activated, will also call the mail functions, errors on mail are logged and ignored (will not lead to FALSE return value).
260    *
261    * @param p_run_id The valid run id to signal state changes.
262    * @param p_status A valid run state.
263    *
264    * @return TRUE if run state successfully signalled otherwise FALSE.
265    */
266    FUNCTION signal_status_change( p_run_id IN NUMBER
267  				    , p_status IN NUMBER
268  				    )
269  	 RETURN BOOLEAN
270    ;
271  
272    /* FUNCTION SOSL_SYS.SET_RUN_STATE
273    * Sets the given run state in SOSL_RUN_QUEUE.
274    *
275    * Run states must follow the state hierarchy: WAITING, ENQUEUED, STARTED, RUNNING, FINISHED. Every state allows to set the
276    * state to ERROR or to the following state. Wrong state hierarchy will lead to run state ERROR. If state is equal to current
277    * state, no change will take place.
278    *
279    * @param p_run_id The valid run id to update.
280    * @param p_status A valid run state.
281    *
282    * @return TRUE if run state successfully updated otherwise FALSE.
283    */
284    FUNCTION set_run_state( p_run_id IN NUMBER
285  			     , p_status IN NUMBER
286  			     )
287  	 RETURN BOOLEAN
288    ;
289  
290    /* FUNCTION SOSL_SYS.SET_SCRIPT_STATUS
291    * This function will be used by wrapper functions in SOSL_SERVER package. It will first set the status of the script
292    * associated to the given run id in SOSL_RUN_QUEUE and then signal the state to all defined set_script_status functions.
293    * Invalid status will lead to run state ERROR used. Errors will get logged. Invalid functions will deactivate the related
294    * executors. If at least one status could be set successfully, it will return success (0).
295    *
296    * Run states must follow the state hierarchy: WAITING, ENQUEUED, STARTED, RUNNING, FINISHED. Every state allows to set the
297    * state to ERROR or to the following state. Wrong state hierarchy will lead to run state ERROR. If state is equal to current
298    * state, no change will take place.
299    *
300    * @param p_run_id The valid run id of the script that should change run state.
301    * @param p_status A valid status as defined in SOSL_CONSTANTS for run states.
302    *
303    * @return Return 0 if successful executed otherwise -1.
304    */
305    FUNCTION set_script_status( p_run_id IN NUMBER
306  				 , p_status IN NUMBER
307  				 )
308  	 RETURN NUMBER
309    ;
310  
311    /* FUNCTION SOSL_SYS.REGISTER_NEXT_SCRIPT
312    * Fetches the PAYLOAD from a given configured function for SOSL_SERVER.GET_NEXT_SCRIPT and stores it in SOSL_RUN_QUEUE with the
313    * status WAITING. On errors, if sufficient data are available, the next script information is stored with status ERROR.
314    * All executors using a function with errors will get deactivated.
315    *
316    * @param p_function_name The function to execute for getting the payload. Package functions allowed.
317    * @param p_function_owner The function owner of the function to execute.
318    *
319    * @return TRUE if fetch was successful, otherwise FALSE.
320    */
321    FUNCTION register_next_script( p_function_name  IN VARCHAR2
322  				    , p_function_owner IN VARCHAR2
323  				    )
324  	 RETURN BOOLEAN
325    ;
326  
327    /* FUNCTION SOSL_SYS.REGISTER_WAITING
328    * Registers all waiting scripts available by defined GET_NEXT_SCRIPT function and persisting them in SOSL_RUN_QUEUE.
329    * State may be WAITING or ERROR, if errors occured and SOSL_PAYLOAD has usable values. Errors get logged.
330    *
331    * @return TRUE if successfully registered any waiting script, otherwise FALSE.
332    */
333    FUNCTION register_waiting
334  	 RETURN BOOLEAN
335    ;
336  
337    /* FUNCTION SOSL_SYS.FETCH_NEXT_RUN_ID
338    * Gets the next available RUN_ID from scripts with status WAITING in SOSL_RUN_QUEUE. Mainly sorted by create date but on
339    * similar create date randomly.
340    *
341    * @return The RUN_ID of the next script to execute or -1 on errors.
342    */
343    FUNCTION fetch_next_run_id
344  	 RETURN NUMBER
345    ;
346  
347    /* FUNCTION SOSL_SYS.GET_NEXT_SCRIPT
348    * This function will be used by the wrapper function SOSL_SERVER.GET_NEXT_SCRIPT.
349    * It collects from all executors the next script to execute, queues them in SOSL_RUN_QUEUE and then fetches the first script in the
350    * run queue as next script to execute. If no scripts are available or on errors, the function will return -1.
351    * Errors will be logged. From interface functions it excepts the return type SOSL_PAYLOAD.
352    *
353    * @return The next script reference as RUN_ID from SOSL_RUN_QUEUE, containing run id that can be related to executor, external script id and scriptfile.
354    */
355    FUNCTION get_next_script
356  	 RETURN NUMBER
357    ;
358  
359  END;
360  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_sys.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_sys
  2  AS
  3    -- for description see header file
  4    FUNCTION get_valid_executor_cnt
  5  	 RETURN NUMBER
  6    IS
  7  	 l_return NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*)
 10  	   INTO l_return
 11  	   FROM sosl_executor_definition
 12  	  WHERE executor_active   = sosl_constants.NUM_YES
 13  	    AND executor_reviewed = sosl_constants.NUM_YES
 14  	 ;
 15  	 RETURN l_return;
 16    EXCEPTION
 17  	 WHEN OTHERS THEN
 18  	   -- log the error instead of RAISE
 19  	   sosl_log.exception_log('sosl_sys.get_valid_executor_cnt', 'SOSL_SYS', SQLERRM);
 20  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 21  	   RETURN -1;
 22    END get_valid_executor_cnt;
 23  
 24    FUNCTION get_waiting_cnt
 25  	 RETURN NUMBER
 26    IS
 27  	 l_return NUMBER;
 28    BEGIN
 29  	 SELECT COUNT(*)
 30  	   INTO l_return
 31  	   FROM sosl_run_queue
 32  	  WHERE run_state = sosl_constants.RUN_STATE_WAITING
 33  	 ;
 34  	 RETURN l_return;
 35    EXCEPTION
 36  	 WHEN OTHERS THEN
 37  	   -- log the error instead of RAISE
 38  	   sosl_log.exception_log('sosl_sys.get_waiting_cnt', 'SOSL_SYS', SQLERRM);
 39  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 40  	   RETURN -1;
 41    END get_waiting_cnt;
 42  
 43    FUNCTION get_waiting_cnt(p_executor_id IN NUMBER)
 44  	 RETURN NUMBER
 45    IS
 46  	 l_return NUMBER;
 47    BEGIN
 48  	 SELECT COUNT(*)
 49  	   INTO l_return
 50  	   FROM sosl_run_queue
 51  	  WHERE run_state   = sosl_constants.RUN_STATE_WAITING
 52  	    AND executor_id = p_executor_id
 53  	 ;
 54  	 RETURN l_return;
 55    EXCEPTION
 56  	 WHEN OTHERS THEN
 57  	   -- log the error instead of RAISE
 58  	   sosl_log.exception_log('sosl_sys.get_waiting_cnt executor', 'SOSL_SYS', SQLERRM);
 59  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 60  	   RETURN -1;
 61    END get_waiting_cnt;
 62  
 63    FUNCTION deactivate_by_fn_has_scripts( p_function_owner IN VARCHAR2
 64  					    , p_fn_has_scripts IN VARCHAR2
 65  					    , p_log_reason     IN VARCHAR2
 66  					    )
 67  	 RETURN BOOLEAN
 68    IS
 69  	 PRAGMA AUTONOMOUS_TRANSACTION;
 70  	 l_return	     BOOLEAN;
 71  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
 72  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_has_scripts';
 73  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
 74  			      , cp_function_name  IN VARCHAR2
 75  			      )
 76  	 IS
 77  	   SELECT executor_id
 78  		, function_owner
 79  	     FROM sosl_executor_definition
 80  	    WHERE function_owner = cp_function_owner
 81  	      AND fn_has_scripts = cp_function_name
 82  	 ;
 83    BEGIN
 84  	 l_return := TRUE;
 85  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
 86  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_has_scripts)
 87  	 LOOP
 88  	   -- disable executor
 89  	   UPDATE sosl_executor_definition
 90  	      SET executor_active    = sosl_constants.NUM_NO
 91  		, executor_reviewed  = sosl_constants.NUM_NO
 92  	    WHERE executor_id = rec.executor_id
 93  	   ;
 94  	   COMMIT;
 95  	   -- revoke grants for function owner
 96  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
 97  	   THEN
 98  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
 99  	     -- if one fails, it all is in error
100  	     l_return := FALSE;
101  	   END IF;
102  	 END LOOP;
103  	 RETURN l_return;
104    EXCEPTION
105  	 WHEN OTHERS THEN
106  	   -- log the error instead of RAISE
107  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
108  	   RETURN FALSE;
109    END deactivate_by_fn_has_scripts;
110  
111    FUNCTION deactivate_by_fn_get_next_script( p_function_owner     IN VARCHAR2
112  						, p_fn_get_next_script IN VARCHAR2
113  						, p_log_reason	       IN VARCHAR2
114  						)
115  	 RETURN BOOLEAN
116    IS
117  	 PRAGMA AUTONOMOUS_TRANSACTION;
118  	 l_return	     BOOLEAN;
119  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
120  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_get_next_script';
121  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
122  			      , cp_function_name  IN VARCHAR2
123  			      )
124  	 IS
125  	   SELECT executor_id
126  		, function_owner
127  	     FROM sosl_executor_definition
128  	    WHERE function_owner     = cp_function_owner
129  	      AND fn_get_next_script = cp_function_name
130  	 ;
131    BEGIN
132  	 l_return := TRUE;
133  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
134  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_get_next_script)
135  	 LOOP
136  	   -- disable executor
137  	   UPDATE sosl_executor_definition
138  	      SET executor_active    = sosl_constants.NUM_NO
139  		, executor_reviewed  = sosl_constants.NUM_NO
140  	    WHERE executor_id = rec.executor_id
141  	   ;
142  	   COMMIT;
143  	   -- revoke grants for function owner
144  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
145  	   THEN
146  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
147  	     -- if one fails, it all is in error
148  	     l_return := FALSE;
149  	   END IF;
150  	 END LOOP;
151  	 RETURN l_return;
152    EXCEPTION
153  	 WHEN OTHERS THEN
154  	   -- log the error instead of RAISE
155  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
156  	   RETURN FALSE;
157    END deactivate_by_fn_get_next_script;
158  
159    FUNCTION deactivate_by_fn_set_script_status( p_function_owner	   IN VARCHAR2
160  						  , p_fn_set_script_status IN VARCHAR2
161  						  , p_log_reason	   IN VARCHAR2
162  						  )
163  	 RETURN BOOLEAN
164    IS
165  	 PRAGMA AUTONOMOUS_TRANSACTION;
166  	 l_return	     BOOLEAN;
167  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
168  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_set_script_status';
169  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
170  			      , cp_function_name  IN VARCHAR2
171  			      )
172  	 IS
173  	   SELECT executor_id
174  		, function_owner
175  	     FROM sosl_executor_definition
176  	    WHERE function_owner       = cp_function_owner
177  	      AND fn_set_script_status = cp_function_name
178  	 ;
179    BEGIN
180  	 l_return := TRUE;
181  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
182  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_set_script_status)
183  	 LOOP
184  	   -- disable executor
185  	   UPDATE sosl_executor_definition
186  	      SET executor_active    = sosl_constants.NUM_NO
187  		, executor_reviewed  = sosl_constants.NUM_NO
188  	    WHERE executor_id = rec.executor_id
189  	   ;
190  	   COMMIT;
191  	   -- revoke grants for function owner
192  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
193  	   THEN
194  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
195  	     -- if one fails, it all is in error
196  	     l_return := FALSE;
197  	   END IF;
198  	 END LOOP;
199  	 RETURN l_return;
200    EXCEPTION
201  	 WHEN OTHERS THEN
202  	   -- log the error instead of RAISE
203  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
204  	   RETURN FALSE;
205    END deactivate_by_fn_set_script_status;
206  
207    FUNCTION deactivate_by_fn_send_db_mail( p_function_owner  IN VARCHAR2
208  					     , p_fn_send_db_mail IN VARCHAR2
209  					     , p_log_reason	 IN VARCHAR2
210  					     )
211  	 RETURN BOOLEAN
212    IS
213  	 PRAGMA AUTONOMOUS_TRANSACTION;
214  	 l_return	     BOOLEAN;
215  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
216  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.deactivate_by_fn_send_db_mail';
217  	 CURSOR cur_deactivate( cp_function_owner IN VARCHAR2
218  			      , cp_function_name  IN VARCHAR2
219  			      )
220  	 IS
221  	   SELECT executor_id
222  		, function_owner
223  	     FROM sosl_executor_definition
224  	    WHERE function_owner  = cp_function_owner
225  	      AND fn_send_db_mail = cp_function_name
226  	 ;
227    BEGIN
228  	 l_return := TRUE;
229  	 sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, p_log_reason);
230  	 FOR rec IN cur_deactivate(p_function_owner, p_fn_send_db_mail)
231  	 LOOP
232  	   -- disable executor
233  	   UPDATE sosl_executor_definition
234  	      SET executor_active    = sosl_constants.NUM_NO
235  		, executor_reviewed  = sosl_constants.NUM_NO
236  	    WHERE executor_id = rec.executor_id
237  	   ;
238  	   COMMIT;
239  	   -- revoke grants for function owner
240  	   IF NOT sosl_util.revoke_role(rec.function_owner, 'SOSL_EXECUTOR')
241  	   THEN
242  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to revoke grant SOSL_EXECUTOR from ' || rec.function_owner);
243  	     -- if one fails, it all is in error
244  	     l_return := FALSE;
245  	   END IF;
246  	 END LOOP;
247  	 RETURN l_return;
248    EXCEPTION
249  	 WHEN OTHERS THEN
250  	   -- log the error instead of RAISE
251  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
252  	   RETURN FALSE;
253    END deactivate_by_fn_send_db_mail;
254  
255    FUNCTION build_script_call( p_function_owner  IN VARCHAR2
256  				 , p_function_name   IN VARCHAR2
257  				 )
258  	 RETURN VARCHAR2
259    IS
260  	 l_statement VARCHAR2(1024);
261    BEGIN
262  	 IF p_function_owner IS NOT NULL
263  	 THEN
264  	   l_statement := 'SELECT ' || p_function_owner || '.' || p_function_name || ' FROM dual';
265  	 ELSE
266  	   l_statement := 'SELECT ' || p_function_name || ' FROM dual';
267  	 END IF;
268  	 RETURN l_statement;
269    EXCEPTION
270  	 WHEN OTHERS THEN
271  	   -- log the error instead of RAISE
272  	   sosl_log.exception_log('sosl_sys.build_script_call', 'SOSL_SYS', SQLERRM);
273  	   RETURN 'SELECT -1 FROM dual';
274    END build_script_call;
275  
276    FUNCTION build_signal_call( p_function_owner  IN VARCHAR2
277  				 , p_function_name   IN VARCHAR2
278  				 , p_run_id	     IN NUMBER
279  				 , p_status	     IN NUMBER
280  				 )
281  	 RETURN VARCHAR2
282    IS
283  	 l_statement VARCHAR2(4000);
284    BEGIN
285  	 IF p_function_owner IS NOT NULL
286  	 THEN
287  	   l_statement := 'SELECT ' || p_function_owner || '.' || p_function_name || '(' ||
288  			  TRIM(TO_CHAR(p_run_id)) || ', ' || TRIM(TO_CHAR(p_status)) || ')' ||
289  			  ' FROM dual'
290  	   ;
291  	 ELSE
292  	   l_statement := 'SELECT ' || p_function_name || '(' ||
293  			  TRIM(TO_CHAR(p_run_id)) || ', ' || TRIM(TO_CHAR(p_status)) || ')' ||
294  			  ' FROM dual';
295  	 END IF;
296  	 RETURN l_statement;
297    EXCEPTION
298  	 WHEN OTHERS THEN
299  	   -- log the error instead of RAISE
300  	   sosl_log.exception_log('sosl_sys.build_signal_call', 'SOSL_SYS', SQLERRM);
301  	   RETURN 'SELECT -1 FROM dual';
302    END build_signal_call;
303  
304  
305    FUNCTION get_has_script_cnt
306  	 RETURN NUMBER
307    IS
308  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
309  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_has_script_cnt';
310  	 l_total	     NUMBER;
311  	 l_count	     NUMBER;
312  	 l_success	     BOOLEAN;
313  	 l_statement	     VARCHAR2(1024);
314  	 CURSOR cur_fn_has_scripts
315  	 IS
316  	   SELECT function_owner
317  		, fn_has_scripts
318  	     FROM sosl_executor_definition
319  	    WHERE executor_active   = sosl_constants.NUM_YES
320  	      AND executor_reviewed = sosl_constants.NUM_YES
321  	    GROUP BY function_owner
322  		   , fn_has_scripts
323  	 ;
324    BEGIN
325  	 -- flag to determine if at least one execution was successful
326  	 l_success := FALSE;
327  	 l_total   := 0;
328  	 l_count   := 0;
329  	 -- loop through functions
330  	 FOR rec IN cur_fn_has_scripts
331  	 LOOP
332  	   l_statement := sosl_sys.build_script_call(rec.function_owner, rec.fn_has_scripts);
333  	   BEGIN
334  	     EXECUTE IMMEDIATE l_statement INTO l_count;
335  	   EXCEPTION
336  	     WHEN OTHERS THEN
337  	       sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
338  	       l_count := -1;
339  	   END;
340  	   IF l_count < 0
341  	   THEN
342  	     -- we have errors with this function disable executors using this function
343  	     IF NOT sosl_sys.deactivate_by_fn_has_scripts(rec.function_owner, rec.fn_has_scripts, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
344  	     THEN
345  	       -- error situation
346  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || rec.fn_has_scripts || ' function owner ' || rec.function_owner);
347  	     END IF;
348  	   ELSE
349  	     l_success := TRUE;
350  	     l_total   := l_total + l_count;
351  	   END IF;
352  	 END LOOP;
353  	 -- now check if we have at least one function executed with success
354  	 IF NOT l_success
355  	 THEN
356  	   -- we should report the error situation
357  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'No defined has_scripts function is working. Disabled executors.');
358  	   l_total := -1;
359  	 END IF;
360  	 RETURN l_total;
361    EXCEPTION
362  	 WHEN OTHERS THEN
363  	   -- log the error instead of RAISE
364  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
365  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
366  	   RETURN -1;
367    END get_has_script_cnt;
368  
369    FUNCTION is_executor_valid(p_executor_id IN NUMBER)
370  	 RETURN BOOLEAN
371    IS
372  	 l_valid_count NUMBER;
373  	 l_return      BOOLEAN;
374    BEGIN
375  	 l_return := FALSE;
376  	 SELECT COUNT(*)
377  	   INTO l_valid_count
378  	   FROM sosl_executor_definition
379  	  WHERE executor_id	   = p_executor_id
380  	    AND executor_active    = sosl_constants.NUM_YES
381  	    AND executor_reviewed  = sosl_constants.NUM_YES
382  	 ;
383  	 l_return := (l_valid_count != 0);
384  	 RETURN l_return;
385    EXCEPTION
386  	 WHEN OTHERS THEN
387  	   sosl_log.exception_log('sosl_sys.is_executor_valid', 'SOSL_SYS', SQLERRM);
388  	   RETURN FALSE;
389    END is_executor_valid;
390  
391    FUNCTION is_executor(p_executor_id IN NUMBER)
392  	 RETURN BOOLEAN
393    IS
394  	 l_valid_count NUMBER;
395  	 l_return      BOOLEAN;
396    BEGIN
397  	 l_return := FALSE;
398  	 SELECT COUNT(*)
399  	   INTO l_valid_count
400  	   FROM sosl_executor_definition
401  	  WHERE executor_id	   = p_executor_id
402  	 ;
403  	 l_return := (l_valid_count != 0);
404  	 RETURN l_return;
405    EXCEPTION
406  	 WHEN OTHERS THEN
407  	   sosl_log.exception_log('sosl_sys.is_executor', 'SOSL_SYS', SQLERRM);
408  	   RETURN FALSE;
409    END is_executor;
410  
411    FUNCTION has_valid_executors
412  	 RETURN BOOLEAN
413    IS
414  	 l_return	     BOOLEAN;
415  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
416  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.has_valid_executors';
417    BEGIN
418  	 l_return := (sosl_sys.get_valid_executor_cnt > 0);
419  	 RETURN l_return;
420    EXCEPTION
421  	 WHEN OTHERS THEN
422  	   -- log the error instead of RAISE
423  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
424  	   RETURN FALSE;
425    END has_valid_executors;
426  
427    FUNCTION has_scripts
428  	 RETURN NUMBER
429    IS
430  	 l_return	     NUMBER;
431  	 l_waiting	     NUMBER;
432  	 l_defined	     NUMBER;
433  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
434  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.has_scripts';
435    BEGIN
436  	 l_return      := -1;
437  	 IF sosl_sys.has_valid_executors
438  	 THEN
439  	   -- initialize the total count
440  	   l_return := 0;
441  	   -- get count of waiting scripts
442  	   l_waiting := sosl_sys.get_waiting_cnt;
443  	   l_defined := sosl_sys.get_has_script_cnt;
444  	   IF	   l_waiting >= 0
445  	      AND  l_defined >= 0
446  	   THEN
447  	     -- build total
448  	     l_return := l_waiting + l_defined;
449  	   ELSE
450  	     -- report error
451  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Defined functions or run queue in error. Fix problems before expecting valid results');
452  	     l_return := -1;
453  	   END IF;
454  	 ELSE
455  	   -- log no valid executors
456  	   sosl_log.minimal_warning_log(l_self_caller, l_self_log_category, 'Nothing to do, no valid executors. Return 0 scripts available');
457  	   l_return := 0;
458  	 END IF;
459  	 RETURN l_return;
460    EXCEPTION
461  	 WHEN OTHERS THEN
462  	   -- log the error instead of RAISE
463  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
464  	   RETURN -1;
465    END has_scripts;
466  
467    FUNCTION has_run_id(p_run_id IN NUMBER)
468  	 RETURN BOOLEAN
469    IS
470  	 l_return  BOOLEAN;
471  	 l_count   NUMBER;
472    BEGIN
473  	 l_return := FALSE;
474  	 SELECT COUNT(*)
475  	   INTO l_count
476  	   FROM sosl_run_queue
477  	  WHERE run_id = p_run_id
478  	 ;
479  	 l_return := (l_count = 1);
480  	 RETURN l_return;
481    EXCEPTION
482  	 WHEN OTHERS THEN
483  	   -- log the error instead of RAISE
484  	   sosl_log.exception_log('sosl_sys.has_run_id', 'SOSL_SYS', SQLERRM);
485  	   RETURN FALSE;
486    END has_run_id;
487  
488    FUNCTION get_run_state(p_run_id IN NUMBER)
489  	 RETURN NUMBER
490    IS
491  	 l_run_state NUMBER;
492    BEGIN
493  	 IF sosl_sys.has_run_id(p_run_id)
494  	 THEN
495  	   SELECT run_state
496  	     INTO l_run_state
497  	     FROM sosl_run_queue
498  	    WHERE run_id = p_run_id
499  	   ;
500  	 ELSE
501  	   l_run_state := sosl_constants.RUN_STATE_ERROR;
502  	 END IF;
503  	 RETURN l_run_state;
504    EXCEPTION
505  	 WHEN OTHERS THEN
506  	   -- log the error instead of RAISE
507  	   sosl_log.exception_log('sosl_sys.get_run_state', 'SOSL_SYS', SQLERRM);
508  	   RETURN -1;
509    END get_run_state;
510  
511    FUNCTION get_payload(p_run_id IN NUMBER)
512  	 RETURN SOSL_PAYLOAD
513    IS
514  	 l_payload	     SOSL_PAYLOAD;
515  	 l_executor_id	     sosl_run_queue.executor_id%TYPE;
516  	 l_ext_script_id     sosl_run_queue.ext_script_id%TYPE;
517  	 l_script_file	     sosl_run_queue.script_file%TYPE;
518  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
519  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_payload';
520    BEGIN
521  	 l_payload := NULL;
522  	 IF sosl_sys.has_run_id(p_run_id)
523  	 THEN
524  	   SELECT executor_id
525  		, ext_script_id
526  		, script_file
527  	     INTO l_executor_id
528  		, l_ext_script_id
529  		, l_script_file
530  	     FROM sosl_run_queue
531  	    WHERE run_id = p_run_id
532  	   ;
533  	   l_payload := SOSL_PAYLOAD(l_executor_id, l_ext_script_id, l_script_file);
534  	 ELSE
535  	   l_payload := NULL;
536  	   -- log error
537  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid run id ' || p_run_id);
538  	 END IF;
539  	 RETURN l_payload;
540    EXCEPTION
541  	 WHEN OTHERS THEN
542  	   -- log the error instead of RAISE
543  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
544  	   RETURN NULL;
545    END get_payload;
546  
547    FUNCTION signal_status_change( p_run_id IN NUMBER
548  				    , p_status IN NUMBER
549  				    )
550  	 RETURN BOOLEAN
551    IS
552  	 l_return		 BOOLEAN;
553  	 l_num_result		 NUMBER;
554  	 l_function_owner	 sosl_executor_definition.function_owner%TYPE;
555  	 l_fn_set_script_status  sosl_executor_definition.fn_set_script_status%TYPE;
556  	 l_fn_send_db_mail	 sosl_executor_definition.fn_send_db_mail%TYPE;
557  	 l_use_mail		 sosl_executor_definition.use_mail%TYPE;
558  	 l_statement		 VARCHAR2(4000);
559  	 l_self_log_category	 sosl_server_log.log_category%TYPE := 'SOSL_SYS';
560  	 l_self_caller		 sosl_server_log.caller%TYPE	   := 'sosl_sys.signal_status_change';
561    BEGIN
562  	 l_return := FALSE;
563  	 IF sosl_sys.has_run_id(p_run_id)
564  	 THEN
565  	   -- get the defined function to signal the status change
566  	   SELECT sed.function_owner
567  		, sed.fn_set_script_status
568  		, sed.fn_send_db_mail
569  		, sed.use_mail
570  	     INTO l_function_owner
571  		, l_fn_set_script_status
572  		, l_fn_send_db_mail
573  		, l_use_mail
574  	     FROM sosl_run_queue srqu
575  	    INNER JOIN sosl_executor_definition sed
576  	       ON srqu.executor_id = sed.executor_id
577  	    WHERE srqu.run_id = p_run_id
578  	   ;
579  	   l_statement := sosl_sys.build_signal_call(l_function_owner, l_fn_set_script_status, p_run_id, p_status);
580  	   BEGIN
581  	     EXECUTE IMMEDIATE l_statement INTO l_num_result;
582  	     IF l_num_result = sosl_constants.NUM_SUCCESS
583  	     THEN
584  	       l_return := TRUE;
585  	     END IF;
586  	   EXCEPTION
587  	     WHEN OTHERS THEN
588  	       sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
589  	   END;
590  	   IF l_return
591  	   THEN
592  	     -- if mail activated execute also the defined mail function
593  	     IF l_use_mail = sosl_constants.NUM_YES
594  	     THEN
595  	       l_statement := sosl_sys.build_signal_call(l_function_owner, l_fn_send_db_mail, p_run_id, p_status);
596  	       BEGIN
597  		 EXECUTE IMMEDIATE l_statement INTO l_num_result;
598  	       EXCEPTION
599  		 WHEN OTHERS THEN
600  		   sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
601  		   l_num_result := sosl_constants.NUM_ERROR;
602  	       END;
603  	       IF l_num_result = sosl_constants.NUM_ERROR
604  	       THEN
605  		 IF NOT sosl_sys.deactivate_by_fn_send_db_mail(l_function_owner, l_fn_send_db_mail, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
606  		 THEN
607  		   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || l_fn_send_db_mail || ' function owner ' || l_function_owner);
608  		 END IF;
609  	       END IF;
610  	     END IF;
611  	   ELSE
612  	     -- deactivate executors using the set_script_status function
613  	     IF NOT sosl_sys.deactivate_by_fn_set_script_status(l_function_owner, l_fn_set_script_status, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
614  	     THEN
615  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || l_fn_set_script_status || ' function owner ' || l_function_owner);
616  	     END IF;
617  	   END IF;
618  	 END IF;
619  	 RETURN l_return;
620    EXCEPTION
621  	 WHEN OTHERS THEN
622  	   -- log the error instead of RAISE
623  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
624  	   RETURN FALSE;
625    END signal_status_change;
626  
627    FUNCTION set_run_state( p_run_id IN NUMBER
628  			     , p_status IN NUMBER
629  			     )
630  	 RETURN BOOLEAN
631    IS
632  	 PRAGMA AUTONOMOUS_TRANSACTION;
633  	 l_return	     BOOLEAN;
634  	 l_run_state	     INTEGER;
635  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
636  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.set_script_status';
637    BEGIN
638  	 l_return := FALSE;
639  	 l_run_state := sosl_util.get_valid_run_state(p_status);
640  	 IF sosl_sys.has_run_id(p_run_id)
641  	 THEN
642  	   UPDATE sosl_run_queue
643  	      SET run_state = l_run_state
644  	    WHERE run_id = p_run_id
645  	   ;
646  	   COMMIT;
647  	   -- check that state was set successfully
648  	   l_return := (l_run_state = sosl_sys.get_run_state(p_run_id));
649  	 END IF;
650  	 RETURN l_return;
651    EXCEPTION
652  	 WHEN OTHERS THEN
653  	   -- log the error instead of RAISE
654  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
655  	   RETURN FALSE;
656    END set_run_state;
657  
658    FUNCTION set_script_status( p_run_id IN NUMBER
659  				 , p_status IN NUMBER
660  				 )
661  	 RETURN NUMBER
662    IS
663  	 l_return	     NUMBER;
664  	 l_run_state	     INTEGER;
665  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
666  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.set_script_status';
667    BEGIN
668  	 l_return := -1;
669  	 -- check status
670  	 l_run_state := sosl_util.get_valid_run_state(p_status);
671  	 -- check run id
672  	 IF sosl_sys.has_run_id(p_run_id)
673  	 THEN
674  	   -- first set own status, then signal changes
675  	   IF	  sosl_sys.set_run_state(p_run_id, p_status)
676  	      AND sosl_sys.signal_status_change(p_run_id, p_status)
677  	   THEN
678  	     l_return := 0;
679  	   ELSE
680  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not set the run state to ' || p_status || ' for run id ' || p_run_id);
681  	   END IF;
682  	 END IF;
683  	 RETURN l_return;
684    EXCEPTION
685  	 WHEN OTHERS THEN
686  	   -- log the error instead of RAISE
687  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
688  	   RETURN -1;
689    END set_script_status;
690  
691    FUNCTION register_next_script( p_function_name  IN VARCHAR2
692  				    , p_function_owner IN VARCHAR2
693  				    )
694  	 RETURN BOOLEAN
695    IS
696  	 PRAGMA AUTONOMOUS_TRANSACTION;
697  	 l_return	     BOOLEAN;
698  	 l_payload	     SOSL_PAYLOAD;
699  	 l_statement	     VARCHAR2(1024);
700  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
701  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.register_next_script';
702    BEGIN
703  	 l_return := FALSE;
704  	 l_statement := sosl_sys.build_script_call(p_function_owner, p_function_name);
705  	 BEGIN
706  	   EXECUTE IMMEDIATE l_statement INTO l_payload;
707  	   IF	   sosl_sys.is_executor_valid(l_payload.executor_id)
708  	      AND  l_payload.ext_script_id IS NOT NULL
709  	      AND  l_payload.script_file   IS NOT NULL
710  	   THEN
711  	     -- valid payload
712  	     INSERT INTO sosl_run_queue
713  	       (executor_id, ext_script_id, script_file)
714  	       VALUES
715  	       (l_payload.executor_id, l_payload.ext_script_id, l_payload.script_file)
716  	     ;
717  	     COMMIT;
718  	     l_return := TRUE;
719  	   ELSE
720  	     -- invalid payload, check if usable and save with error state if possible
721  	     IF     sosl_sys.is_executor(l_payload.executor_id)
722  		AND l_payload.ext_script_id IS NOT NULL
723  		AND l_payload.script_file   IS NOT NULL
724  	     THEN
725  	       -- insert the record with error state
726  	       INSERT INTO sosl_run_queue
727  		 (executor_id, ext_script_id, script_file, run_state)
728  		 VALUES
729  		 (l_payload.executor_id, l_payload.ext_script_id, l_payload.script_file, sosl_constants.RUN_STATE_ERROR)
730  	       ;
731  	       COMMIT;
732  	     END IF;
733  	     -- log the error
734  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'SOSL_PAYLOAD has invalid content, either the executor "' || l_payload.executor_id || '" is not valid or payload fields are NULL. External script id "' || l_payload.ext_script_id || '" script file "' || l_payload.script_file || '".');
735  	     l_return := FALSE;
736  	   END IF;
737  	 EXCEPTION
738  	   WHEN OTHERS THEN
739  	     sosl_log.exception_log(l_self_caller, l_self_log_category, l_statement || ': ' || SQLERRM);
740  	     l_return := FALSE;
741  	 END;
742  	 -- if we have still FALSE return value, deactivate the executors for the given function
743  	 IF NOT l_return
744  	 THEN
745  	   IF NOT sosl_sys.deactivate_by_fn_get_next_script(p_function_owner, p_function_name, 'Function returns exceptions or values below zero. Executors deactivated. Fix function issue before.')
746  	   THEN
747  	     -- log error
748  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not deactivate executors for function ' || p_function_name || ' function owner ' || p_function_owner);
749  	   END IF;
750  	 END IF;
751  	 RETURN l_return;
752    EXCEPTION
753  	 WHEN OTHERS THEN
754  	   -- log the error instead of RAISE
755  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
756  	   RETURN FALSE;
757    END register_next_script;
758  
759    FUNCTION register_waiting
760  	 RETURN BOOLEAN
761    IS
762  	 l_return	     BOOLEAN;
763  	 l_success	     BOOLEAN;
764  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
765  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.register_waiting';
766  	 CURSOR cur_fn_get_next_script
767  	 IS
768  	   SELECT function_owner
769  		, fn_get_next_script
770  	     FROM sosl_executor_definition
771  	    WHERE executor_active   = sosl_constants.NUM_YES
772  	      AND executor_reviewed = sosl_constants.NUM_YES
773  	    GROUP BY function_owner
774  		   , fn_get_next_script
775  	 ;
776    BEGIN
777  	 l_return  := FALSE;
778  	 l_success := FALSE;
779  	 FOR rec IN cur_fn_get_next_script
780  	 LOOP
781  	   IF sosl_sys.register_next_script(rec.fn_get_next_script, rec.function_owner)
782  	   THEN
783  	     l_success := TRUE;
784  	   END IF;
785  	 END LOOP;
786  	 -- if at least one script was registered successfully, errors may be seen in the logs of register_next_script
787  	 IF l_success
788  	 THEN
789  	   l_return := TRUE;
790  	 ELSE
791  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Error fetching get_next_script functions. No defined function works correctly.');
792  	   l_return := FALSE;
793  	 END IF;
794  	 RETURN l_return;
795    EXCEPTION
796  	 WHEN OTHERS THEN
797  	   -- log the error instead of RAISE
798  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
799  	   RETURN FALSE;
800    END register_waiting;
801  
802    FUNCTION fetch_next_run_id
803  	 RETURN NUMBER
804    IS
805  	 l_run_id	     NUMBER;
806  	 l_count	     NUMBER;
807  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
808  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.fetch_next_run_id';
809  	 -- get waiting run id, oldest first
810  	 CURSOR cur_run_id
811  	 IS
812  	   SELECT run_id
813  	     FROM sosl_run_queue
814  	    WHERE run_state = sosl_constants.RUN_STATE_WAITING
815  	    ORDER BY created
816  	 ;
817    BEGIN
818  	 l_run_id := -1;
819  	 SELECT COUNT(*) INTO l_count FROM sosl_run_queue WHERE run_state = sosl_constants.RUN_STATE_WAITING;
820  	 IF l_count > 0
821  	 THEN
822  	   OPEN cur_run_id;
823  	   FETCH cur_run_id INTO l_run_id;
824  	   CLOSE cur_run_id;
825  	 END IF;
826  	 RETURN l_run_id;
827    EXCEPTION
828  	 WHEN OTHERS THEN
829  	   -- log the error instead of RAISE
830  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
831  	   RETURN -1;
832    END fetch_next_run_id;
833  
834    FUNCTION get_next_script
835  	 RETURN NUMBER
836    IS
837  	 l_run_id	     NUMBER;
838  	 l_state_result      NUMBER;
839  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SYS';
840  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_sys.get_next_script';
841    BEGIN
842  	 l_run_id := -1;
843  	 -- if we have scripts
844  	 IF sosl_sys.has_scripts > 0
845  	 THEN
846  	   -- select all valid executors and get their results, store results in SOSL_RUN_QUEUE.
847  	   IF NOT sosl_sys.register_waiting
848  	   THEN
849  	     -- probably an error with defined functions, log the error
850  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Defined functions in error, not registered any new script.');
851  	   END IF;
852  	   -- as we should have scripts, the run queue still may have scripts even if register failed
853  	   l_run_id := sosl_sys.fetch_next_run_id;
854  	   IF l_run_id = sosl_constants.NUM_ERROR
855  	   THEN
856  	     -- log the error
857  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Unable to fetch next run id.');
858  	   ELSE
859  	     -- mark run id as enqueued
860  	     l_state_result := sosl_sys.set_script_status(l_run_id, sosl_constants.RUN_STATE_ENQUEUED);
861  	     IF l_state_result = sosl_constants.NUM_ERROR
862  	     THEN
863  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Could not update run state to ENQUEUED for run id: ' || l_run_id);
864  	     END IF;
865  	   END IF;
866  	 END IF;
867  	 RETURN l_run_id;
868    EXCEPTION
869  	 WHEN OTHERS THEN
870  	   -- log the error instead of RAISE
871  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
872  	   RETURN -1;
873    END get_next_script;
874  
875  END;
876  /

Package body created.

SQL> @@../sosl_ddl/packages/sosl_server.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- server interface package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl_server
  2  AS
  3    /**
  4    * This package contains the server interface used by the Simple Oracle Script Loader.
  5    * All server scripts depend on this package. The default error return value is -1, either
  6    * as number or as string. The SOSL server can only deal with this two types of return
  7    * values: NUMBER or VARCHAR2. And it can only deal with functions usable in a SELECT statement.
  8    * All interpreted values are read in as COLUMN variables, it makes no difference, if -1 or '-1'
  9    * is delivered as error code.
 10    */
 11  
 12    /*====================================== start internal functions made visible for testing ======================================*/
 13    -- SOSL server will not call this functions directly, so return type can be different from NUMBER or VARCHAR2
 14  
 15    /* FUNCTION SOSL_SERVER.HAS_CONFIG_NAME
 16    * Checks if a given case sensitive configuration name exists. Errors get logged.
 17    *
 18    * @param p_config_name The config name of the configuration item.
 19    *
 20    * @return Either TRUE if the configuration name exists or FALSE, including FALSE on error.
 21    */
 22    FUNCTION has_config_name(p_config_name IN VARCHAR2)
 23  	 RETURN BOOLEAN
 24    ;
 25    /* FUNCTION SOSL_SERVER.SET_GUID
 26    * Sets the GUID of the SOSL server, used during script execution, in SOSL_RUN_QUEUE. The GUID will be
 27    * a generic identifier for this script execution. All identifiers in SOSLERRLOG will start with this GUID
 28    * for a specific script execution.
 29    *
 30    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
 31    * @param p_guid The GUID used by the SOSL server for this script execution.
 32    *
 33    * @return Exit code, either 0 = successful or -1 on error.
 34    */
 35    FUNCTION set_guid( p_run_id IN NUMBER
 36  			, p_guid   IN VARCHAR2
 37  			)
 38  	 RETURN NUMBER
 39    ;
 40    /* FUNCTION SOSL_SERVER.SET_IDENTIFIER
 41    * Sets the exact SOSL IDENTIFIER of the SOSL server, used during main script execution, in SOSL_RUN_QUEUE. The identifier
 42    * will exactly match SOSLERRLOG.IDENTIFIER in case of errors for a specific script execution. It will start with the GUID
 43    * for the whole script execution process.
 44    *
 45    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
 46    * @param p_identifier The exact identifier used by the SOSL server for the main part of the script execution.
 47    *
 48    * @return Exit code, either 0 = successful or -1 on error.
 49    */
 50    FUNCTION set_identifier( p_run_id     IN NUMBER
 51  			      , p_identifier IN VARCHAR2
 52  			      )
 53  	 RETURN NUMBER
 54    ;
 55    /*====================================== end internal functions made visible for testing ======================================*/
 56  
 57    /** Function SOSL_SERVER.SET_CONFIG
 58    * Sets an existing configuration value for a given and existing case sensitive configuration name. Invalid
 59    * config names get logged. Invalid config values for SOSL_RUNMODE and SOSL_SERVER_STATE are ignored and will
 60    * not change the config value. Errors get logged.
 61    * SOSL_RUNMODE values: RUN, WAIT, STOP
 62    * SOSL_SERVER_STATE values: ACTIVE, INACTIVE, PAUSE
 63    *
 64    * @param p_config_name The valid config name of the configuration item.
 65    * @param p_config_value The value to assign to the configuration item.
 66    *
 67    * @return Exit code, either 0 = successful or -1 on error.
 68    */
 69    FUNCTION set_config( p_config_name  IN VARCHAR2
 70  			  , p_config_value IN VARCHAR2
 71  			  )
 72  	 RETURN NUMBER
 73    ;
 74  
 75    /** Function SOSL_SERVER.GET_CONFIG
 76    * Gets an existing configuration value for a given and existing case sensitive configuration name. Errors get logged.
 77    *
 78    * @param p_config_name The config name of the configuration item.
 79    *
 80    * @return The configured value as VARCHAR2 or '-1' string on error.
 81    */
 82    FUNCTION get_config(p_config_name IN VARCHAR2)
 83  	 RETURN VARCHAR2
 84    ;
 85  
 86    /* FUNCTION SOSL_SERVER.SET_SERVER_STATE
 87    * A shortcut function using sosl_server.set_config for SOSL_SERVER_STATE. Errors get logged.
 88    *
 89    * @param p_server_state A valid server state: ACTIVE, INACTIVE, PAUSE.
 90    *
 91    * @return Exit code, either 0 = successful or -1 on error.
 92    */
 93    FUNCTION set_server_state(p_server_state IN VARCHAR2)
 94  	 RETURN NUMBER
 95    ;
 96  
 97  
 98    /* FUNCTION SOSL_SERVER.SET_RUNMODE
 99    * A shortcut function using sosl_server.set_config for SOSL_RUNMODE. Errors get logged.
100    *
101    * @param p_server_state A valid run mode: RUN, WAIT, STOP.
102    *
103    * @return Exit code, either 0 = successful or -1 on error.
104    */
105    FUNCTION set_runmode(p_runmode IN VARCHAR2)
106  	 RETURN NUMBER
107    ;
108  
109    /* FUNCTION SOSL_SERVER.GET_EXECUTOR_CFG
110    * Retrieves the config login file to use for a specific executor by a given run id. Errors get logged.
111    *
112    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
113    *
114    * @return The configuration login filename including relative/absolute path or '-1' on errors.
115    */
116    FUNCTION get_executor_cfg(p_run_id IN NUMBER)
117  	 RETURN VARCHAR2
118    ;
119  
120    /* FUNCTION SOSL_SERVER.GET_SCRIPT_FILE
121    * Retrieves the script filename including relative or full path by a given run id. Errors get logged.
122    *
123    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
124    *
125    * @return The script filename including relative/absolute path or '-1' on errors.
126    */
127    FUNCTION get_script_file(p_run_id IN NUMBER)
128  	 RETURN VARCHAR2
129    ;
130  
131    /* FUNCTION SOSL_SERVER.GET_SCRIPT_SCHEMA
132    * Retrieves the schema a given script should run in by a given run id. Uses FUNCTION_OWNER as defined
133    * for the executor of this script. Errors get logged.
134    *
135    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
136    *
137    * @return The schema to use for the script associated with the run id or the current schema of this package as fallback on errors.
138    */
139    FUNCTION get_script_schema(p_run_id IN NUMBER)
140  	 RETURN VARCHAR2
141    ;
142  
143    /* FUNCTION SOSL_SERVER.GET_SOSL_SCHEMA
144    * Retrieves the current SOSL schema from table SOSL_CONFIG. Used for prefixing SOSL packages and functions when executing
145    * scripts for an executor. Errors get logged. Fix any issue on SOSL schema before running the server component locally.
146    *
147    * @return The SOSL schema as defined on installation. On errors will return PUBLIC, so any package prefixed with this virtual schema will fail.
148    */
149    FUNCTION get_sosl_schema
150  	 RETURN VARCHAR2
151    ;
152  
153    /* FUNCTION SOSL_SERVER.SET_SCRIPT_STARTED
154    * Short cut function for sosl_sys.set_run_state to guarantee correct run states. On errors the script state will
155    * be set to error. Before calling this function at least GUID should be set for the current script.
156    * Wrapper function for SOSL_SYS.SET_SCRIPT_STATUS.
157    *
158    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
159    *
160    * @return Exit code, either 0 = successful or -1 on error.
161    */
162    FUNCTION set_script_started(p_run_id IN NUMBER)
163  	 RETURN NUMBER
164    ;
165  
166    /* FUNCTION SOSL_SERVER.SET_SCRIPT_RUNNING
167    * Short cut function for sosl_sys.set_run_state to guarantee correct run states. On errors the script state will
168    * be set to error. Before calling this function the exact SOSL identifier should be set for the current script.
169    * Wrapper function for SOSL_SYS.SET_SCRIPT_STATUS.
170    *
171    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
172    *
173    * @return Exit code, either 0 = successful or -1 on error.
174    */
175    FUNCTION set_script_running(p_run_id IN NUMBER)
176  	 RETURN NUMBER
177    ;
178  
179    /* FUNCTION SOSL_SERVER.SET_SCRIPT_FINISHED
180    * Short cut function for sosl_sys.set_run_state to guarantee correct run states. On errors the script state will
181    * be set to error. Wrapper function for SOSL_SYS.SET_SCRIPT_STATUS.
182    *
183    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
184    *
185    * @return Exit code, either 0 = successful or -1 on error.
186    */
187    FUNCTION set_script_finished(p_run_id IN NUMBER)
188  	 RETURN NUMBER
189    ;
190  
191    /* FUNCTION SOSL_SERVER.SET_SCRIPT_RUNNING
192    * Short cut function for sosl_sys.set_run_state to guarantee correct run states. On errors the script state will
193    * be set to error. Before calling this function the GUID and exact SOSL identifier should be set for the current script.
194    * Wrapper function for SOSL_SYS.SET_SCRIPT_STATUS.
195    *
196    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
197    *
198    * @return Exit code, either 0 = successful or -1 on error.
199    */
200    FUNCTION set_script_error(p_run_id IN NUMBER)
201  	 RETURN NUMBER
202    ;
203  
204    /* FUNCTION SOSL_SERVER.INFO_LOG
205    * Provides a possibility to output content for a local log as well as logging it to SOSL_SERVER_LOG. Can be
206    * be called within every SELECT statement. On success log category will always be SOSL_SERVER, log type INFO.
207    *
208    * @param p_srv_caller The script calling this function.
209    * @param p_srv_message The message to use for the local log as well as to the SOSL_SERVER_LOG.
210    * @param p_identifier In almost all cases scripts called from the server have an identifier, that they use for SOSLERRORLOG. NULL by default.
211    * @param p_local_log In almost all cases scripts called from the server have a log file, that they use. NULL by default.
212    * @param p_srv_run_id Scripts issued by executors will have a run id which is retrieved from the SOSL server. If a run id is given, the log is also enhanced with executor details for this script. NULL by default.
213    * @param p_srv_guid For cases scripts called from the server have also the GUID, that they use. NULL by default.
214    *
215    * @return Will return p_message or error information.
216    */
217    FUNCTION info_log( p_srv_caller	 IN VARCHAR2
218  			, p_srv_message  IN VARCHAR2
219  			, p_identifier	 IN VARCHAR2 DEFAULT NULL
220  			, p_local_log	 IN VARCHAR2 DEFAULT NULL
221  			, p_srv_run_id	 IN NUMBER   DEFAULT NULL
222  			, p_srv_guid	 IN VARCHAR2 DEFAULT NULL
223  			)
224  	 RETURN VARCHAR2
225    ;
226  
227    /* FUNCTION SOSL_SERVER.WARNING_LOG
228    * Provides a possibility to output content for a local log as well as logging it to SOSL_SERVER_LOG. Can be
229    * be called within every SELECT statement. On success log category will always be SOSL_SERVER, log type WARNING.
230    *
231    * @param p_srv_caller The script calling this function.
232    * @param p_srv_message The message to use for the local log as well as to the SOSL_SERVER_LOG.
233    * @param p_identifier In almost all cases scripts called from the server have an identifier, that they use for SOSLERRORLOG. NULL by default.
234    * @param p_local_log In almost all cases scripts called from the server have a log file, that they use. NULL by default.
235    * @param p_srv_run_id Scripts issued by executors will have a run id which is retrieved from the SOSL server. If a run id is given, the log is also enhanced with executor details for this script. NULL by default.
236    * @param p_srv_guid For cases scripts called from the server have also the GUID, that they use. NULL by default.
237    *
238    * @return Will return p_message or error information.
239    */
240    FUNCTION warning_log( p_srv_caller   IN VARCHAR2
241  			   , p_srv_message  IN VARCHAR2
242  			   , p_identifier   IN VARCHAR2 DEFAULT NULL
243  			   , p_local_log    IN VARCHAR2 DEFAULT NULL
244  			   , p_srv_run_id   IN NUMBER	DEFAULT NULL
245  			   , p_srv_guid     IN VARCHAR2 DEFAULT NULL
246  			   )
247  	 RETURN VARCHAR2
248    ;
249  
250    /* FUNCTION SOSL_SERVER.ERROR_LOG
251    * Provides a possibility to output content for a local log as well as logging it to SOSL_SERVER_LOG. Can be
252    * be called within every SELECT statement. On success log category will always be SOSL_SERVER, log type ERROR.
253    *
254    * @param p_srv_caller The script calling this function.
255    * @param p_srv_message The message to use for the local log as well as to the SOSL_SERVER_LOG.
256    * @param p_identifier In almost all cases scripts called from the server have an identifier, that they use for SOSLERRORLOG. NULL by default.
257    * @param p_local_log In almost all cases scripts called from the server have a log file, that they use. NULL by default.
258    * @param p_srv_run_id Scripts issued by executors will have a run id which is retrieved from the SOSL server. If a run id is given, the log is also enhanced with executor details for this script. NULL by default.
259    * @param p_srv_guid For cases scripts called from the server have also the GUID, that they use. NULL by default.
260    *
261    * @return Will return p_message or error information.
262    */
263    FUNCTION error_log( p_srv_caller   IN VARCHAR2
264  			 , p_srv_message  IN VARCHAR2
265  			 , p_identifier   IN VARCHAR2 DEFAULT NULL
266  			 , p_local_log	  IN VARCHAR2 DEFAULT NULL
267  			 , p_srv_run_id   IN NUMBER   DEFAULT NULL
268  			 , p_srv_guid	  IN VARCHAR2 DEFAULT NULL
269  			 )
270  	 RETURN VARCHAR2
271    ;
272  
273    /* FUNCTION SOSL_SERVER.HAS_SCRIPTS
274    * Wrapper function for SOSL_SYS.HAS_SCRIPTS.
275    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
276    * return a number greater or equal to 0 as well as messages waiting in SOSL_RUN_QUEUE to be processed. Errors will get logged.
277    *
278    * @return The total amount of scripts waiting for processing or -1 on unhandled exceptions/all functions have errors.
279    */
280    FUNCTION has_scripts
281  	 RETURN NUMBER
282    ;
283  
284    /* FUNCTION SOSL_SERVER.GET_NEXT_SCRIPT
285    * Wrapper function for SOSL_SYS.GET_NEXT_SCRIPT.
286    * It collects from all executors the next script to execute, queues them in SOSL_RUN_QUEUE and then fetches the first script in the
287    * run queue as next script to execute. If no scripts are available or on errors, the function will return -1.
288    * Errors will be logged. From interface functions it excepts the return type SOSL_PAYLOAD.
289    *
290    * @return The next script reference as RUN_ID from SOSL_RUN_QUEUE, containing run id that can be related to executor, external script id and scriptfile.
291    */
292    FUNCTION get_next_script
293  	 RETURN NUMBER
294    ;
295  
296    /* FUNCTION SOSL_SERVER.UPDATE_RUN_ID
297    * Updates the run id with details from the server. Errors get logged.
298    *
299    * @param p_run_id A valid run id for table SOSL_RUN_QUEUE.
300    * @param p_identifier The exact identifier used by the SOSL server for the main part of the script execution.
301    * @param p_guid The (optional) GUID used by the SOSL server for this script execution.
302    *
303    * @return Exit code, either 0 = successful or -1 on error.
304    */
305    FUNCTION update_run_id( p_run_id      IN NUMBER
306  			     , p_identifier  IN VARCHAR2
307  			     , p_guid	     IN VARCHAR2 DEFAULT NULL
308  			     )
309  	 RETURN NUMBER
310    ;
311  
312  END;
313  /

Package created.

SQL> -- grants
SQL> GRANT EXECUTE ON sosl_server TO sosl_executor;

Grant succeeded.

SQL> @@../sosl_ddl/packages/sosl_server.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_server
  2  AS
  3    -- for description see header file
  4    /*====================================== start internal functions made visible for testing ======================================*/
  5    FUNCTION has_config_name(p_config_name IN VARCHAR2)
  6  	 RETURN BOOLEAN
  7    IS
  8  	 l_return	     BOOLEAN;
  9  	 l_count	     NUMBER;
 10  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
 11  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.has_config_name';
 12    BEGIN
 13  	 SELECT COUNT(*)
 14  	   INTO l_count
 15  	   FROM sosl_config
 16  	  WHERE config_name = p_config_name
 17  	 ;
 18  	 l_return := (l_count = 1);
 19  	 RETURN l_return;
 20    EXCEPTION
 21  	 WHEN OTHERS THEN
 22  	   -- log the error instead of RAISE
 23  	   sosl_log.exception_log('sosl_server.has_config_name', 'SOSL_SERVER', SQLERRM);
 24  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 25  	   RETURN FALSE;
 26    END has_config_name;
 27  
 28  
 29    FUNCTION set_guid( p_run_id IN NUMBER
 30  			, p_guid   IN VARCHAR2
 31  			)
 32  	 RETURN NUMBER
 33    IS
 34  	 PRAGMA AUTONOMOUS_TRANSACTION;
 35  	 l_return	     NUMBER;
 36  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
 37  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.set_guid';
 38    BEGIN
 39  	 l_return := -1;
 40  	 IF sosl_sys.has_run_id(p_run_id)
 41  	 THEN
 42  	   UPDATE sosl_run_queue
 43  	      SET script_guid = p_guid
 44  	    WHERE run_id = p_run_id
 45  	   ;
 46  	   COMMIT;
 47  	   l_return := 0;
 48  	 ELSE
 49  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
 50  	   l_return := -1;
 51  	 END IF;
 52  	 RETURN l_return;
 53    EXCEPTION
 54  	 WHEN OTHERS THEN
 55  	   -- log the error instead of RAISE
 56  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 57  	   RETURN -1;
 58    END set_guid;
 59  
 60    FUNCTION set_identifier( p_run_id     IN NUMBER
 61  			      , p_identifier IN VARCHAR2
 62  			      )
 63  	 RETURN NUMBER
 64    IS
 65  	 PRAGMA AUTONOMOUS_TRANSACTION;
 66  	 l_return	     NUMBER;
 67  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
 68  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.set_identifier';
 69    BEGIN
 70  	 l_return := -1;
 71  	 IF sosl_sys.has_run_id(p_run_id)
 72  	 THEN
 73  	   UPDATE sosl_run_queue
 74  	      SET sosl_identifier = p_identifier
 75  	    WHERE run_id = p_run_id
 76  	   ;
 77  	   COMMIT;
 78  	   l_return := 0;
 79  	 ELSE
 80  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
 81  	   l_return := -1;
 82  	 END IF;
 83  	 RETURN l_return;
 84    EXCEPTION
 85  	 WHEN OTHERS THEN
 86  	   -- log the error instead of RAISE
 87  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 88  	   RETURN -1;
 89    END set_identifier;
 90    /*====================================== end internal functions made visible for testing ======================================*/
 91  
 92    FUNCTION set_config( p_config_name  IN VARCHAR2
 93  			  , p_config_value IN VARCHAR2
 94  			  )
 95  	 RETURN NUMBER
 96    IS
 97  	 PRAGMA AUTONOMOUS_TRANSACTION;
 98  	 l_return	     NUMBER;
 99  	 l_set_value	     BOOLEAN;
100  	 l_config_value      sosl_config.config_value%TYPE;
101  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
102  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.set_config';
103    BEGIN
104  	 l_return := -1;
105  	 IF sosl_server.has_config_name(p_config_name)
106  	 THEN
107  	   l_set_value	  := TRUE;
108  	   l_config_value := TRIM(p_config_value);
109  	   -- do some extra checks on config name SOSL_RUNMODE and SOSL_SERVER_STATE
110  	   IF p_config_name IN ('SOSL_RUNMODE', 'SOSL_SERVER_STATE')
111  	   THEN
112  	     -- make commands uppercase
113  	     l_config_value := UPPER(l_config_value);
114  	     IF     p_config_name      = 'SOSL_RUNMODE'
115  		AND l_config_value NOT IN ('RUN', 'WAIT', 'STOP')
116  	     THEN
117  	       -- log the error and do not change the config value
118  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid run mode: ' || l_config_value || '. Configuration not changed');
119  	       l_set_value := FALSE;
120  	     END IF;
121  	     IF      p_config_name = 'SOSL_SERVER_STATE'
122  		AND  l_config_value NOT IN ('ACTIVE', 'INACTIVE', 'PAUSE')
123  	     THEN
124  	       -- log the error and do not change the config value
125  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Invalid server state: ' || l_config_value || '. Configuration not changed');
126  	       l_set_value := FALSE;
127  	     END IF;
128  	   END IF;
129  	   IF l_set_value
130  	   THEN
131  	     UPDATE sosl_config
132  		SET config_value = p_config_value
133  	      WHERE config_name = p_config_name
134  	     ;
135  	     COMMIT;
136  	     l_return := 0;
137  	   END IF;
138  	 ELSE
139  	   -- log error wrong config name
140  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested config name "' || p_config_name || '" does not exist.');
141  	 END IF;
142  	 RETURN l_return;
143    EXCEPTION
144  	 WHEN OTHERS THEN
145  	   -- log the error instead of RAISE
146  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
147  	   RETURN -1;
148    END set_config;
149  
150    FUNCTION get_config(p_config_name IN VARCHAR2)
151  	 RETURN VARCHAR2
152    IS
153  	 l_config_value      sosl_config.config_value%TYPE;
154  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
155  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.get_config';
156    BEGIN
157  	 l_config_value := '-1';
158  	 IF sosl_server.has_config_name(p_config_name)
159  	 THEN
160  	   SELECT config_value
161  	     INTO l_config_value
162  	     FROM sosl_config
163  	    WHERE config_name = p_config_name
164  	   ;
165  	 ELSE
166  	   -- log error wrong config name
167  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested config name "' || p_config_name || '" does not exist.');
168  	   l_config_value := '-1';
169  	 END IF;
170  	 RETURN l_config_value;
171    EXCEPTION
172  	 WHEN OTHERS THEN
173  	   -- log the error instead of RAISE
174  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
175  	   RETURN '-1';
176    END get_config;
177  
178    FUNCTION set_server_state(p_server_state IN VARCHAR2)
179  	 RETURN NUMBER
180    IS
181  	 l_return  NUMBER;
182    BEGIN
183  	 l_return := sosl_server.set_config('SOSL_SERVER_STATE', p_server_state);
184  	 RETURN l_return;
185    EXCEPTION
186  	 WHEN OTHERS THEN
187  	   -- log the error instead of RAISE
188  	   sosl_log.exception_log('sosl_server.set_server_state', 'SOSL_SERVER', SQLERRM);
189  	   RETURN -1;
190    END set_server_state;
191  
192    FUNCTION set_runmode(p_runmode IN VARCHAR2)
193  	 RETURN NUMBER
194    IS
195  	 l_return  NUMBER;
196    BEGIN
197  	 l_return := sosl_server.set_config('SOSL_RUNMODE', p_runmode);
198  	 RETURN l_return;
199    EXCEPTION
200  	 WHEN OTHERS THEN
201  	   -- log the error instead of RAISE
202  	   sosl_log.exception_log('sosl_server.set_runmode', 'SOSL_SERVER', SQLERRM);
203  	   RETURN -1;
204    END set_runmode;
205  
206    FUNCTION get_executor_cfg(p_run_id IN NUMBER)
207  	 RETURN VARCHAR2
208    IS
209  	 l_executor_cfg      sosl_executor_definition.cfg_file%TYPE;
210  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
211  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.get_executor_cfg';
212    BEGIN
213  	 l_executor_cfg := '-1';
214  	 IF sosl_sys.has_run_id(p_run_id)
215  	 THEN
216  	   SELECT sed.cfg_file
217  	     INTO l_executor_cfg
218  	     FROM sosl_run_queue srq
219  	     LEFT OUTER JOIN sosl_executor_definition sed
220  	       ON srq.executor_id = sed.executor_id
221  	    WHERE srq.run_id = p_run_id
222  	   ;
223  	 ELSE
224  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
225  	   l_executor_cfg := '-1';
226  	 END IF;
227  	 RETURN l_executor_cfg;
228    EXCEPTION
229  	 WHEN OTHERS THEN
230  	   -- log the error instead of RAISE
231  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
232  	   RETURN '-1';
233    END get_executor_cfg;
234  
235    FUNCTION get_script_file(p_run_id IN NUMBER)
236  	 RETURN VARCHAR2
237    IS
238  	 l_script_file	     sosl_run_queue.script_file%TYPE;
239  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
240  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.get_script_file';
241    BEGIN
242  	 l_script_file := '-1';
243  	 IF sosl_sys.has_run_id(p_run_id)
244  	 THEN
245  	   SELECT script_file
246  	     INTO l_script_file
247  	     FROM sosl_run_queue
248  	    WHERE run_id = p_run_id
249  	   ;
250  	 ELSE
251  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
252  	   l_script_file := '-1';
253  	 END IF;
254  	 RETURN l_script_file;
255    EXCEPTION
256  	 WHEN OTHERS THEN
257  	   -- log the error instead of RAISE
258  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
259  	   RETURN '-1';
260    END get_script_file;
261  
262    FUNCTION get_script_schema(p_run_id IN NUMBER)
263  	 RETURN VARCHAR2
264    IS
265  	 l_script_schema     sosl_executor_definition.function_owner%TYPE;
266  	 l_self_log_category sosl_server_log.log_category%TYPE := 'SOSL_SERVER';
267  	 l_self_caller	     sosl_server_log.caller%TYPE       := 'sosl_server.get_script_schema';
268    BEGIN
269  	 l_script_schema := TRIM(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'));
270  	 IF sosl_sys.has_run_id(p_run_id)
271  	 THEN
272  	   SELECT sed.function_owner
273  	     INTO l_script_schema
274  	     FROM sosl_run_queue srq
275  	     LEFT OUTER JOIN sosl_executor_definition sed
276  	       ON srq.executor_id = sed.executor_id
277  	    WHERE srq.run_id = p_run_id
278  	   ;
279  	 ELSE
280  	   sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Requested run id ' || p_run_id || ' does not exist.');
281  	   l_script_schema := TRIM(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'));
282  	 END IF;
283  	 RETURN l_script_schema;
284    EXCEPTION
285  	 WHEN OTHERS THEN
286  	   -- log the error instead of RAISE
287  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
288  	   RETURN TRIM(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'));
289    END get_script_schema;
290  
291    FUNCTION get_sosl_schema
292  	 RETURN VARCHAR2
293    IS
294  	 l_sosl_schema	     VARCHAR2(128);
295    BEGIN
296  	 SELECT config_value
297  	   INTO l_sosl_schema
298  	   FROM sosl_config
299  	  WHERE config_name = 'SOSL_SCHEMA'
300  	 ;
301  	 RETURN l_sosl_schema;
302    EXCEPTION
303  	 WHEN OTHERS THEN
304  	   -- log the error instead of RAISE
305  	   sosl_log.exception_log('sosl_server.get_sosl_schema', 'SOSL_SERVER', SQLERRM);
306  	   -- return PUBLIC to guarantee errors if used as schema prefix. Issues must be fixed before.
307  	   RETURN 'PUBLIC';
308    END get_sosl_schema;
309  
310    FUNCTION set_script_started(p_run_id IN NUMBER)
311  	 RETURN NUMBER
312    IS
313  	 l_return	     NUMBER;
314    BEGIN
315  	 l_return := sosl_sys.set_script_status(p_run_id, sosl_constants.RUN_STATE_STARTED);
316  	 RETURN l_return;
317    EXCEPTION
318  	 WHEN OTHERS THEN
319  	   -- log the error instead of RAISE
320  	   sosl_log.exception_log('sosl_server.set_script_started', 'SOSL_SERVER', SQLERRM);
321  	   RETURN -1;
322    END set_script_started;
323  
324    FUNCTION set_script_running(p_run_id IN NUMBER)
325  	 RETURN NUMBER
326    IS
327  	 l_return	     NUMBER;
328    BEGIN
329  	 l_return := sosl_sys.set_script_status(p_run_id, sosl_constants.RUN_STATE_RUNNING);
330  	 RETURN l_return;
331    EXCEPTION
332  	 WHEN OTHERS THEN
333  	   -- log the error instead of RAISE
334  	   sosl_log.exception_log('sosl_server.set_script_running', 'SOSL_SERVER', SQLERRM);
335  	   RETURN -1;
336    END set_script_running;
337  
338    FUNCTION set_script_finished(p_run_id IN NUMBER)
339  	 RETURN NUMBER
340    IS
341  	 l_return	     NUMBER;
342    BEGIN
343  	 l_return := sosl_sys.set_script_status(p_run_id, sosl_constants.RUN_STATE_FINISHED);
344  	 RETURN l_return;
345    EXCEPTION
346  	 WHEN OTHERS THEN
347  	   -- log the error instead of RAISE
348  	   sosl_log.exception_log('sosl_server.set_script_finished', 'SOSL_SERVER', SQLERRM);
349  	   RETURN -1;
350    END set_script_finished;
351  
352    FUNCTION set_script_error(p_run_id IN NUMBER)
353  	 RETURN NUMBER
354    IS
355  	 l_return	     NUMBER;
356    BEGIN
357  	 l_return := sosl_sys.set_script_status(p_run_id, sosl_constants.RUN_STATE_ERROR);
358  	 RETURN l_return;
359    EXCEPTION
360  	 WHEN OTHERS THEN
361  	   -- log the error instead of RAISE
362  	   sosl_log.exception_log('sosl_server.set_script_error', 'SOSL_SERVER', SQLERRM);
363  	   RETURN -1;
364    END set_script_error;
365  
366    FUNCTION info_log( p_srv_caller	 IN VARCHAR2
367  			, p_srv_message  IN VARCHAR2
368  			, p_identifier	 IN VARCHAR2 DEFAULT NULL
369  			, p_local_log	 IN VARCHAR2 DEFAULT NULL
370  			, p_srv_run_id	 IN NUMBER   DEFAULT NULL
371  			, p_srv_guid	 IN VARCHAR2 DEFAULT NULL
372  			)
373  	 RETURN VARCHAR2
374    IS
375  	 l_message   VARCHAR2(32767);
376  	 l_payload   SOSL_PAYLOAD;
377    BEGIN
378  	 IF p_local_log IS NOT NULL
379  	 THEN
380  	   l_message := p_srv_message || ' local log file: ' || p_local_log;
381  	 ELSE
382  	   l_message := p_srv_message;
383  	 END IF;
384  	 IF p_srv_run_id IS NOT NULL
385  	 THEN
386  	   l_payload := sosl_sys.get_payload(p_srv_run_id);
387  	 ELSE
388  	   l_payload := SOSL_PAYLOAD(NULL, NULL, NULL);
389  	 END IF;
390  	 sosl_log.full_log( p_message => l_message
391  			  , p_log_type => sosl_constants.LOG_INFO_TYPE
392  			  , p_log_category => 'SOSL_SERVER'
393  			  , p_caller => p_srv_caller
394  			  , p_guid => p_srv_guid
395  			  , p_sosl_identifier => p_identifier
396  			  , p_executor_id => l_payload.executor_id
397  			  , p_ext_script_id => l_payload.ext_script_id
398  			  , p_script_file => l_payload.script_file
399  			  , p_run_id => p_srv_run_id
400  			  )
401  	 ;
402  	 RETURN p_srv_message;
403    EXCEPTION
404  	 WHEN OTHERS THEN
405  	   -- log the error instead of RAISE
406  	   sosl_log.exception_log('sosl_server.info_log', 'SOSL_SERVER', SQLERRM);
407  	   RETURN SUBSTR(SQLERRM, 1, 4000);
408    END info_log;
409  
410    FUNCTION warning_log( p_srv_caller   IN VARCHAR2
411  			   , p_srv_message  IN VARCHAR2
412  			   , p_identifier   IN VARCHAR2 DEFAULT NULL
413  			   , p_local_log    IN VARCHAR2 DEFAULT NULL
414  			   , p_srv_run_id   IN NUMBER	DEFAULT NULL
415  			   , p_srv_guid     IN VARCHAR2 DEFAULT NULL
416  			   )
417  	 RETURN VARCHAR2
418    IS
419  	 l_message   VARCHAR2(32767);
420  	 l_payload   SOSL_PAYLOAD;
421    BEGIN
422  	 IF p_local_log IS NOT NULL
423  	 THEN
424  	   l_message := p_srv_message || ' local log file: ' || p_local_log;
425  	 ELSE
426  	   l_message := p_srv_message;
427  	 END IF;
428  	 IF p_srv_run_id IS NOT NULL
429  	 THEN
430  	   l_payload := sosl_sys.get_payload(p_srv_run_id);
431  	 ELSE
432  	   l_payload := SOSL_PAYLOAD(NULL, NULL, NULL);
433  	 END IF;
434  	 sosl_log.full_log( p_message => l_message
435  			  , p_log_type => sosl_constants.LOG_WARNING_TYPE
436  			  , p_log_category => 'SOSL_SERVER'
437  			  , p_caller => p_srv_caller
438  			  , p_guid => p_srv_guid
439  			  , p_sosl_identifier => p_identifier
440  			  , p_executor_id => l_payload.executor_id
441  			  , p_ext_script_id => l_payload.ext_script_id
442  			  , p_script_file => l_payload.script_file
443  			  , p_run_id => p_srv_run_id
444  			  )
445  	 ;
446  	 RETURN p_srv_message;
447    EXCEPTION
448  	 WHEN OTHERS THEN
449  	   -- log the error instead of RAISE
450  	   sosl_log.exception_log('sosl_server.warning_log', 'SOSL_SERVER', SQLERRM);
451  	   RETURN SUBSTR(SQLERRM, 1, 4000);
452    END warning_log;
453  
454    FUNCTION error_log( p_srv_caller   IN VARCHAR2
455  			 , p_srv_message  IN VARCHAR2
456  			 , p_identifier   IN VARCHAR2 DEFAULT NULL
457  			 , p_local_log	  IN VARCHAR2 DEFAULT NULL
458  			 , p_srv_run_id   IN NUMBER   DEFAULT NULL
459  			 , p_srv_guid	  IN VARCHAR2 DEFAULT NULL
460  			 )
461  	 RETURN VARCHAR2
462    IS
463  	 l_message   VARCHAR2(32767);
464  	 l_payload   SOSL_PAYLOAD;
465    BEGIN
466  	 IF p_local_log IS NOT NULL
467  	 THEN
468  	   l_message := p_srv_message || ' local log file: ' || p_local_log;
469  	 ELSE
470  	   l_message := p_srv_message;
471  	 END IF;
472  	 IF p_srv_run_id IS NOT NULL
473  	 THEN
474  	   l_payload := sosl_sys.get_payload(p_srv_run_id);
475  	 ELSE
476  	   l_payload := SOSL_PAYLOAD(NULL, NULL, NULL);
477  	 END IF;
478  	 sosl_log.full_log( p_message => l_message
479  			  , p_log_type => sosl_constants.LOG_ERROR_TYPE
480  			  , p_log_category => 'SOSL_SERVER'
481  			  , p_caller => p_srv_caller
482  			  , p_guid => p_srv_guid
483  			  , p_sosl_identifier => p_identifier
484  			  , p_executor_id => l_payload.executor_id
485  			  , p_ext_script_id => l_payload.ext_script_id
486  			  , p_script_file => l_payload.script_file
487  			  , p_run_id => p_srv_run_id
488  			  )
489  	 ;
490  	 RETURN p_srv_message;
491    EXCEPTION
492  	 WHEN OTHERS THEN
493  	   -- log the error instead of RAISE
494  	   sosl_log.exception_log('sosl_server.error_log', 'SOSL_SERVER', SQLERRM);
495  	   RETURN SUBSTR(SQLERRM, 1, 4000);
496    END error_log;
497  
498    FUNCTION has_scripts
499  	 RETURN NUMBER
500    IS
501  	 l_return NUMBER;
502    BEGIN
503  	 l_return := sosl_sys.has_scripts;
504  	 RETURN l_return;
505    EXCEPTION
506  	 WHEN OTHERS THEN
507  	   -- log the error instead of RAISE
508  	   sosl_log.exception_log('sosl_server.has_scripts', 'SOSL_SERVER', SQLERRM);
509  	   RETURN -1;
510    END has_scripts;
511  
512    FUNCTION get_next_script
513  	 RETURN NUMBER
514    IS
515  	 l_return NUMBER;
516    BEGIN
517  	 l_return := sosl_sys.get_next_script;
518  	 RETURN l_return;
519    EXCEPTION
520  	 WHEN OTHERS THEN
521  	   -- log the error instead of RAISE
522  	   sosl_log.exception_log('sosl_server.get_next_script', 'SOSL_SERVER', SQLERRM);
523  	   RETURN -1;
524    END get_next_script;
525  
526    FUNCTION update_run_id( p_run_id      IN NUMBER
527  			     , p_identifier  IN VARCHAR2
528  			     , p_guid	     IN VARCHAR2 DEFAULT NULL
529  			     )
530  	 RETURN NUMBER
531    IS
532  	 l_return  NUMBER;
533  	 l_result  NUMBER;
534    BEGIN
535  	 l_return := -1;
536  	 l_result := sosl_server.set_identifier(p_run_id, p_identifier);
537  	 IF l_result = 0
538  	 THEN
539  	   l_return := 0;
540  	 END IF;
541  	 IF p_guid IS NOT NULL
542  	 THEN
543  	   l_result := sosl_server.set_guid(p_run_id, p_guid);
544  	   IF l_result != 0
545  	   THEN
546  	     l_return := -1;
547  	   END IF;
548  	 END IF;
549  	 RETURN l_return;
550    EXCEPTION
551  	 WHEN OTHERS THEN
552  	   -- log the error instead of RAISE
553  	   sosl_log.exception_log('sosl_server.update_run_id', 'SOSL_SERVER', SQLERRM);
554  	   RETURN -1;
555    END update_run_id;
556  
557  END;
558  /

Package body created.

SQL> @@../sosl_ddl/packages/sosl_api.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- Basic package providing the API to the Simple Oracle Script Loader.
SQL> CREATE OR REPLACE PACKAGE sosl_api
  2  AS
  3    /**
  4    * This package contains SOSL API functions and procedures to be used by executors.
  5    */
  6  
  7    /* FUNCTION SOSL_API.GET_PAYLOAD
  8    * Builds a SOSL_PAYLOAD object from the given run id. Wrapper for SOSL_SYS.
  9    *
 10    * @param p_run_id The run id to get the SOSL_PAYLOAD object for.
 11    *
 12    * @return On success a valid SOSL_PAYLOAD object or NULL on errors.
 13    */
 14    FUNCTION get_payload(p_run_id IN NUMBER)
 15  	 RETURN SOSL_PAYLOAD
 16    ;
 17  
 18    /** Function SOSL_API.GET_CONFIG
 19    * Gets an existing configuration value for a given and existing case sensitive configuration name.
 20    *
 21    * @return The configured value as VARCHAR2 or -1 string on error.
 22    */
 23    FUNCTION get_config(p_config_name IN VARCHAR2)
 24  	 RETURN VARCHAR2
 25    ;
 26  
 27  
 28    /** Function SOSL_API.BASE_PATH
 29    * Returns the base path to use for the given run id. Used to switch the run base path for scripts
 30    * running from a different directory.
 31    *
 32    * @return The configured full base path or a simple point for current directory if nothing is configured.
 33    */
 34    FUNCTION base_path(p_run_id IN NUMBER)
 35  	 RETURN VARCHAR2
 36    ;
 37  
 38    /** Function SOSL_API.CFG_PATH
 39    * Returns the relative configuration path to use for the given run id. A sosl_login.cfg file is expected
 40    * at the given location.
 41    *
 42    * @return The configured relative configuration path or the configured default set by the sosl server.
 43    */
 44    FUNCTION cfg_path(p_run_id IN NUMBER)
 45  	 RETURN VARCHAR2
 46    ;
 47  
 48    /** Function SOSL_API.TMP_PATH
 49    * Returns the relative temporary path to use for the given run id.
 50    *
 51    * @return The configured relative temporary path or the configured default set by the sosl server.
 52    */
 53    FUNCTION tmp_path(p_run_id IN NUMBER)
 54  	 RETURN VARCHAR2
 55    ;
 56  
 57    /** Function SOSL_API.LOG_PATH
 58    * Returns the relative log path to use for the given run id.
 59    *
 60    * @return The configured relative log path or the configured default set by the sosl server.
 61    */
 62    FUNCTION log_path(p_run_id IN NUMBER)
 63  	 RETURN VARCHAR2
 64    ;
 65  
 66    /* FUNCTION SOSL_API.DUMMY_MAIL
 67    * This is a testing function that will NOT send any mail. It will log the mail message created in SOSL_SERVER_LOG using
 68    * the field full_message, so output can be controlled.
 69    *
 70    * @param p_sender The valid mail sender address, e.g. mail.user@some.org.
 71    * @param p_recipients The semicolon separated list of mail recipient addresses.
 72    * @param p_subject A preferablly short subject for the mail.
 73    * @param p_message The correctly formatted mail message.
 74    *
 75    * @return Will return TRUE on success or FALSE on errors.
 76    */
 77    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
 78  			  , p_recipients  IN VARCHAR2
 79  			  , p_subject	  IN VARCHAR2
 80  			  , p_message	  IN VARCHAR2
 81  			  )
 82  	 RETURN BOOLEAN
 83    ;
 84  
 85    /* FUNCTION SOSL_API.HAS_RUN_ID
 86    * Checks if a given run id exists. Errors get logged.
 87    *
 88    * @param p_run_id The run id to verify.
 89    *
 90    * @return TRUE if run id exists otherwise FALSE.
 91    */
 92    FUNCTION has_run_id(p_run_id IN NUMBER)
 93  	 RETURN BOOLEAN
 94    ;
 95  
 96  END;
 97  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_api.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_api
  2  AS
  3    -- for description see header file
  4    FUNCTION get_payload(p_run_id IN NUMBER)
  5  	 RETURN SOSL_PAYLOAD
  6    IS
  7  	 l_sosl_payload  SOSL_PAYLOAD;
  8    BEGIN
  9  	 l_sosl_payload := sosl_sys.get_payload(p_run_id);
 10  	 RETURN l_sosl_payload;
 11    EXCEPTION
 12  	 WHEN OTHERS THEN
 13  	   -- log the error instead of RAISE
 14  	   sosl_log.exception_log('sosl_api.get_payload', 'SOSL_API', SQLERRM);
 15  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 16  	   RETURN NULL;
 17    END get_payload;
 18  
 19    FUNCTION get_config(p_config_name IN VARCHAR2)
 20  	 RETURN VARCHAR2
 21    IS
 22    BEGIN
 23  	 RETURN NULL;
 24    END get_config;
 25  
 26    FUNCTION base_path(p_run_id IN NUMBER)
 27  	 RETURN VARCHAR2
 28    IS
 29    BEGIN
 30  	 RETURN NULL;
 31    END base_path;
 32  
 33    FUNCTION cfg_path(p_run_id IN NUMBER)
 34  	 RETURN VARCHAR2
 35    IS
 36    BEGIN
 37  	 RETURN NULL;
 38    END cfg_path;
 39  
 40    FUNCTION tmp_path(p_run_id IN NUMBER)
 41  	 RETURN VARCHAR2
 42    IS
 43    BEGIN
 44  	 RETURN NULL;
 45    END tmp_path;
 46  
 47    FUNCTION log_path(p_run_id IN NUMBER)
 48  	 RETURN VARCHAR2
 49    IS
 50    BEGIN
 51  	 RETURN NULL;
 52    END log_path;
 53  
 54    FUNCTION dummy_mail( p_sender	  IN VARCHAR2
 55  			  , p_recipients  IN VARCHAR2
 56  			  , p_subject	  IN VARCHAR2
 57  			  , p_message	  IN VARCHAR2
 58  			  )
 59  	 RETURN BOOLEAN
 60    IS
 61  	 l_result  NUMBER;
 62  	 l_return  BOOLEAN;
 63    BEGIN
 64  	 l_result  := sosl_util.dummy_mail(p_sender, p_recipients, p_subject, p_message);
 65  	 l_return  := (l_result = 0);
 66  	 RETURN l_return;
 67    EXCEPTION
 68  	 WHEN OTHERS THEN
 69  	   -- log the error instead of RAISE
 70  	   sosl_log.exception_log('sosl_api.dummy_mail', 'SOSL_API', SQLERRM);
 71  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 72  	   RETURN FALSE;
 73    END dummy_mail;
 74  
 75    FUNCTION has_run_id(p_run_id IN NUMBER)
 76  	 RETURN BOOLEAN
 77    IS
 78  	 l_return BOOLEAN;
 79    BEGIN
 80  	 l_return := sosl_sys.has_run_id(p_run_id);
 81  	 RETURN l_return;
 82    EXCEPTION
 83  	 WHEN OTHERS THEN
 84  	   -- log the error instead of RAISE
 85  	   sosl_log.exception_log('sosl_api.has_run_id', 'SOSL_API', SQLERRM);
 86  	   -- sosl_constants.NUM_ERROR can be tweaked by modifying the package, make sure, value is below zero
 87  	   RETURN FALSE;
 88    END has_run_id;
 89  
 90  END;
 91  /

Package body created.

SQL> -- grants
SQL> GRANT EXECUTE ON sosl_api TO sosl_executor;

Grant succeeded.

SQL> @@../sosl_ddl/packages/sosl_if.pks
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- interface package of the Simple Oracle Script Loader
SQL> CREATE OR REPLACE PACKAGE sosl_if
  2  AS
  3    /**
  4    * This package contains the internal interface to SOSL used by the Simple Oracle Script Loader.
  5    * Can be seen as tutorial and implementation hint for own interfaces.
  6    */
  7  
  8    /** Function SOSL_IF.HAS_SCRIPTS
  9    * Determines if script ids are available to be executed. To be defined in SOSL_EXECUTOR_DEFINITION.
 10    *
 11    * @return The number of script ids waiting for execution.
 12    */
 13    FUNCTION has_scripts
 14  	 RETURN NUMBER
 15    ;
 16  
 17    /** Function SOSL_IF.GET_NEXT_SCRIPT
 18    * Returns the next script id to execute. To be defined in SOSL_EXECUTOR_DEFINITION.
 19    *
 20    * @return The id of the next script to execute.
 21    */
 22    FUNCTION get_next_script
 23  	 RETURN SOSL.SOSL_PAYLOAD
 24    ;
 25  
 26    /** Function SOSL_IF.SET_SCRIPT_STATUS
 27    * Sets the status of a script. To be defined in SOSL_EXECUTOR_DEFINITION.
 28    *
 29    * @param p_run_id The valid run id of the script that should change run state.
 30    * @param p_status A valid status as defined in SOSL_CONSTANTS for run states.
 31    *
 32    * @return Return 0 if successful executed otherwise -1.
 33    */
 34    FUNCTION set_script_status( p_run_id IN NUMBER
 35  				 , p_status IN NUMBER
 36  				 )
 37  	 RETURN NUMBER
 38    ;
 39  
 40    /* FUNCTION SOSL_IF.SEND_MAIL
 41    * This interface function is mainly used for testing. In the default setting, it will only send the mail message to
 42    * SOSL_SERVER_LOG. To be defined in SOSL_EXECUTOR_DEFINITION. Will be called on every status change, if mail is activated.
 43    *
 44    * @param p_run_id The valid run id of the script that should change run state.
 45    * @param p_status A valid status as defined in SOSL_CONSTANTS for run states.
 46    *
 47    * @return Return 0 if successful executed otherwise -1.
 48    */
 49    FUNCTION send_mail( p_run_id IN NUMBER
 50  			 , p_status IN NUMBER
 51  			 )
 52  	 RETURN NUMBER
 53    ;
 54  
 55  END;
 56  /

Package created.

SQL> @@../sosl_ddl/packages/sosl_if.pkb
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE PACKAGE BODY sosl_if
  2  AS
  3    -- see package header for documentation
  4    FUNCTION has_scripts
  5  	 RETURN NUMBER
  6    IS
  7  	 l_return NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*)
 10  	   INTO l_return
 11  	   FROM sosl_if_script
 12  		-- internal conditions about scripts ready to execute
 13  	  WHERE script_active = sosl_constants.NUM_YES
 14  	    AND run_state     = sosl_constants.RUN_STATE_WAITING
 15  		-- we need an assigned executor for the payload
 16  	    AND executor_id   IS NOT NULL
 17  	 ;
 18  	 RETURN l_return;
 19    EXCEPTION
 20  	 WHEN OTHERS THEN
 21  	   -- log the error instead of RAISE
 22  	   sosl_log.exception_log('sosl_if.has_scripts', 'SOSL_IF', SQLERRM);
 23  	   RETURN -1;
 24    END has_scripts;
 25  
 26    FUNCTION get_next_script
 27  	 RETURN SOSL.SOSL_PAYLOAD
 28    IS
 29  	 l_payload	 SOSL.SOSL_PAYLOAD;
 30  	 l_executor_id	 NUMBER;
 31  	 l_ext_script_id VARCHAR2(4000);
 32  	 l_script_file	 VARCHAR2(4000);
 33  	 CURSOR cur_script_data
 34  	 IS
 35  	   SELECT executor_id
 36  		, TRIM(TO_CHAR(script_id)) AS ext_script_id
 37  		, script_name AS script_file
 38  	     FROM sosl_if_script
 39  		  -- internal conditions about scripts ready to execute
 40  	    WHERE script_active = sosl_constants.NUM_YES
 41  	      AND run_state	= sosl_constants.RUN_STATE_WAITING
 42  		  -- we need an assigned executor for the payload
 43  	      AND executor_id	IS NOT NULL
 44  		  -- adjust the order in which scripts get delivered
 45  	    ORDER BY run_group
 46  		   , run_order
 47  	 ;
 48    BEGIN
 49  	 l_payload := NULL;
 50  	 -- check if we have scripts
 51  	 IF sosl_if.has_scripts > 0
 52  	 THEN
 53  	   -- fetch only the first record, statement apart from order is identical to has_scripts statement
 54  	   OPEN cur_script_data;
 55  	   FETCH cur_script_data INTO l_executor_id, l_ext_script_id, l_script_file;
 56  	   CLOSE cur_script_data;
 57  	   -- you may want to add checks for the payload data before building the SOSL_PAYLOAD
 58  	   l_payload := SOSL.SOSL_PAYLOAD(l_executor_id, l_ext_script_id, l_script_file);
 59  	 ELSE
 60  	   -- log error information
 61  	   sosl_log.minimal_error_log('sosl_if.get_next_script', 'SOSL_IF', 'get_next_script called without having scripts to run');
 62  	   l_payload := NULL;
 63  	 END IF;
 64  	 RETURN l_payload;
 65    EXCEPTION
 66  	 WHEN OTHERS THEN
 67  	   -- log the error instead of RAISE
 68  	   sosl_log.exception_log('sosl_if.get_next_script', 'SOSL_IF', SQLERRM);
 69  	   RETURN NULL;
 70    END get_next_script;
 71  
 72    FUNCTION set_script_status( p_run_id IN NUMBER
 73  				 , p_status IN NUMBER
 74  				 )
 75  	 RETURN NUMBER
 76    IS
 77  	 PRAGMA AUTONOMOUS_TRANSACTION;
 78  	 l_return      NUMBER;
 79  	 l_script_id   NUMBER;
 80  	 l_executor_id NUMBER;
 81  	 l_payload     SOSL.SOSL_PAYLOAD;
 82    BEGIN
 83  	 l_return := -1;
 84  	 -- get payload for own identifiers as send by get_next_script
 85  	 l_payload := sosl_api.get_payload(p_run_id);
 86  	 IF l_payload IS NOT NULL
 87  	 THEN
 88  	   -- transform to internal type
 89  	   l_script_id	 := TO_NUMBER(l_payload.ext_script_id);
 90  	   l_executor_id := l_payload.executor_id;
 91  	   -- update internal script table
 92  	   UPDATE sosl_if_script
 93  	      SET run_state = p_status
 94  	    WHERE script_id    = l_script_id
 95  	      AND executor_id  = l_executor_id
 96  	   ;
 97  	   COMMIT;
 98  	   l_return := 0;
 99  	 ELSE
100  	   -- log error information
101  	   sosl_log.minimal_error_log('sosl_if.set_script_status', 'SOSL_IF', 'Invalid SOSL_PAYLOAD for run_id: ' || p_run_id || ' and run state ' || p_status);
102  	   l_return := -1;
103  	 END IF;
104  	 RETURN l_return;
105    EXCEPTION
106  	 WHEN OTHERS THEN
107  	   -- log the error instead of RAISE
108  	   sosl_log.exception_log('sosl_if.set_script_status', 'SOSL_IF', SQLERRM);
109  	   RETURN -1;
110    END set_script_status;
111  
112    FUNCTION send_mail( p_run_id IN NUMBER
113  			 , p_status IN NUMBER
114  			 )
115  	 RETURN NUMBER
116    IS
117  	 l_return	 NUMBER;
118  	 l_mail_subject  VARCHAR2(256);
119  	 l_mail_body	 VARCHAR2(32767);
120  	 l_sender	 VARCHAR2(128);
121  	 l_recipients	 VARCHAR2(1024);
122  	 l_payload	 SOSL.SOSL_PAYLOAD;
123    BEGIN
124  	 l_return := -1;
125  	 -- define basic objects
126  	 l_mail_subject  := 'SOSL ' || sosl_constants.run_state_text(p_status) || ' ';
127  	 l_sender	 := 'fake_sender@fake_domain.com';
128  	 l_recipients	 := 'fake_recipient_group@fake_domain.com; fake_recipient_special@fake_domain.com';
129  	 IF sosl_api.has_run_id(p_run_id)
130  	 THEN
131  	   -- get payload for own identifiers as send by get_next_script
132  	   l_payload := sosl_api.get_payload(p_run_id);
133  	   IF l_payload IS NOT NULL
134  	   THEN
135  	     -- prepare mail
136  	     l_mail_subject  := l_mail_subject || 'Script: ' || TRIM(l_payload.script_file);
137  	     -- format mail body RFC conform, use LF, CR is also valid, but NOT CRLF
138  	     l_mail_body     := 'Dear SOSL user' || sosl_constants.LF || sosl_constants.LF ||
139  				CASE
140  				  WHEN p_status = sosl_constants.RUN_STATE_ERROR
141  				  THEN 'An ERROR happened during script execution.'
142  				  ELSE 'The state of the script execution has changed to ' || sosl_constants.run_state_text(p_status)
143  				END || sosl_constants.LF ||
144  				'Script: ' || l_payload.script_file || sosl_constants.LF ||
145  				'Executor ID: ' || l_payload.executor_id || sosl_constants.LF ||
146  				'Script ID: ' || l_payload.ext_script_id || sosl_constants.LF ||
147  				'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || sosl_constants.LF ||
148  				sosl_constants.LF ||
149  				'Best regards' || sosl_constants.LF ||
150  				'Your SOSL team'|| sosl_constants.LF ||
151  				sosl_constants.LF ||
152  				'Contact fake_admin@fake_domain.com for more information.'
153  	     ;
154  	   ELSE
155  	     -- we still have data for the mail
156  	     l_mail_subject := l_mail_subject || 'RUN_ID: ' || p_run_id;
157  	     l_mail_body     := 'Dear SOSL user' || sosl_constants.LF || sosl_constants.LF ||
158  				'An SEVERE ERROR happened during script execution.' || sosl_constants.LF ||
159  				'Script cannot be identified or SOSL_API.GET_PAYLOAD has failed.' || sosl_constants.LF ||
160  				'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || sosl_constants.LF ||
161  				'Intended state change to: ' || sosl_constants.run_state_text(p_status) || sosl_constants.LF ||
162  				sosl_constants.LF ||
163  				'Best regards' || sosl_constants.LF ||
164  				'Your SOSL team'|| sosl_constants.LF ||
165  				sosl_constants.LF ||
166  				'Contact fake_admin@fake_domain.com for more information.'
167  	     ;
168  	   END IF;
169  	   IF sosl_api.dummy_mail(l_sender, l_recipients, l_mail_subject, l_mail_body)
170  	   THEN
171  	     l_return := 0;
172  	   ELSE
173  	     sosl_log.minimal_error_log('sosl_if.send_mail', 'SOSL_IF', 'Could not send fake mail to log.');
174  	     l_return := -1;
175  	   END IF;
176  	 ELSE
177  	   sosl_log.minimal_error_log('sosl_if.send_mail', 'SOSL_IF', 'RUN_ID ' || p_run_id || ' does not exist.');
178  	   l_mail_subject := l_mail_subject || 'Invalid RUN_ID: ' || p_run_id;
179  	   l_mail_body	   := 'Dear SOSL user' || sosl_constants.LF || sosl_constants.LF ||
180  			      'An SEVERE ERROR happened during script execution.' || sosl_constants.LF ||
181  			      'Given RUN_ID does not exist in table SOSL_RUN_QUEUE.' || sosl_constants.LF ||
182  			      'SOSL_RUN_QUEUE.RUN_ID: ' || p_run_id || sosl_constants.LF ||
183  			      'Intended state change to: ' || sosl_constants.run_state_text(p_status) || sosl_constants.LF ||
184  			      sosl_constants.LF ||
185  			      'Best regards' || sosl_constants.LF ||
186  			      'Your SOSL team'|| sosl_constants.LF ||
187  			      sosl_constants.LF ||
188  			      'Contact fake_admin@fake_domain.com for more information.'
189  	   ;
190  	   IF sosl_api.dummy_mail(l_sender, l_recipients, l_mail_subject, l_mail_body)
191  	   THEN
192  	     l_return := 0;
193  	   ELSE
194  	     sosl_log.minimal_error_log('sosl_if.send_mail', 'SOSL_IF', 'Could not send fake mail to log.');
195  	     l_return := -1;
196  	   END IF;
197  	 END IF;
198  	 RETURN l_return;
199    EXCEPTION
200  	 WHEN OTHERS THEN
201  	   -- log the error instead of RAISE
202  	   sosl_log.exception_log('sosl_if.send_mail', 'SOSL_IF', SQLERRM);
203  	   RETURN -1;
204    END send_mail;
205  
206  END;
207  /

Package body created.

SQL> -- table trigger using packages and tables defined
SQL> @@../sosl_ddl/trigger/sosl_server_log_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_server_log_ins_trg
  2    BEFORE INSERT ON sosl_server_log
  3    FOR EACH ROW
  4  DECLARE
  5    l_split		   BOOLEAN;
  6    l_self_log_category sosl_server_log.log_category%TYPE	 := 'SOSL_TRIGGER';
  7    l_self_caller	   sosl_server_log.caller%TYPE		 := 'sosl_server_log_ins_trg';
  8  BEGIN
  9    -- first set default value if not set, as Oracle does not support default values from package variables
 10    IF :NEW.log_type = sosl_constants.GEN_NA_TYPE
 11    THEN
 12  	 :NEW.log_type := sosl_constants.LOG_INFO_TYPE;
 13    END IF;
 14    -- instead of check constraint to get package support
 15    IF NOT sosl_log.log_type_valid(:NEW.log_type)
 16    THEN
 17  	 -- do not block logging, log the error instead, move message to full message
 18  	 :NEW.full_message := :NEW.message || :NEW.full_message;
 19  	 :NEW.message	   := 'Invalid log type. Not supported by package SOSL_SYS. Given log type: ' || NVL(:NEW.log_type, sosl_constants.GEN_NULL_TEXT);
 20  	 :NEW.log_type	   := sosl_constants.LOG_FATAL_TYPE;
 21    ELSE
 22  	 :NEW.log_type := sosl_log.get_valid_log_type(:NEW.log_type);
 23    END IF;
 24    :NEW.exec_timestamp := SYSTIMESTAMP;
 25    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 26    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 27    -- split messages
 28    IF NOT sosl_log.distribute(:NEW.message, :NEW.full_message, 4000)
 29    THEN
 30  	 -- do not block logging, log the error instead, if :NEW.message contains error information leave it there
 31  	 IF :NEW.message IS NULL AND :NEW.full_message IS NULL
 32  	 THEN
 33  	   :NEW.message := 'Full message must be given, if message is NULL or vice versa.';
 34  	 END IF;
 35  	 :NEW.log_type := sosl_constants.LOG_FATAL_TYPE;
 36    END IF;
 37  EXCEPTION
 38    WHEN OTHERS THEN
 39  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 40  	 RAISE;
 41  END;
 42  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_upd_trg
  2    BEFORE UPDATE ON sosl_server_log
  3  BEGIN
  4    sosl_log.minimal_error_log( 'sosl_server_log_upd_trg'
  5  				 , 'SOSL_TRIGGER'
  6  				 , '-20000 No updates allowed on a log table.'
  7  				 , 'Forbidden UPDATE on log table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
  8  				 )
  9    ;
 10    RAISE_APPLICATION_ERROR(-20000, 'No updates allowed on a log table.');
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_server_log_del_trg
  2    BEFORE DELETE ON sosl_server_log
  3  BEGIN
  4    sosl_log.minimal_error_log( 'sosl_server_log_del_trg'
  5  				 , 'SOSL_TRIGGER'
  6  				 , '-20001 Delete records from a log table is not allowed. This is an admin job which needs sufficient rights and usage of the SOSL API.'
  7  				 , 'Forbidden DELETE on log table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
  8  				 )
  9    ;
 10    RAISE_APPLICATION_ERROR(-20001, 'Delete records from a log table is not allowed. This is an admin job which needs sufficient rights and usage of the SOSL API.');
 11  END;
 12  /

Trigger created.

SQL> @@../sosl_ddl/trigger/sosl_config_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_config_ins_trg
  2    BEFORE INSERT ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok		   BOOLEAN;
  6    l_date		   DATE;
  7    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_CONFIG';
  8    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_config_ins_trg';
  9  BEGIN
 10    -- remove any leading and trailing blanks from config_value
 11    :NEW.config_value   := TRIM(:NEW.config_value);
 12    :NEW.created	   := SYSDATE;
 13    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 14    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 15    -- check max length if defined
 16    IF :NEW.config_type = 'CHAR'
 17    THEN
 18  	 IF :NEW.config_max_length > 0
 19  	 THEN
 20  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 21  	   THEN
 22  	     sosl_log.minimal_error_log( l_self_caller
 23  				       , l_self_log_category
 24  				       , '-20010 The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value)
 25  				       , 'Wrong length of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 26  				       )
 27  	     ;
 28  	     RAISE_APPLICATION_ERROR(-20010, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 29  	   END IF;
 30  	 END IF;
 31    END IF;
 32    -- check number type
 33    IF :NEW.config_type = 'NUMBER'
 34    THEN
 35  	 l_ok := TRUE;
 36  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 37  	 BEGIN
 38  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 39  	 EXCEPTION
 40  	   WHEN OTHERS THEN
 41  	     sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 42  	     l_ok := FALSE;
 43  	 END;
 44  	 IF NOT l_ok
 45  	 THEN
 46  	   sosl_log.minimal_error_log( l_self_caller
 47  				     , l_self_log_category
 48  				     , '-20011 The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.'
 49  				     , 'Wrong type of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 50  				     )
 51  	   ;
 52  	   RAISE_APPLICATION_ERROR(-20011, 'The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.');
 53  	 END IF;
 54    END IF;
 55  END;
 56  /

Trigger created.

SQL> 
SQL> CREATE OR REPLACE TRIGGER sosl_config_upd_trg
  2    BEFORE UPDATE ON sosl_config
  3    FOR EACH ROW
  4  DECLARE
  5    l_ok		   BOOLEAN;
  6    l_date		   DATE;
  7    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_CONFIG';
  8    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_config_upd_trg';
  9  BEGIN
 10    -- remove any leading and trailing blanks from config_value
 11    :NEW.config_value   := TRIM(:NEW.config_value);
 12    -- report intended changes on columns not allowed to change and reset values to OLD
 13    sosl_log.log_column_change(:OLD.created, :NEW.created, 'SOSL_CONFIG.CREATED', l_self_caller, TRUE);
 14    :NEW.created	   := :OLD.created;
 15    sosl_log.log_column_change(:OLD.created_by, :NEW.created_by, 'SOSL_CONFIG.CREATED_BY', l_self_caller, TRUE);
 16    :NEW.created_by	   := :OLD.created_by;
 17    sosl_log.log_column_change(:OLD.created_by_os, :NEW.created_by_os, 'SOSL_CONFIG.CREATED_BY_OS', l_self_caller, TRUE);
 18    :NEW.created_by_os  := :OLD.created_by_os;
 19    -- check changes on config_name for protected values
 20    IF     :OLD.config_name != :NEW.config_name
 21  	  AND :OLD.config_name IN ( 'SOSL_PATH_CFG'
 22  				  , 'SOSL_PATH_TMP'
 23  				  , 'SOSL_PATH_LOG'
 24  				  , 'SOSL_START_LOG'
 25  				  , 'SOSL_BASE_LOG'
 26  				  , 'SOSL_EXT_LOG'
 27  				  , 'SOSL_EXT_TMP'
 28  				  , 'SOSL_EXT_LOCK'
 29  				  , 'SOSL_EXT_ERROR'
 30  				  , 'SOSL_MAX_PARALLEL'
 31  				  , 'SOSL_RUNMODE'
 32  				  , 'SOSL_DEFAULT_WAIT'
 33  				  , 'SOSL_NOJOB_WAIT'
 34  				  , 'SOSL_PAUSE_WAIT'
 35  				  , 'SOSL_SERVER_STATE'
 36  				  , 'SOSL_START_JOBS'
 37  				  , 'SOSL_STOP_JOBS'
 38  				  , 'SOSL_SCHEMA'
 39  				  )
 40    THEN
 41  	 sosl_log.log_column_change(:OLD.config_name, :NEW.config_name, 'SOSL_CONFIG.CONFIG_NAME', l_self_caller, TRUE);
 42  	 sosl_log.minimal_error_log( l_self_caller
 43  				   , l_self_log_category
 44  				   , '-20012 The given system config_name ' || :OLD.config_name || ' cannot be changed.'
 45  				   , 'Tried to change a system config name for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 46  				   )
 47  	 ;
 48  	 RAISE_APPLICATION_ERROR(-20012, 'The given system config_name ' || :OLD.config_name || ' cannot be changed.');
 49    END IF;
 50    IF      :OLD.config_name   = 'SOSL_SCHEMA'
 51  	  AND  :OLD.config_value != :NEW.config_value
 52    THEN
 53  	 sosl_log.log_column_change(:OLD.config_value, :NEW.config_value, 'SOSL_CONFIG.CONFIG_VALUE', l_self_caller, TRUE);
 54  	 sosl_log.minimal_error_log( l_self_caller
 55  				   , l_self_log_category
 56  				   , '-20014 The SOSL_SCHEMA value ' || :OLD.config_value || ' cannot be changed.'
 57  				   , 'Tried to change SOSL_SCHEMA in SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 58  				   )
 59  	 ;
 60  	 RAISE_APPLICATION_ERROR(-20014, '-20014 The SOSL_SCHEMA value ' || :OLD.config_value || ' cannot be changed.');
 61    END IF;
 62    -- report value changes allowed
 63    sosl_log.log_column_change(:OLD.config_value, :NEW.config_value, :OLD.config_name, l_self_caller, FALSE);
 64    -- set updated
 65    :NEW.updated	   := SYSDATE;
 66    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 67    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 68    -- check max length if defined
 69    IF :NEW.config_type = 'CHAR'
 70    THEN
 71  	 IF :NEW.config_max_length > 0
 72  	 THEN
 73  	   IF LENGTH(:NEW.config_value) > :NEW.config_max_length
 74  	   THEN
 75  	     sosl_log.minimal_error_log( l_self_caller
 76  				       , l_self_log_category
 77  				       , '-20010 The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value)
 78  				       , 'Wrong length of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 79  				       )
 80  	     ;
 81  	     RAISE_APPLICATION_ERROR(-20010, 'The config_value exceeds the defined config_max_length. Current length: ' || LENGTH(:NEW.config_value));
 82  	   END IF;
 83  	 END IF;
 84    END IF;
 85    -- check number type
 86    IF :NEW.config_type = 'NUMBER'
 87    THEN
 88  	 l_ok := TRUE;
 89  	 -- compare TO_NUMBER with implicite conversion, if it fails the config_value cannot be interpreted correctly
 90  	 BEGIN
 91  	   l_ok := (TO_NUMBER(:NEW.config_value) = :NEW.config_value);
 92  	 EXCEPTION
 93  	   WHEN OTHERS THEN
 94  	     sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 95  	     l_ok := FALSE;
 96  	 END;
 97  	 IF NOT l_ok
 98  	 THEN
 99  	   sosl_log.minimal_error_log( l_self_caller
100  				     , l_self_log_category
101  				     , '-20011 The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.'
102  				     , 'Wrong type of config value for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
103  				     )
104  	   ;
105  	   RAISE_APPLICATION_ERROR(-20011, 'The given config_value "' || NVL(:NEW.config_value, sosl_constants.GEN_NULL_TEXT) || '" could not be converted successfully to a number.');
106  	 END IF;
107    END IF;
108  END;
109  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_config_del_trg
  2    BEFORE DELETE ON sosl_config
  3    FOR EACH ROW
  4  BEGIN
  5    -- protect system parameters from delete
  6    IF :OLD.config_name IN ( 'SOSL_PATH_CFG'
  7  			      , 'SOSL_PATH_TMP'
  8  			      , 'SOSL_PATH_LOG'
  9  			      , 'SOSL_START_LOG'
 10  			      , 'SOSL_BASE_LOG'
 11  			      , 'SOSL_EXT_LOG'
 12  			      , 'SOSL_EXT_TMP'
 13  			      , 'SOSL_EXT_LOCK'
 14  			      , 'SOSL_EXT_ERROR'
 15  			      , 'SOSL_MAX_PARALLEL'
 16  			      , 'SOSL_RUNMODE'
 17  			      , 'SOSL_DEFAULT_WAIT'
 18  			      , 'SOSL_NOJOB_WAIT'
 19  			      , 'SOSL_PAUSE_WAIT'
 20  			      , 'SOSL_SERVER_STATE'
 21  			      , 'SOSL_START_JOBS'
 22  			      , 'SOSL_STOP_JOBS'
 23  			      , 'SOSL_SCHEMA'
 24  			      )
 25    THEN
 26  	 sosl_log.minimal_error_log( 'sosl_config_del_trg'
 27  				   , 'SOSL_CONFIG'
 28  				   , '-20015 The given system config_name "' || :OLD.config_name || '" cannot be deleted.'
 29  				   , 'Forbidden delete of config name for SOSL_CONFIG table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 30  				   )
 31  	 ;
 32  	 RAISE_APPLICATION_ERROR(-20013, 'The given system config_name "' || :OLD.config_name || '" cannot be deleted.');
 33    END IF;
 34  END;
 35  /

Trigger created.

SQL> 
SQL> @@../sosl_ddl/trigger/sosl_executor_definition_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_executor_definition_ins_trg
  2    BEFORE INSERT ON sosl_executor_definition
  3    FOR EACH ROW
  4  DECLARE
  5    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_EXECUTOR_DEFINITION';
  6    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_executor_definition_ins_trg';
  7  BEGIN
  8    :NEW.created	       := SYSDATE;
  9    :NEW.created_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.created_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 11    :NEW.updated	       := SYSDATE;
 12    :NEW.updated_by	       := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 13    :NEW.updated_by_os      := SYS_CONTEXT('USERENV', 'OS_USER');
 14    :NEW.executor_active    := 0;
 15    :NEW.executor_reviewed  := 0;
 16    -- transform users and functions to UPPERCASE, no support currently for special mix-case.
 17    :NEW.function_owner	 := UPPER(:NEW.function_owner);
 18    :NEW.db_user		 := UPPER(:NEW.db_user);
 19    :NEW.fn_has_scripts	 := UPPER(:NEW.fn_has_scripts);
 20    :NEW.fn_get_next_script	 := UPPER(:NEW.fn_get_next_script);
 21    :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 22    :NEW.fn_send_db_mail	 := UPPER(:NEW.fn_send_db_mail);
 23    -- check user
 24    IF NOT sosl_util.has_db_user(:NEW.db_user)
 25    THEN
 26  	 sosl_log.minimal_error_log( l_self_caller
 27  				   , l_self_log_category
 28  				   , '-20020 The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 29  				   , 'Wrong database user for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 30  				   )
 31  	 ;
 32  	 RAISE_APPLICATION_ERROR(-20020, 'The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 33    END IF;
 34    IF NOT sosl_util.has_db_user(:NEW.function_owner)
 35    THEN
 36  	 sosl_log.minimal_error_log( l_self_caller
 37  				   , l_self_log_category
 38  				   , '-20021 The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 39  				   , 'Wrong function owner for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 40  				   )
 41  	 ;
 42  	 RAISE_APPLICATION_ERROR(-20021, 'The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 43    END IF;
 44    -- check configured functions
 45    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 46    THEN
 47  	 sosl_log.minimal_error_log( l_self_caller
 48  				   , l_self_log_category
 49  				   , '-20022 The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 50  				   , 'Wrong function has_scripts for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 51  				   )
 52  	 ;
 53  	 RAISE_APPLICATION_ERROR(-20022, 'The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 54    END IF;
 55    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'OBJECT')
 56    THEN
 57  	 sosl_log.minimal_error_log( l_self_caller
 58  				   , l_self_log_category
 59  				   , '-20023 The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 60  				   , 'Wrong function get_next_script for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 61  				   )
 62  	 ;
 63  	 RAISE_APPLICATION_ERROR(-20023, 'The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 64    END IF;
 65    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
 66    THEN
 67  	 sosl_log.minimal_error_log( l_self_caller
 68  				   , l_self_log_category
 69  				   , '-20024 The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 70  				   , 'Wrong function set_script_status for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 71  				   )
 72  	 ;
 73  	 RAISE_APPLICATION_ERROR(-20024, 'The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 74    END IF;
 75    -- check mail
 76    IF :NEW.use_mail = 1
 77    THEN
 78  	 IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
 79  	 THEN
 80  	   sosl_log.minimal_error_log( l_self_caller
 81  				     , l_self_log_category
 82  				     , '-20025 The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 83  				     , 'Wrong function send_db_mail for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 84  				     )
 85  	   ;
 86  	   RAISE_APPLICATION_ERROR(-20025, 'The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 87  	 END IF;
 88    END IF;
 89    -- log the insert
 90    sosl_log.minimal_info_log( l_self_caller
 91  				, l_self_log_category
 92  				, 'A new executor named ' || :NEW.executor_name || ' has been defined for DB user: ' || :NEW.db_user || ' with function owner: ' || :NEW.function_owner || '.'
 93  				)
 94    ;
 95  EXCEPTION
 96    WHEN OTHERS THEN
 97  	 -- catch and log all undefined exceptions
 98  	 IF SQLCODE NOT IN (-20005, -20006, -20007, -20008, -20009, -20010)
 99  	 THEN
100  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
101  	 END IF;
102  	 -- raise all errors
103  	 RAISE;
104  END;
105  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_executor_definition_upd_trg
  2    BEFORE UPDATE ON sosl_executor_definition
  3    FOR EACH ROW
  4  DECLARE
  5    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_EXECUTOR_DEFINITION';
  6    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_executor_definition_upd_trg';
  7  BEGIN
  8    :NEW.updated	   := SYSDATE;
  9    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 10    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 11    -- no overwrite for this values, log changes
 12    sosl_log.log_column_change(:OLD.created, :NEW.created, 'SOSL_EXECUTOR_DEFINITION.CREATED', l_self_caller);
 13    :NEW.created := :OLD.created;
 14    sosl_log.log_column_change(:OLD.created_by, :NEW.created_by, 'SOSL_EXECUTOR_DEFINITION.CREATED_BY', l_self_caller);
 15    :NEW.created_by := :OLD.created_by;
 16    sosl_log.log_column_change(:OLD.created_by_os, :NEW.created_by_os, 'SOSL_EXECUTOR_DEFINITION.CREATED_BY_OS', l_self_caller);
 17    :NEW.created_by_os := :OLD.created_by_os;
 18    sosl_log.log_column_change(:OLD.function_owner, :NEW.function_owner, 'SOSL_EXECUTOR_DEFINITION.FUNCTION_OWNER', l_self_caller);
 19    :NEW.function_owner := :OLD.function_owner;
 20    sosl_log.log_column_change(:OLD.db_user, :NEW.db_user, 'SOSL_EXECUTOR_DEFINITION.DB_USER', l_self_caller);
 21    :NEW.db_user := :OLD.db_user;
 22    -- prepare possibly modified values
 23    sosl_log.log_column_change(:OLD.executor_active, :NEW.executor_active, 'SOSL_EXECUTOR_DEFINITION.EXECUTOR_ACTIVE', l_self_caller, FALSE);
 24    sosl_log.log_column_change(:OLD.executor_reviewed, :NEW.executor_reviewed, 'SOSL_EXECUTOR_DEFINITION.EXECUTOR_REVIEWED', l_self_caller, FALSE);
 25    sosl_log.log_column_change(:OLD.use_mail, :NEW.use_mail, 'SOSL_EXECUTOR_DEFINITION.USE_MAIL', l_self_caller, FALSE);
 26    sosl_log.log_column_change(:OLD.fn_has_scripts, :NEW.fn_has_scripts, 'SOSL_EXECUTOR_DEFINITION.FN_HAS_SCRIPTS', l_self_caller, FALSE);
 27    :NEW.fn_has_scripts := UPPER(:NEW.fn_has_scripts);
 28    sosl_log.log_column_change(:OLD.fn_get_next_script, :NEW.fn_get_next_script, 'SOSL_EXECUTOR_DEFINITION.FN_GET_NEXT_SCRIPT', l_self_caller, FALSE);
 29    :NEW.fn_get_next_script := UPPER(:NEW.fn_get_next_script);
 30    sosl_log.log_column_change(:OLD.fn_set_script_status, :NEW.fn_set_script_status, 'SOSL_EXECUTOR_DEFINITION.FN_SET_SCRIPT_STATUS', l_self_caller, FALSE);
 31    :NEW.fn_set_script_status := UPPER(:NEW.fn_set_script_status);
 32    sosl_log.log_column_change(:OLD.fn_send_db_mail, :NEW.fn_send_db_mail, 'SOSL_EXECUTOR_DEFINITION.FN_SEND_DB_MAIL', l_self_caller, FALSE);
 33    :NEW.fn_send_db_mail := UPPER(:NEW.fn_send_db_mail);
 34    -- do all checks again including user
 35    -- check user
 36    IF NOT sosl_util.has_db_user(:NEW.db_user)
 37    THEN
 38  	 sosl_log.minimal_error_log( l_self_caller
 39  				   , l_self_log_category
 40  				   , '-20020 The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 41  				   , 'Wrong database user for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 42  				   )
 43  	 ;
 44  	 RAISE_APPLICATION_ERROR(-20020, 'The given database user "' || NVL(:NEW.db_user, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 45    END IF;
 46    IF NOT sosl_util.has_db_user(:NEW.function_owner)
 47    THEN
 48  	 sosl_log.minimal_error_log( l_self_caller
 49  				   , l_self_log_category
 50  				   , '-20021 The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.'
 51  				   , 'Wrong function owner for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 52  				   )
 53  	 ;
 54  	 RAISE_APPLICATION_ERROR(-20021, 'The given function owner database user "' || NVL(:NEW.function_owner, sosl_constants.GEN_NULL_TEXT) || '" is not visible for SOSL in ALL_USERS. Either the user does not exist or SOSL has no right to see this user.');
 55    END IF;
 56    -- check configured functions
 57    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_has_scripts, 'NUMBER')
 58    THEN
 59  	 sosl_log.minimal_error_log( l_self_caller
 60  				   , l_self_log_category
 61  				   , '-20022 The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 62  				   , 'Wrong function has_scripts for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 63  				   )
 64  	 ;
 65  	 RAISE_APPLICATION_ERROR(-20022, 'The given function "' || NVL(:NEW.fn_has_scripts, sosl_constants.GEN_NULL_TEXT) || '" for has_scripts is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 66    END IF;
 67    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_get_next_script, 'OBJECT')
 68    THEN
 69  	 sosl_log.minimal_error_log( l_self_caller
 70  				   , l_self_log_category
 71  				   , '-20023 The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 72  				   , 'Wrong function get_next_script for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 73  				   )
 74  	 ;
 75  	 RAISE_APPLICATION_ERROR(-20023, 'The given function "' || NVL(:NEW.fn_get_next_script, sosl_constants.GEN_NULL_TEXT) || '" for get_next_script is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype OBJECT or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 76    END IF;
 77    IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_set_script_status, 'NUMBER')
 78    THEN
 79  	 sosl_log.minimal_error_log( l_self_caller
 80  				   , l_self_log_category
 81  				   , '-20024 The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 82  				   , 'Wrong function set_script_status for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 83  				   )
 84  	 ;
 85  	 RAISE_APPLICATION_ERROR(-20024, 'The given function "' || NVL(:NEW.fn_set_script_status, sosl_constants.GEN_NULL_TEXT) || '" for set_script_status is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 86    END IF;
 87    -- check mail
 88    IF :NEW.use_mail = 1
 89    THEN
 90  	 IF NOT sosl_util.has_function(:NEW.function_owner, :NEW.fn_send_db_mail, 'NUMBER')
 91  	 THEN
 92  	   sosl_log.minimal_error_log( l_self_caller
 93  				     , l_self_log_category
 94  				     , '-20025 The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.'
 95  				     , 'Wrong function send_db_mail for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 96  				     )
 97  	   ;
 98  	   RAISE_APPLICATION_ERROR(-20025, 'The given function "' || NVL(:NEW.fn_send_db_mail, sosl_constants.GEN_NULL_TEXT) || '" for send_db_mail is not visible for SOSL in ALL_ARGUMENTS. Either the function does not exist, function owner is wrong, has not return datatype NUMBER or is not granted with EXECUTE rights to role SOSL_EXECUTOR.');
 99  	 END IF;
100    END IF;
101    -- check grants if active and reviewed
102    IF      :NEW.executor_active    = sosl_constants.NUM_YES
103  	  AND  :NEW.executor_reviewed  = sosl_constants.NUM_YES
104    THEN
105  	 IF    NOT sosl_util.grant_role(:NEW.db_user, 'SOSL_USER')
106  	    OR NOT sosl_util.grant_role(:NEW.function_owner, 'SOSL_EXECUTOR')
107  	 THEN
108  	   -- could not check or grant role to database user or function owner
109  	   sosl_log.minimal_error_log( l_self_caller
110  				     , l_self_log_category
111  				     , '-20026 Error granting necessary roles to db user (SOSL_USER) or function owner (SOSL_EXECUTOR). Check setup and roles. Probably grant the roles manually before trying update again.'
112  				     , 'Failed granting necessary roles for SOSL_EXECUTOR_DEFINITION table issued by DB user: ' || SYS_CONTEXT('USERENV', 'CURRENT_USER') || ' OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
113  				     )
114  	   ;
115  	   RAISE_APPLICATION_ERROR(-20026, 'Error granting necessary roles to db user (SOSL_USER) or function owner (SOSL_EXECUTOR). Check setup and roles. Probably grant the roles manually before trying update again.');
116  	 END IF;
117    END IF;
118    -- log the update
119    sosl_log.minimal_info_log( l_self_caller
120  				, l_self_log_category
121  				, 'The configuration for executor ID: ' || :OLD.executor_id || ' named ' || :OLD.executor_name || ' has been updated.'
122  				)
123    ;
124  EXCEPTION
125    WHEN OTHERS THEN
126  	 -- catch and log all undefined exceptions
127  	 IF SQLCODE NOT IN (-20005, -20006, -20007, -20008, -20009, -20010, -20011)
128  	 THEN
129  	   sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
130  	 END IF;
131  	 -- raise all errors
132  	 RAISE;
133  END;
134  /

Trigger created.

SQL> @@../sosl_ddl/trigger/sosl_run_queue_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_run_queue_ins_trg
  2    BEFORE INSERT ON sosl_run_queue
  3    FOR EACH ROW
  4  DECLARE
  5    l_executor_valid    NUMBER;
  6    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_RUN_QUEUE';
  7    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_run_queue_ins_trg';
  8  BEGIN
  9    -- check executor, if not accepted and reviewed, set run state to error, else waiting
 10    IF sosl_sys.is_executor_valid(:NEW.executor_id)
 11    THEN
 12  	 :NEW.run_state      := sosl_constants.RUN_STATE_WAITING;
 13  	 :NEW.waiting	     := SYSTIMESTAMP;
 14  	 :NEW.waiting_by     := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 15  	 :NEW.waiting_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 16  	 :NEW.finished	     := NULL;
 17  	 :NEW.finished_by    := NULL;
 18  	 :NEW.finished_by_os := NULL;
 19    ELSE
 20  	 -- log error
 21  	 sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Given executor id ' || :NEW.executor_id || ' is not active and reviewed. Script execution not allowed.');
 22  	 :NEW.run_state      := sosl_constants.RUN_STATE_ERROR;
 23  	 :NEW.waiting	     := NULL;
 24  	 :NEW.waiting_by     := NULL;
 25  	 :NEW.waiting_by_os  := NULL;
 26  	 :NEW.finished	     := SYSTIMESTAMP;
 27  	 :NEW.finished_by    := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 28  	 :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 29    END IF;
 30    -- set basic timestamps
 31    :NEW.created	   := SYSTIMESTAMP;
 32    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 33    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 34    -- overwrite any other injected dates and user on insert
 35    :NEW.enqueued	   := NULL;
 36    :NEW.enqueued_by    := NULL;
 37    :NEW.enqueued_by_os := NULL;
 38    :NEW.started	   := NULL;
 39    :NEW.started_by	   := NULL;
 40    :NEW.started_by_os  := NULL;
 41    :NEW.running_since  := NULL;
 42    :NEW.running_by	   := NULL;
 43    :NEW.running_by_os  := NULL;
 44    -- log the insert
 45    sosl_log.minimal_info_log( l_self_caller
 46  				, l_self_log_category
 47  				, 'A new script with run id ' || :NEW.run_id || ' has been added to the run queue created by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
 48  				)
 49    ;
 50  EXCEPTION
 51    WHEN OTHERS THEN
 52  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 53  	 -- raise all errors
 54  	 RAISE;
 55  END;
 56  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_run_queue_upd_trg
  2    BEFORE UPDATE ON sosl_run_queue
  3    FOR EACH ROW
  4  DECLARE
  5    l_executor_valid    NUMBER;
  6    l_self_log_category sosl_server_log.log_category%TYPE   := 'SOSL_RUN_QUEUE';
  7    l_self_caller	   sosl_server_log.caller%TYPE	       := 'sosl_run_queue_upd_trg';
  8  BEGIN
  9    -- make sure created and basics are not changed
 10    sosl_log.log_column_change(:NEW.created, :OLD.created, 'SOSL_RUN_QUEUE.CREATED', l_self_caller);
 11    :NEW.created	   := :OLD.created;
 12    sosl_log.log_column_change(:NEW.created_by, :OLD.created_by, 'SOSL_RUN_QUEUE.CREATED_BY', l_self_caller);
 13    :NEW.created_by	   := :OLD.created_by;
 14    sosl_log.log_column_change(:NEW.created_by_os, :OLD.created_by_os, 'SOSL_RUN_QUEUE.CREATED_BY_OS', l_self_caller);
 15    :NEW.created_by_os  := :OLD.created_by_os;
 16    sosl_log.log_column_change(:NEW.executor_id, :OLD.executor_id, 'SOSL_RUN_QUEUE.EXECUTOR_ID', l_self_caller);
 17    :NEW.executor_id    := :OLD.executor_id;
 18    sosl_log.log_column_change(:NEW.ext_script_id, :OLD.ext_script_id, 'SOSL_RUN_QUEUE.EXT_SCRIPT_ID', l_self_caller);
 19    :NEW.ext_script_id  := :OLD.ext_script_id;
 20    sosl_log.log_column_change(:NEW.script_file, :OLD.script_file, 'SOSL_RUN_QUEUE.SCRIPT_FILE', l_self_caller);
 21    :NEW.script_file    := :OLD.script_file;
 22    -- check run state order, error can always be set
 23    IF :NEW.run_state != sosl_constants.RUN_STATE_ERROR
 24    THEN
 25  	 -- only if run state has changed
 26  	 IF :NEW.run_state != :OLD.run_state
 27  	 THEN
 28  	   -- normal transitions, organized as ordered sequence numbers 0 to 4
 29  	   -- WAITING -> ENQUEUED, ENQUEUED -> STARTED, STARTED -> RUNNING, RUNNING -> FINISHED, FINSHED -> WAITING
 30  	   IF	  (   :OLD.run_state = sosl_constants.RUN_STATE_ERROR
 31  		   OR :OLD.run_state = sosl_constants.RUN_STATE_FINISHED
 32  		  )
 33  	      AND :NEW.run_state != sosl_constants.RUN_STATE_WAITING
 34  	   THEN
 35  	     -- log it
 36  	     sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Wrong state transition: ' || sosl_constants.run_state_text(:OLD.run_state) || ' not allowed to change to ' || sosl_constants.run_state_text(:NEW.run_state) || '. State set to ERROR.');
 37  	     -- ignore invalid run state, set state to error
 38  	     :NEW.run_state := sosl_constants.RUN_STATE_ERROR;
 39  	   ELSE
 40  	     -- next state must be exactly old run state +1
 41  	     IF :NEW.run_state != (:OLD.run_state + 1)
 42  	     THEN
 43  	       -- log it
 44  	       sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Wrong state transition: ' || sosl_constants.run_state_text(:OLD.run_state) || ' not allowed to change to ' || sosl_constants.run_state_text(:NEW.run_state) || '. State set to ERROR.');
 45  	       -- ignore invalid run state, set state to error
 46  	       :NEW.run_state := sosl_constants.RUN_STATE_ERROR;
 47  	     END IF;
 48  	   END IF;
 49  	 END IF;
 50    END IF;
 51    -- check executor and prevent updates on run state if not valid, set run state to error if executor not valid
 52    IF sosl_sys.is_executor_valid(:NEW.executor_id)
 53    THEN
 54  	-- update dates and user by run state
 55  	 CASE :NEW.run_state
 56  	   WHEN sosl_constants.RUN_STATE_WAITING THEN
 57  	     :NEW.waiting	 := SYSTIMESTAMP;
 58  	     :NEW.waiting_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 59  	     :NEW.waiting_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 60  	   WHEN sosl_constants.RUN_STATE_ENQUEUED THEN
 61  	     :NEW.enqueued	 := SYSTIMESTAMP;
 62  	     :NEW.enqueued_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 63  	     :NEW.enqueued_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 64  	   WHEN sosl_constants.RUN_STATE_STARTED THEN
 65  	     :NEW.started	 := SYSTIMESTAMP;
 66  	     :NEW.started_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 67  	     :NEW.started_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 68  	   WHEN sosl_constants.RUN_STATE_RUNNING THEN
 69  	     :NEW.running_since  := SYSTIMESTAMP;
 70  	     :NEW.running_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 71  	     :NEW.running_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 72  	   WHEN sosl_constants.RUN_STATE_FINISHED THEN
 73  	     :NEW.finished	 := SYSTIMESTAMP;
 74  	     :NEW.finished_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 75  	     :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 76  	   ELSE
 77  	     -- any other state is an error state
 78  	     :NEW.finished	 := SYSTIMESTAMP;
 79  	     :NEW.finished_by	 := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 80  	     :NEW.finished_by_os := SYS_CONTEXT('USERENV', 'OS_USER');
 81  	     :NEW.run_state	 := sosl_constants.RUN_STATE_ERROR;
 82  	 END CASE;
 83    ELSE
 84  	 -- log error
 85  	 sosl_log.minimal_error_log(l_self_caller, l_self_log_category, 'Current executor id ' || :NEW.executor_id || ' is not longer active and reviewed. Script execution not allowed.');
 86  	 -- set run state to error in any case
 87  	 :NEW.run_state      := sosl_constants.RUN_STATE_ERROR;
 88  	 :NEW.enqueued	     := :OLD.enqueued;
 89  	 :NEW.enqueued_by    := :OLD.enqueued_by;
 90  	 :NEW.enqueued_by_os := :OLD.enqueued_by_os;
 91  	 :NEW.started	     := :OLD.started;
 92  	 :NEW.started_by     := :OLD.started_by;
 93  	 :NEW.started_by_os  := :OLD.started_by_os;
 94  	 :NEW.running_since  := :OLD.running_since;
 95  	 :NEW.running_by     := :OLD.running_by;
 96  	 :NEW.running_by_os  := :OLD.running_by_os;
 97  	 :NEW.finished	     := :OLD.finished;
 98  	 :NEW.finished_by    := :OLD.finished_by;
 99  	 :NEW.finished_by_os := :OLD.finished_by_os;
100    END IF;
101    -- log the update
102    sosl_log.minimal_info_log( l_self_caller
103  				, l_self_log_category
104  				, 'Updated run id ' || :OLD.run_id || ' by OS user: ' || SYS_CONTEXT('USERENV', 'OS_USER')
105  				)
106    ;
107  EXCEPTION
108    WHEN OTHERS THEN
109  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
110  	 -- raise all errors
111  	 RAISE;
112  END;
113  /

Trigger created.

SQL> @@../sosl_ddl/trigger/sosl_if_script_trg.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- requires login with the correct schema, either SOSL or your own SOSL schema
SQL> -- requires table to have been created before, as well as used packages
SQL> CREATE OR REPLACE TRIGGER sosl_if_script_ins_trg
  2    BEFORE INSERT ON sosl_if_script
  3    FOR EACH ROW
  4  BEGIN
  5    :NEW.created	   := SYSDATE;
  6    :NEW.updated	   := NULL;
  7    :NEW.created_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  8    :NEW.created_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
  9    :NEW.updated_by	   := NULL;
 10    :NEW.updated_by_os  := NULL;
 11  END;
 12  /

Trigger created.

SQL> CREATE OR REPLACE TRIGGER sosl_if_script_upd_trg
  2    BEFORE UPDATE ON sosl_if_script
  3    FOR EACH ROW
  4  BEGIN
  5    -- make sure created is not changed
  6    :NEW.created	   := :OLD.created;
  7    :NEW.created_by	   := :OLD.created_by;
  8    :NEW.created_by_os  := :OLD.created_by_os;
  9    :NEW.updated	   := SYSDATE;
 10    :NEW.updated_by	   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
 11    :NEW.updated_by_os  := SYS_CONTEXT('USERENV', 'OS_USER');
 12  END;
 13  /

Trigger created.

SQL> -- wrapper functions
SQL> @@../sosl_ddl/functions/has_scripts.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> CREATE OR REPLACE FUNCTION has_scripts
  2    RETURN NUMBER
  3  IS
  4    /* Wrapper function for defined executor has_scripts functions.
  5    * Collects and sums the output of all defined executor has_scripts functions of active and reviewed executors that
  6    * return a number greater 0. Will log all functions in error.
  7    *
  8    * @return The amount of scripts waiting for all valid executor has_scripts functions or -1 if all functions have errors.
  9    */
 10    l_return 	   NUMBER;
 11    l_self_log_category sosl_server_log.log_category%TYPE := 'HAS_SCRIPTS';
 12    l_self_caller	   sosl_server_log.caller%TYPE	     := 'has_scripts wrapper';
 13  BEGIN
 14    l_return := sosl_sys.has_scripts;
 15    RETURN l_return;
 16  EXCEPTION
 17    WHEN OTHERS THEN
 18  	 -- log the error instead of RAISE
 19  	 sosl_log.exception_log(l_self_caller, l_self_log_category, SQLERRM);
 20  	 RETURN -1;
 21  END;
 22  /

Function created.

SQL> -- grants, everyone can see if scripts are available, inherited by others
SQL> GRANT EXECUTE ON has_scripts TO sosl_guest;

Grant succeeded.

SQL> -- views
SQL> @@../sosl_ddl/views/sosl_run_queue_v.sql
SQL> CREATE OR REPLACE VIEW sosl_run_queue_v
  2  AS
  3    SELECT srq.script_file
  4  	    , sosl_constants.run_state_text(srq.run_state) AS run_state
  5  	    , srq.run_id
  6  	    , srq.ext_script_id
  7  	    , sed.executor_name
  8  	    , srq.created
  9  	    , srq.waiting
 10  	    , srq.enqueued
 11  	    , srq.started
 12  	    , srq.running_since
 13  	    , srq.finished
 14  	    , srq.created_by
 15  	    , srq.waiting_by
 16  	    , srq.enqueued_by
 17  	    , srq.started_by
 18  	    , srq.running_by
 19  	    , srq.finished_by
 20  	    , srq.created_by_os
 21  	    , srq.waiting_by_os
 22  	    , srq.enqueued_by_os
 23  	    , srq.started_by_os
 24  	    , srq.running_by_os
 25  	    , srq.finished_by_os
 26  	    , srq.executor_id
 27  	    , srq.run_state AS run_state_num
 28  	 FROM sosl_run_queue srq
 29  	 LEFT OUTER JOIN sosl_executor_definition sed
 30  	   ON srq.executor_id = sed.executor_id
 31  	ORDER BY created DESC
 32  ;

View created.

SQL> -- load basic config data
SQL> @@sosl_config_defaults.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> -- load default values that can be configured in the database (mandatory)
SQL> -- basic configuration
SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_RUNMODE', 'RUN', 'CHAR', 'Determines if the server should RUN, WAIT or STOP. Read by the SOSL server. RUN will cause the SOSL server, if started to run as long as it does not get a STOP signal from the database. Set it to STOP to stop the SOSL server. Set to WAIT if the server should not call any script apart the check for the run mode. Can be locally overwritten.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_MAX_PARALLEL', '8', 'NUMBER', 'The maximum of parallel started scripts. Read by the SOSL server. After this amount if scripts is started, next scripts are only loaded, if the run count is below this value.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_DEFAULT_WAIT', '1', 'NUMBER', 'Determines the normal sleep time in seconds the sosl server has between calls if scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_NOJOB_WAIT', '120', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if no scripts are available for processing.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_type, config_description)
  3    VALUES
  4    ('SOSL_PAUSE_WAIT', '3600', 'NUMBER', 'Determines the sleep time in seconds the sosl server has between calls if run mode is set to wait.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_SERVER_STATE', 'INACTIVE', 'Information only. SOSL server sets this flag to ACTIVE if started, INACTIVE if stopped and PAUSE if waiting. If server is broken, the state is probably not reflecting the real server state.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_START_JOBS', '22:00', 5, 'Defines the hour:minutes (24 hour format with leading zeros) where SOSL should start running scripts. If set to -1 this parameter is ignored and SOSL server runs until stopped. Otherwise the server will not start to request scripts before this hour. Either both hours are given for start and stop or -1 on one value deactivates the time frame.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_STOP_JOBS', '03:30', 5, 'Defines the hour:minutes (24 hour format with leading zeros) where SOSL should stop running scripts. If set to -1 this parameter is ignored and SOSL server runs until stopped. Otherwise the server will stop to request scripts after this hour. Either both hours are given for start and stop or -1 on one value deactivates the time frame.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_CFG', '..\..\sosl_cfg\', 4000, 'Information only. The relative path with delimiter at path end to configuration files the SOSL server uses for SOSL logins. Set by SOSL server. As configuration files contain credentials and secrets the path should be in a safe space with controlled user rights.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_TMP', '..\..\sosl_tmp\', 239, 'Information only. The relative path with delimiter at path end to temporary files the SOSL server uses. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_PATH_LOG', '..\..\sosl_log\', 239, 'Information only. The relative path with delimiter at path end to log files the SOSL server creates. Set by SOSL server. Parameter for sql files, limited to 239 chars.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_START_LOG', 'sosl_server', 'Information only. The log filename for start and end of SOSL server CMD. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_BASE_LOG', 'sosl_job_', 'Information only. The base log filename for single job runs. Will be extended by GUID. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOG', 'log', 'Information only. The log file extension to use. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_TMP', 'tmp', 'Information only. The log file extension for temporary logs to use. On error those file extension will be renamed to SOSL_EXT_ERROR extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_LOCK', 'lock', 'Information only. The default process lock file extension. Lock files will always get deleted either on service start or after a run. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_description)
  3    VALUES
  4    ('SOSL_EXT_ERROR', 'err', 'Information only. The default process error file extension. Set by SOSL server.')
  5  ;

1 row created.

SQL> INSERT INTO sosl_config
  2    (config_name, config_value, config_max_length, config_description)
  3    VALUES
  4    ('SOSL_SCHEMA', TRIM(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')), 128, 'Information only. The schema SOSL uses. Defined on setup. No update or delete allowed.')
  5  ;

1 row created.

SQL> COMMIT;

Commit complete.

SQL> -- ==============INSTALL done==============
SQL> @@../sosl_sql/util/log_silent.sql
SQL> -- (C) 2024 Michael Lindenau licensed via https://www.gnu.org/licenses/agpl-3.0.txt
SQL> -- Not allowed to be used as AI training material without explicite permission.
SQL> SET ECHO OFF
SUCCESS - no errors found during setup          0
